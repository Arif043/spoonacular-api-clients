<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over 380,000 recipes, thousands of ingredients, 80,000 food products, and 100,000 menu items. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: david@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.spoonacular.client\com.spoonacular;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com.spoonacular.client\ApiException;
use com.spoonacular.client\Configuration;
use com.spoonacular.client\HeaderSelector;
use com.spoonacular.client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation analyzeARecipeSearchQuery
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function analyzeARecipeSearchQuery($q)
    {
        list($response) = $this->analyzeARecipeSearchQueryWithHttpInfo($q);
        return $response;
    }

    /**
     * Operation analyzeARecipeSearchQueryWithHttpInfo
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeARecipeSearchQueryWithHttpInfo($q)
    {
        $request = $this->analyzeARecipeSearchQueryRequest($q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeARecipeSearchQueryAsync
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeARecipeSearchQueryAsync($q)
    {
        return $this->analyzeARecipeSearchQueryAsyncWithHttpInfo($q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeARecipeSearchQueryAsyncWithHttpInfo
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeARecipeSearchQueryAsyncWithHttpInfo($q)
    {
        $returnType = 'object';
        $request = $this->analyzeARecipeSearchQueryRequest($q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeARecipeSearchQuery'
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function analyzeARecipeSearchQueryRequest($q)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling analyzeARecipeSearchQuery'
            );
        }

        $resourcePath = '/recipes/queries/analyze';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation analyzeRecipeInstructions
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The instructions text. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function analyzeRecipeInstructions($instructions)
    {
        list($response) = $this->analyzeRecipeInstructionsWithHttpInfo($instructions);
        return $response;
    }

    /**
     * Operation analyzeRecipeInstructionsWithHttpInfo
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The instructions text. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeRecipeInstructionsWithHttpInfo($instructions)
    {
        $request = $this->analyzeRecipeInstructionsRequest($instructions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeRecipeInstructionsAsync
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The instructions text. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeInstructionsAsync($instructions)
    {
        return $this->analyzeRecipeInstructionsAsyncWithHttpInfo($instructions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeRecipeInstructionsAsyncWithHttpInfo
     *
     * Analyze Recipe Instructions
     *
     * @param  string $instructions The instructions text. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeInstructionsAsyncWithHttpInfo($instructions)
    {
        $returnType = 'object';
        $request = $this->analyzeRecipeInstructionsRequest($instructions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeRecipeInstructions'
     *
     * @param  string $instructions The instructions text. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function analyzeRecipeInstructionsRequest($instructions)
    {
        // verify the required parameter 'instructions' is set
        if ($instructions === null || (is_array($instructions) && count($instructions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instructions when calling analyzeRecipeInstructions'
            );
        }

        $resourcePath = '/recipes/analyzeInstructions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($instructions !== null) {
            $formParams['instructions'] = ObjectSerializer::toFormValue($instructions);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteIngredientSearch
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The query - a partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  bool $intolerances A comma-separated list of intolerances. All found ingredients must not cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function autocompleteIngredientSearch($query, $number = null, $meta_information = null, $intolerances = null)
    {
        list($response) = $this->autocompleteIngredientSearchWithHttpInfo($query, $number, $meta_information, $intolerances);
        return $response;
    }

    /**
     * Operation autocompleteIngredientSearchWithHttpInfo
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The query - a partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  bool $intolerances A comma-separated list of intolerances. All found ingredients must not cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteIngredientSearchWithHttpInfo($query, $number = null, $meta_information = null, $intolerances = null)
    {
        $request = $this->autocompleteIngredientSearchRequest($query, $number, $meta_information, $intolerances);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteIngredientSearchAsync
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The query - a partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  bool $intolerances A comma-separated list of intolerances. All found ingredients must not cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteIngredientSearchAsync($query, $number = null, $meta_information = null, $intolerances = null)
    {
        return $this->autocompleteIngredientSearchAsyncWithHttpInfo($query, $number, $meta_information, $intolerances)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteIngredientSearchAsyncWithHttpInfo
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The query - a partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  bool $intolerances A comma-separated list of intolerances. All found ingredients must not cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteIngredientSearchAsyncWithHttpInfo($query, $number = null, $meta_information = null, $intolerances = null)
    {
        $returnType = 'object';
        $request = $this->autocompleteIngredientSearchRequest($query, $number, $meta_information, $intolerances);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteIngredientSearch'
     *
     * @param  string $query The query - a partial or full ingredient name. (required)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  bool $intolerances A comma-separated list of intolerances. All found ingredients must not cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function autocompleteIngredientSearchRequest($query, $number = null, $meta_information = null, $intolerances = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteIngredientSearch'
            );
        }

        $resourcePath = '/food/ingredients/autocomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($meta_information !== null) {
            $queryParams['metaInformation'] = ObjectSerializer::toQueryValue($meta_information);
        }
        // query params
        if ($intolerances !== null) {
            $queryParams['intolerances'] = ObjectSerializer::toQueryValue($intolerances);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteMenuItemSearch
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function autocompleteMenuItemSearch($query, $number = null)
    {
        list($response) = $this->autocompleteMenuItemSearchWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation autocompleteMenuItemSearchWithHttpInfo
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteMenuItemSearchWithHttpInfo($query, $number = null)
    {
        $request = $this->autocompleteMenuItemSearchRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteMenuItemSearchAsync
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteMenuItemSearchAsync($query, $number = null)
    {
        return $this->autocompleteMenuItemSearchAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteMenuItemSearchAsyncWithHttpInfo
     *
     * Autocomplete Menu Item Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteMenuItemSearchAsyncWithHttpInfo($query, $number = null)
    {
        $returnType = 'object';
        $request = $this->autocompleteMenuItemSearchRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteMenuItemSearch'
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function autocompleteMenuItemSearchRequest($query, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteMenuItemSearch'
            );
        }

        $resourcePath = '/food/menuItems/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteProductSearch
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function autocompleteProductSearch($query, $number = null)
    {
        list($response) = $this->autocompleteProductSearchWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation autocompleteProductSearchWithHttpInfo
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteProductSearchWithHttpInfo($query, $number = null)
    {
        $request = $this->autocompleteProductSearchRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteProductSearchAsync
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteProductSearchAsync($query, $number = null)
    {
        return $this->autocompleteProductSearchAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteProductSearchAsyncWithHttpInfo
     *
     * Autocomplete Product Search
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteProductSearchAsyncWithHttpInfo($query, $number = null)
    {
        $returnType = 'object';
        $request = $this->autocompleteProductSearchRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteProductSearch'
     *
     * @param  string $query The (partial) search query. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function autocompleteProductSearchRequest($query, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteProductSearch'
            );
        }

        $resourcePath = '/food/products/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteRecipeSearch
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function autocompleteRecipeSearch($query, $number = null)
    {
        list($response) = $this->autocompleteRecipeSearchWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation autocompleteRecipeSearchWithHttpInfo
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteRecipeSearchWithHttpInfo($query, $number = null)
    {
        $request = $this->autocompleteRecipeSearchRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteRecipeSearchAsync
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteRecipeSearchAsync($query, $number = null)
    {
        return $this->autocompleteRecipeSearchAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteRecipeSearchAsyncWithHttpInfo
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteRecipeSearchAsyncWithHttpInfo($query, $number = null)
    {
        $returnType = 'object';
        $request = $this->autocompleteRecipeSearchRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteRecipeSearch'
     *
     * @param  string $query The query to be autocompleted. (required)
     * @param  float $number The number of results to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function autocompleteRecipeSearchRequest($query, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling autocompleteRecipeSearch'
            );
        }

        $resourcePath = '/recipes/autocomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyCuisine
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function classifyCuisine($title, $ingredient_list)
    {
        list($response) = $this->classifyCuisineWithHttpInfo($title, $ingredient_list);
        return $response;
    }

    /**
     * Operation classifyCuisineWithHttpInfo
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyCuisineWithHttpInfo($title, $ingredient_list)
    {
        $request = $this->classifyCuisineRequest($title, $ingredient_list);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyCuisineAsync
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyCuisineAsync($title, $ingredient_list)
    {
        return $this->classifyCuisineAsyncWithHttpInfo($title, $ingredient_list)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyCuisineAsyncWithHttpInfo
     *
     * Classify Cuisine
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyCuisineAsyncWithHttpInfo($title, $ingredient_list)
    {
        $returnType = 'object';
        $request = $this->classifyCuisineRequest($title, $ingredient_list);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyCuisine'
     *
     * @param  string $title The title of the recipe. (required)
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function classifyCuisineRequest($title, $ingredient_list)
    {
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling classifyCuisine'
            );
        }
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling classifyCuisine'
            );
        }

        $resourcePath = '/recipes/cuisine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($title !== null) {
            $formParams['title'] = ObjectSerializer::toFormValue($title);
        }
        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyGroceryProduct
     *
     * Classify Grocery Product
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject8 $inline_object8 inline_object8 (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function classifyGroceryProduct($inline_object8, $locale = null)
    {
        list($response) = $this->classifyGroceryProductWithHttpInfo($inline_object8, $locale);
        return $response;
    }

    /**
     * Operation classifyGroceryProductWithHttpInfo
     *
     * Classify Grocery Product
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject8 $inline_object8 (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyGroceryProductWithHttpInfo($inline_object8, $locale = null)
    {
        $request = $this->classifyGroceryProductRequest($inline_object8, $locale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyGroceryProductAsync
     *
     * Classify Grocery Product
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject8 $inline_object8 (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductAsync($inline_object8, $locale = null)
    {
        return $this->classifyGroceryProductAsyncWithHttpInfo($inline_object8, $locale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyGroceryProductAsyncWithHttpInfo
     *
     * Classify Grocery Product
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject8 $inline_object8 (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductAsyncWithHttpInfo($inline_object8, $locale = null)
    {
        $returnType = 'object';
        $request = $this->classifyGroceryProductRequest($inline_object8, $locale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyGroceryProduct'
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\InlineObject8 $inline_object8 (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function classifyGroceryProductRequest($inline_object8, $locale = null)
    {
        // verify the required parameter 'inline_object8' is set
        if ($inline_object8 === null || (is_array($inline_object8) && count($inline_object8) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inline_object8 when calling classifyGroceryProduct'
            );
        }

        $resourcePath = '/food/products/classify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locale !== null) {
            $queryParams['locale'] = ObjectSerializer::toQueryValue($locale);
        }


        // body params
        $_tempBody = null;
        if (isset($inline_object8)) {
            $_tempBody = $inline_object8;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyGroceryProductBulk
     *
     * Classify Grocery Product Bulk
     *
     * @param  object $body body (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function classifyGroceryProductBulk($body, $locale = null)
    {
        list($response) = $this->classifyGroceryProductBulkWithHttpInfo($body, $locale);
        return $response;
    }

    /**
     * Operation classifyGroceryProductBulkWithHttpInfo
     *
     * Classify Grocery Product Bulk
     *
     * @param  object $body (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyGroceryProductBulkWithHttpInfo($body, $locale = null)
    {
        $request = $this->classifyGroceryProductBulkRequest($body, $locale);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyGroceryProductBulkAsync
     *
     * Classify Grocery Product Bulk
     *
     * @param  object $body (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductBulkAsync($body, $locale = null)
    {
        return $this->classifyGroceryProductBulkAsyncWithHttpInfo($body, $locale)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyGroceryProductBulkAsyncWithHttpInfo
     *
     * Classify Grocery Product Bulk
     *
     * @param  object $body (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyGroceryProductBulkAsyncWithHttpInfo($body, $locale = null)
    {
        $returnType = 'object';
        $request = $this->classifyGroceryProductBulkRequest($body, $locale);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyGroceryProductBulk'
     *
     * @param  object $body (required)
     * @param  string $locale The locale of the returned category, supported is en_US and en_GB. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function classifyGroceryProductBulkRequest($body, $locale = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling classifyGroceryProductBulk'
            );
        }

        $resourcePath = '/food/products/classifyBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locale !== null) {
            $queryParams['locale'] = ObjectSerializer::toQueryValue($locale);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation convertAmounts
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function convertAmounts($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        list($response) = $this->convertAmountsWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit);
        return $response;
    }

    /**
     * Operation convertAmountsWithHttpInfo
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function convertAmountsWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        $request = $this->convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation convertAmountsAsync
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertAmountsAsync($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        return $this->convertAmountsAsyncWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation convertAmountsAsyncWithHttpInfo
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertAmountsAsyncWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        $returnType = 'object';
        $request = $this->convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'convertAmounts'
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        // verify the required parameter 'ingredient_name' is set
        if ($ingredient_name === null || (is_array($ingredient_name) && count($ingredient_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_name when calling convertAmounts'
            );
        }
        // verify the required parameter 'source_amount' is set
        if ($source_amount === null || (is_array($source_amount) && count($source_amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_amount when calling convertAmounts'
            );
        }
        // verify the required parameter 'source_unit' is set
        if ($source_unit === null || (is_array($source_unit) && count($source_unit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_unit when calling convertAmounts'
            );
        }
        // verify the required parameter 'target_unit' is set
        if ($target_unit === null || (is_array($target_unit) && count($target_unit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_unit when calling convertAmounts'
            );
        }

        $resourcePath = '/recipes/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ingredient_name !== null) {
            $queryParams['ingredientName'] = ObjectSerializer::toQueryValue($ingredient_name);
        }
        // query params
        if ($source_amount !== null) {
            $queryParams['sourceAmount'] = ObjectSerializer::toQueryValue($source_amount);
        }
        // query params
        if ($source_unit !== null) {
            $queryParams['sourceUnit'] = ObjectSerializer::toQueryValue($source_unit);
        }
        // query params
        if ($target_unit !== null) {
            $queryParams['targetUnit'] = ObjectSerializer::toQueryValue($target_unit);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRecipeCard
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color on the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color on the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createRecipeCard($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        list($response) = $this->createRecipeCardWithHttpInfo($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author, $background_color, $font_color, $source);
        return $response;
    }

    /**
     * Operation createRecipeCardWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color on the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color on the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRecipeCardWithHttpInfo($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        $request = $this->createRecipeCardRequest($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author, $background_color, $font_color, $source);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRecipeCardAsync
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color on the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color on the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardAsync($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        return $this->createRecipeCardAsyncWithHttpInfo($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author, $background_color, $font_color, $source)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRecipeCardAsyncWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color on the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color on the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardAsyncWithHttpInfo($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        $returnType = 'object';
        $request = $this->createRecipeCardRequest($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author, $background_color, $font_color, $source);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRecipeCard'
     *
     * @param  string $title The title of the recipe. (required)
     * @param  \SplFileObject $image The binary image of the recipe as jpg. (required)
     * @param  string $ingredients The ingredient list of the recipe, one ingredient per line (separate lines with \\\\n). (required)
     * @param  string $instructions The instructions to make the recipe. One step per line (separate lines with \\\\n). (required)
     * @param  float $ready_in_minutes The number of minutes it takes to get the recipe on the table. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  string $mask The mask to put over the recipe image (\\\&quot;ellipseMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;diamondMask\\\&quot;, \\\&quot;starMask\\\&quot;, \\\&quot;heartMask\\\&quot;, \\\&quot;potMask\\\&quot;, \\\&quot;fishMask\\\&quot;). (required)
     * @param  string $background_image The background image (\\\&quot;none\\\&quot;,\\\&quot;background1\\\&quot;, or \\\&quot;background2\\\&quot;). (required)
     * @param  string $author The author of the recipe. (optional)
     * @param  string $background_color The background color on the recipe card as a hex-string. (optional)
     * @param  string $font_color The font color on the recipe card as a hex-string. (optional)
     * @param  string $source The source of the recipe. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRecipeCardRequest($title, $image, $ingredients, $instructions, $ready_in_minutes, $servings, $mask, $background_image, $author = null, $background_color = null, $font_color = null, $source = null)
    {
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling createRecipeCard'
            );
        }
        // verify the required parameter 'image' is set
        if ($image === null || (is_array($image) && count($image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling createRecipeCard'
            );
        }
        // verify the required parameter 'ingredients' is set
        if ($ingredients === null || (is_array($ingredients) && count($ingredients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredients when calling createRecipeCard'
            );
        }
        // verify the required parameter 'instructions' is set
        if ($instructions === null || (is_array($instructions) && count($instructions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instructions when calling createRecipeCard'
            );
        }
        // verify the required parameter 'ready_in_minutes' is set
        if ($ready_in_minutes === null || (is_array($ready_in_minutes) && count($ready_in_minutes) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ready_in_minutes when calling createRecipeCard'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling createRecipeCard'
            );
        }
        // verify the required parameter 'mask' is set
        if ($mask === null || (is_array($mask) && count($mask) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mask when calling createRecipeCard'
            );
        }
        // verify the required parameter 'background_image' is set
        if ($background_image === null || (is_array($background_image) && count($background_image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $background_image when calling createRecipeCard'
            );
        }

        $resourcePath = '/recipes/visualizeRecipe';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($title !== null) {
            $formParams['title'] = ObjectSerializer::toFormValue($title);
        }
        // form params
        if ($image !== null) {
            $multipart = true;
            $formParams['image'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($image), 'rb');
        }
        // form params
        if ($ingredients !== null) {
            $formParams['ingredients'] = ObjectSerializer::toFormValue($ingredients);
        }
        // form params
        if ($instructions !== null) {
            $formParams['instructions'] = ObjectSerializer::toFormValue($instructions);
        }
        // form params
        if ($ready_in_minutes !== null) {
            $formParams['readyInMinutes'] = ObjectSerializer::toFormValue($ready_in_minutes);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($mask !== null) {
            $formParams['mask'] = ObjectSerializer::toFormValue($mask);
        }
        // form params
        if ($background_image !== null) {
            $formParams['backgroundImage'] = ObjectSerializer::toFormValue($background_image);
        }
        // form params
        if ($author !== null) {
            $formParams['author'] = ObjectSerializer::toFormValue($author);
        }
        // form params
        if ($background_color !== null) {
            $formParams['backgroundColor'] = ObjectSerializer::toFormValue($background_color);
        }
        // form params
        if ($font_color !== null) {
            $formParams['fontColor'] = ObjectSerializer::toFormValue($font_color);
        }
        // form params
        if ($source !== null) {
            $formParams['source'] = ObjectSerializer::toFormValue($source);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation detectFoodInText
     *
     * Detect Food in Text
     *
     * @param  string $text The text in which food items such as dish names and ingredients should be detected in. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function detectFoodInText($text)
    {
        list($response) = $this->detectFoodInTextWithHttpInfo($text);
        return $response;
    }

    /**
     * Operation detectFoodInTextWithHttpInfo
     *
     * Detect Food in Text
     *
     * @param  string $text The text in which food items such as dish names and ingredients should be detected in. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function detectFoodInTextWithHttpInfo($text)
    {
        $request = $this->detectFoodInTextRequest($text);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation detectFoodInTextAsync
     *
     * Detect Food in Text
     *
     * @param  string $text The text in which food items such as dish names and ingredients should be detected in. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectFoodInTextAsync($text)
    {
        return $this->detectFoodInTextAsyncWithHttpInfo($text)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation detectFoodInTextAsyncWithHttpInfo
     *
     * Detect Food in Text
     *
     * @param  string $text The text in which food items such as dish names and ingredients should be detected in. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectFoodInTextAsyncWithHttpInfo($text)
    {
        $returnType = 'object';
        $request = $this->detectFoodInTextRequest($text);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'detectFoodInText'
     *
     * @param  string $text The text in which food items such as dish names and ingredients should be detected in. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function detectFoodInTextRequest($text)
    {
        // verify the required parameter 'text' is set
        if ($text === null || (is_array($text) && count($text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text when calling detectFoodInText'
            );
        }

        $resourcePath = '/food/detect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($text !== null) {
            $formParams['text'] = ObjectSerializer::toFormValue($text);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractRecipeFromWebsite
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered no matter whether we know the recipe already. Use that only if information is missing as this operation is slower. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function extractRecipeFromWebsite($url, $force_extraction = null)
    {
        list($response) = $this->extractRecipeFromWebsiteWithHttpInfo($url, $force_extraction);
        return $response;
    }

    /**
     * Operation extractRecipeFromWebsiteWithHttpInfo
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered no matter whether we know the recipe already. Use that only if information is missing as this operation is slower. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractRecipeFromWebsiteWithHttpInfo($url, $force_extraction = null)
    {
        $request = $this->extractRecipeFromWebsiteRequest($url, $force_extraction);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extractRecipeFromWebsiteAsync
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered no matter whether we know the recipe already. Use that only if information is missing as this operation is slower. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractRecipeFromWebsiteAsync($url, $force_extraction = null)
    {
        return $this->extractRecipeFromWebsiteAsyncWithHttpInfo($url, $force_extraction)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractRecipeFromWebsiteAsyncWithHttpInfo
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered no matter whether we know the recipe already. Use that only if information is missing as this operation is slower. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractRecipeFromWebsiteAsyncWithHttpInfo($url, $force_extraction = null)
    {
        $returnType = 'object';
        $request = $this->extractRecipeFromWebsiteRequest($url, $force_extraction);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractRecipeFromWebsite'
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered no matter whether we know the recipe already. Use that only if information is missing as this operation is slower. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function extractRecipeFromWebsiteRequest($url, $force_extraction = null)
    {
        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling extractRecipeFromWebsite'
            );
        }

        $resourcePath = '/recipes/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($force_extraction !== null) {
            $queryParams['forceExtraction'] = ObjectSerializer::toQueryValue($force_extraction);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateMealPlan
     *
     * Generate Meal Plan
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function generateMealPlan($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {
        list($response) = $this->generateMealPlanWithHttpInfo($time_frame, $target_calories, $diet, $exclude);
        return $response;
    }

    /**
     * Operation generateMealPlanWithHttpInfo
     *
     * Generate Meal Plan
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateMealPlanWithHttpInfo($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {
        $request = $this->generateMealPlanRequest($time_frame, $target_calories, $diet, $exclude);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateMealPlanAsync
     *
     * Generate Meal Plan
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateMealPlanAsync($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {
        return $this->generateMealPlanAsyncWithHttpInfo($time_frame, $target_calories, $diet, $exclude)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateMealPlanAsyncWithHttpInfo
     *
     * Generate Meal Plan
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateMealPlanAsyncWithHttpInfo($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {
        $returnType = 'object';
        $request = $this->generateMealPlanRequest($time_frame, $target_calories, $diet, $exclude);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateMealPlan'
     *
     * @param  string $time_frame Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;. (optional)
     * @param  float $target_calories What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal. (optional)
     * @param  string $diet Enter a diet that the meal plan has to adhere to. See a full list of supported diets. (optional)
     * @param  string $exclude A comma-separated list of allergens or ingredients that must be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function generateMealPlanRequest($time_frame = null, $target_calories = null, $diet = null, $exclude = null)
    {

        $resourcePath = '/recipes/mealplans/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($time_frame !== null) {
            $queryParams['timeFrame'] = ObjectSerializer::toQueryValue($time_frame);
        }
        // query params
        if ($target_calories !== null) {
            $queryParams['targetCalories'] = ObjectSerializer::toQueryValue($target_calories);
        }
        // query params
        if ($diet !== null) {
            $queryParams['diet'] = ObjectSerializer::toQueryValue($diet);
        }
        // query params
        if ($exclude !== null) {
            $queryParams['exclude'] = ObjectSerializer::toQueryValue($exclude);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getARandomFoodJoke
     *
     * Get a Random Food Joke
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getARandomFoodJoke()
    {
        list($response) = $this->getARandomFoodJokeWithHttpInfo();
        return $response;
    }

    /**
     * Operation getARandomFoodJokeWithHttpInfo
     *
     * Get a Random Food Joke
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getARandomFoodJokeWithHttpInfo()
    {
        $request = $this->getARandomFoodJokeRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getARandomFoodJokeAsync
     *
     * Get a Random Food Joke
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARandomFoodJokeAsync()
    {
        return $this->getARandomFoodJokeAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getARandomFoodJokeAsyncWithHttpInfo
     *
     * Get a Random Food Joke
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARandomFoodJokeAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->getARandomFoodJokeRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getARandomFoodJoke'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getARandomFoodJokeRequest()
    {

        $resourcePath = '/food/jokes/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnalyzedRecipeInstructions
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getAnalyzedRecipeInstructions($id, $step_breakdown = null)
    {
        list($response) = $this->getAnalyzedRecipeInstructionsWithHttpInfo($id, $step_breakdown);
        return $response;
    }

    /**
     * Operation getAnalyzedRecipeInstructionsWithHttpInfo
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnalyzedRecipeInstructionsWithHttpInfo($id, $step_breakdown = null)
    {
        $request = $this->getAnalyzedRecipeInstructionsRequest($id, $step_breakdown);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnalyzedRecipeInstructionsAsync
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyzedRecipeInstructionsAsync($id, $step_breakdown = null)
    {
        return $this->getAnalyzedRecipeInstructionsAsyncWithHttpInfo($id, $step_breakdown)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnalyzedRecipeInstructionsAsyncWithHttpInfo
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyzedRecipeInstructionsAsyncWithHttpInfo($id, $step_breakdown = null)
    {
        $returnType = 'object';
        $request = $this->getAnalyzedRecipeInstructionsRequest($id, $step_breakdown);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnalyzedRecipeInstructions'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAnalyzedRecipeInstructionsRequest($id, $step_breakdown = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAnalyzedRecipeInstructions'
            );
        }

        $resourcePath = '/recipes/{id}/analyzedInstructions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($step_breakdown !== null) {
            $queryParams['stepBreakdown'] = ObjectSerializer::toQueryValue($step_breakdown);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getComparableProducts
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for that you want to find comparable products. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getComparableProducts($upc)
    {
        list($response) = $this->getComparableProductsWithHttpInfo($upc);
        return $response;
    }

    /**
     * Operation getComparableProductsWithHttpInfo
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for that you want to find comparable products. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getComparableProductsWithHttpInfo($upc)
    {
        $request = $this->getComparableProductsRequest($upc);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getComparableProductsAsync
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for that you want to find comparable products. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getComparableProductsAsync($upc)
    {
        return $this->getComparableProductsAsyncWithHttpInfo($upc)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getComparableProductsAsyncWithHttpInfo
     *
     * Get Comparable Products
     *
     * @param  float $upc The UPC of the product for that you want to find comparable products. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getComparableProductsAsyncWithHttpInfo($upc)
    {
        $returnType = 'object';
        $request = $this->getComparableProductsRequest($upc);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getComparableProducts'
     *
     * @param  float $upc The UPC of the product for that you want to find comparable products. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getComparableProductsRequest($upc)
    {
        // verify the required parameter 'upc' is set
        if ($upc === null || (is_array($upc) && count($upc) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upc when calling getComparableProducts'
            );
        }

        $resourcePath = '/food/products/upc/{upc}/comparable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($upc !== null) {
            $resourcePath = str_replace(
                '{' . 'upc' . '}',
                ObjectSerializer::toPathValue($upc),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationSuggests
     *
     * Get Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getConversationSuggests($query, $number = null)
    {
        list($response) = $this->getConversationSuggestsWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation getConversationSuggestsWithHttpInfo
     *
     * Get Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationSuggestsWithHttpInfo($query, $number = null)
    {
        $request = $this->getConversationSuggestsRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationSuggestsAsync
     *
     * Get Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationSuggestsAsync($query, $number = null)
    {
        return $this->getConversationSuggestsAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationSuggestsAsyncWithHttpInfo
     *
     * Get Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationSuggestsAsyncWithHttpInfo($query, $number = null)
    {
        $returnType = 'object';
        $request = $this->getConversationSuggestsRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationSuggests'
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationSuggestsRequest($query, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling getConversationSuggests'
            );
        }

        $resourcePath = '/food/converse/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDishPairingForWine
     *
     * Get Dish Pairing for Wine
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDishPairingForWine($wine)
    {
        list($response) = $this->getDishPairingForWineWithHttpInfo($wine);
        return $response;
    }

    /**
     * Operation getDishPairingForWineWithHttpInfo
     *
     * Get Dish Pairing for Wine
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDishPairingForWineWithHttpInfo($wine)
    {
        $request = $this->getDishPairingForWineRequest($wine);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDishPairingForWineAsync
     *
     * Get Dish Pairing for Wine
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDishPairingForWineAsync($wine)
    {
        return $this->getDishPairingForWineAsyncWithHttpInfo($wine)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDishPairingForWineAsyncWithHttpInfo
     *
     * Get Dish Pairing for Wine
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDishPairingForWineAsyncWithHttpInfo($wine)
    {
        $returnType = 'object';
        $request = $this->getDishPairingForWineRequest($wine);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDishPairingForWine'
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDishPairingForWineRequest($wine)
    {
        // verify the required parameter 'wine' is set
        if ($wine === null || (is_array($wine) && count($wine) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wine when calling getDishPairingForWine'
            );
        }

        $resourcePath = '/food/wine/dishes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($wine !== null) {
            $queryParams['wine'] = ObjectSerializer::toQueryValue($wine);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFoodInformation
     *
     * Get Food Information
     *
     * @param  float $id The id of the food / ingredient. (required)
     * @param  float $amount The amount of that food. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getFoodInformation($id, $amount = null, $unit = null)
    {
        list($response) = $this->getFoodInformationWithHttpInfo($id, $amount, $unit);
        return $response;
    }

    /**
     * Operation getFoodInformationWithHttpInfo
     *
     * Get Food Information
     *
     * @param  float $id The id of the food / ingredient. (required)
     * @param  float $amount The amount of that food. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFoodInformationWithHttpInfo($id, $amount = null, $unit = null)
    {
        $request = $this->getFoodInformationRequest($id, $amount, $unit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFoodInformationAsync
     *
     * Get Food Information
     *
     * @param  float $id The id of the food / ingredient. (required)
     * @param  float $amount The amount of that food. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFoodInformationAsync($id, $amount = null, $unit = null)
    {
        return $this->getFoodInformationAsyncWithHttpInfo($id, $amount, $unit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFoodInformationAsyncWithHttpInfo
     *
     * Get Food Information
     *
     * @param  float $id The id of the food / ingredient. (required)
     * @param  float $amount The amount of that food. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFoodInformationAsyncWithHttpInfo($id, $amount = null, $unit = null)
    {
        $returnType = 'object';
        $request = $this->getFoodInformationRequest($id, $amount, $unit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFoodInformation'
     *
     * @param  float $id The id of the food / ingredient. (required)
     * @param  float $amount The amount of that food. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFoodInformationRequest($id, $amount = null, $unit = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFoodInformation'
            );
        }

        $resourcePath = '/food/ingredients/{id}/information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($amount !== null) {
            $queryParams['amount'] = ObjectSerializer::toQueryValue($amount);
        }
        // query params
        if ($unit !== null) {
            $queryParams['unit'] = ObjectSerializer::toQueryValue($unit);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIngredientSubstitutes
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getIngredientSubstitutes($ingredient_name)
    {
        list($response) = $this->getIngredientSubstitutesWithHttpInfo($ingredient_name);
        return $response;
    }

    /**
     * Operation getIngredientSubstitutesWithHttpInfo
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIngredientSubstitutesWithHttpInfo($ingredient_name)
    {
        $request = $this->getIngredientSubstitutesRequest($ingredient_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIngredientSubstitutesAsync
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesAsync($ingredient_name)
    {
        return $this->getIngredientSubstitutesAsyncWithHttpInfo($ingredient_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIngredientSubstitutesAsyncWithHttpInfo
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesAsyncWithHttpInfo($ingredient_name)
    {
        $returnType = 'object';
        $request = $this->getIngredientSubstitutesRequest($ingredient_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIngredientSubstitutes'
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIngredientSubstitutesRequest($ingredient_name)
    {
        // verify the required parameter 'ingredient_name' is set
        if ($ingredient_name === null || (is_array($ingredient_name) && count($ingredient_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_name when calling getIngredientSubstitutes'
            );
        }

        $resourcePath = '/food/ingredients/substitutes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ingredient_name !== null) {
            $queryParams['ingredientName'] = ObjectSerializer::toQueryValue($ingredient_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIngredientSubstitutesByID
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getIngredientSubstitutesByID($id)
    {
        list($response) = $this->getIngredientSubstitutesByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getIngredientSubstitutesByIDWithHttpInfo
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIngredientSubstitutesByIDWithHttpInfo($id)
    {
        $request = $this->getIngredientSubstitutesByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIngredientSubstitutesByIDAsync
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesByIDAsync($id)
    {
        return $this->getIngredientSubstitutesByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIngredientSubstitutesByIDAsyncWithHttpInfo
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getIngredientSubstitutesByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIngredientSubstitutesByID'
     *
     * @param  float $id The id of the ingredient you want substitutes for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIngredientSubstitutesByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getIngredientSubstitutesByID'
            );
        }

        $resourcePath = '/food/ingredients/{id}/substitutes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMenuItemInformation
     *
     * Get Menu Item Information
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getMenuItemInformation($id)
    {
        list($response) = $this->getMenuItemInformationWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getMenuItemInformationWithHttpInfo
     *
     * Get Menu Item Information
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMenuItemInformationWithHttpInfo($id)
    {
        $request = $this->getMenuItemInformationRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMenuItemInformationAsync
     *
     * Get Menu Item Information
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuItemInformationAsync($id)
    {
        return $this->getMenuItemInformationAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMenuItemInformationAsyncWithHttpInfo
     *
     * Get Menu Item Information
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMenuItemInformationAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getMenuItemInformationRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMenuItemInformation'
     *
     * @param  float $id The menu item id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMenuItemInformationRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMenuItemInformation'
            );
        }

        $resourcePath = '/food/menuItems/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProductInformation
     *
     * Get Product Information
     *
     * @param  float $id The id of the packaged food product. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getProductInformation($id)
    {
        list($response) = $this->getProductInformationWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getProductInformationWithHttpInfo
     *
     * Get Product Information
     *
     * @param  float $id The id of the packaged food product. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductInformationWithHttpInfo($id)
    {
        $request = $this->getProductInformationRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProductInformationAsync
     *
     * Get Product Information
     *
     * @param  float $id The id of the packaged food product. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductInformationAsync($id)
    {
        return $this->getProductInformationAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductInformationAsyncWithHttpInfo
     *
     * Get Product Information
     *
     * @param  float $id The id of the packaged food product. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProductInformationAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getProductInformationRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProductInformation'
     *
     * @param  float $id The id of the packaged food product. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProductInformationRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProductInformation'
            );
        }

        $resourcePath = '/food/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRandomFoodTrivia
     *
     * Get Random Food Trivia
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRandomFoodTrivia()
    {
        list($response) = $this->getRandomFoodTriviaWithHttpInfo();
        return $response;
    }

    /**
     * Operation getRandomFoodTriviaWithHttpInfo
     *
     * Get Random Food Trivia
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRandomFoodTriviaWithHttpInfo()
    {
        $request = $this->getRandomFoodTriviaRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRandomFoodTriviaAsync
     *
     * Get Random Food Trivia
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomFoodTriviaAsync()
    {
        return $this->getRandomFoodTriviaAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRandomFoodTriviaAsyncWithHttpInfo
     *
     * Get Random Food Trivia
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomFoodTriviaAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->getRandomFoodTriviaRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRandomFoodTrivia'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRandomFoodTriviaRequest()
    {

        $resourcePath = '/food/trivia/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRandomRecipes
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must adhere to. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRandomRecipes($limit_license = null, $tags = null, $number = null)
    {
        list($response) = $this->getRandomRecipesWithHttpInfo($limit_license, $tags, $number);
        return $response;
    }

    /**
     * Operation getRandomRecipesWithHttpInfo
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must adhere to. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRandomRecipesWithHttpInfo($limit_license = null, $tags = null, $number = null)
    {
        $request = $this->getRandomRecipesRequest($limit_license, $tags, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRandomRecipesAsync
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must adhere to. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomRecipesAsync($limit_license = null, $tags = null, $number = null)
    {
        return $this->getRandomRecipesAsyncWithHttpInfo($limit_license, $tags, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRandomRecipesAsyncWithHttpInfo
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must adhere to. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomRecipesAsyncWithHttpInfo($limit_license = null, $tags = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->getRandomRecipesRequest($limit_license, $tags, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRandomRecipes'
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must adhere to. (optional)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRandomRecipesRequest($limit_license = null, $tags = null, $number = null)
    {

        $resourcePath = '/recipes/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }
        // query params
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeEquipmentByID
     *
     * Get Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeEquipmentByID($id)
    {
        list($response) = $this->getRecipeEquipmentByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeEquipmentByIDWithHttpInfo
     *
     * Get Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeEquipmentByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeEquipmentByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeEquipmentByIDAsync
     *
     * Get Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeEquipmentByIDAsync($id)
    {
        return $this->getRecipeEquipmentByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeEquipmentByIDAsyncWithHttpInfo
     *
     * Get Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeEquipmentByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getRecipeEquipmentByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeEquipmentByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeEquipmentByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeEquipmentByID'
            );
        }

        $resourcePath = '/recipes/{id}/equipmentWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeInformation
     *
     * Get Recipe Information
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeInformation($id, $include_nutrition = null)
    {
        list($response) = $this->getRecipeInformationWithHttpInfo($id, $include_nutrition);
        return $response;
    }

    /**
     * Operation getRecipeInformationWithHttpInfo
     *
     * Get Recipe Information
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeInformationWithHttpInfo($id, $include_nutrition = null)
    {
        $request = $this->getRecipeInformationRequest($id, $include_nutrition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeInformationAsync
     *
     * Get Recipe Information
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationAsync($id, $include_nutrition = null)
    {
        return $this->getRecipeInformationAsyncWithHttpInfo($id, $include_nutrition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeInformationAsyncWithHttpInfo
     *
     * Get Recipe Information
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationAsyncWithHttpInfo($id, $include_nutrition = null)
    {
        $returnType = 'object';
        $request = $this->getRecipeInformationRequest($id, $include_nutrition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeInformation'
     *
     * @param  float $id The id of the recipe. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeInformationRequest($id, $include_nutrition = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeInformation'
            );
        }

        $resourcePath = '/recipes/{id}/information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_nutrition !== null) {
            $queryParams['includeNutrition'] = ObjectSerializer::toQueryValue($include_nutrition);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeInformationBulk
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeInformationBulk($ids, $include_nutrition = null)
    {
        list($response) = $this->getRecipeInformationBulkWithHttpInfo($ids, $include_nutrition);
        return $response;
    }

    /**
     * Operation getRecipeInformationBulkWithHttpInfo
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeInformationBulkWithHttpInfo($ids, $include_nutrition = null)
    {
        $request = $this->getRecipeInformationBulkRequest($ids, $include_nutrition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeInformationBulkAsync
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationBulkAsync($ids, $include_nutrition = null)
    {
        return $this->getRecipeInformationBulkAsyncWithHttpInfo($ids, $include_nutrition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeInformationBulkAsyncWithHttpInfo
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationBulkAsyncWithHttpInfo($ids, $include_nutrition = null)
    {
        $returnType = 'object';
        $request = $this->getRecipeInformationBulkRequest($ids, $include_nutrition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeInformationBulk'
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data to the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeInformationBulkRequest($ids, $include_nutrition = null)
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getRecipeInformationBulk'
            );
        }

        $resourcePath = '/recipes/informationBulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ids !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($ids);
        }
        // query params
        if ($include_nutrition !== null) {
            $queryParams['includeNutrition'] = ObjectSerializer::toQueryValue($include_nutrition);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeIngredientsByID
     *
     * Get Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeIngredientsByID($id)
    {
        list($response) = $this->getRecipeIngredientsByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeIngredientsByIDWithHttpInfo
     *
     * Get Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeIngredientsByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeIngredientsByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeIngredientsByIDAsync
     *
     * Get Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeIngredientsByIDAsync($id)
    {
        return $this->getRecipeIngredientsByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeIngredientsByIDAsyncWithHttpInfo
     *
     * Get Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeIngredientsByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getRecipeIngredientsByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeIngredientsByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeIngredientsByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeIngredientsByID'
            );
        }

        $resourcePath = '/recipes/{id}/ingredientWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeNutritionByID
     *
     * Get Recipe Nutrition by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipeNutritionByID($id)
    {
        list($response) = $this->getRecipeNutritionByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeNutritionByIDWithHttpInfo
     *
     * Get Recipe Nutrition by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeNutritionByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeNutritionByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeNutritionByIDAsync
     *
     * Get Recipe Nutrition by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeNutritionByIDAsync($id)
    {
        return $this->getRecipeNutritionByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeNutritionByIDAsyncWithHttpInfo
     *
     * Get Recipe Nutrition by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeNutritionByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getRecipeNutritionByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeNutritionByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipeNutritionByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeNutritionByID'
            );
        }

        $resourcePath = '/recipes/{id}/nutritionWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipePriceBreakdownByID
     *
     * Get Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getRecipePriceBreakdownByID($id)
    {
        list($response) = $this->getRecipePriceBreakdownByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipePriceBreakdownByIDWithHttpInfo
     *
     * Get Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipePriceBreakdownByIDWithHttpInfo($id)
    {
        $request = $this->getRecipePriceBreakdownByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipePriceBreakdownByIDAsync
     *
     * Get Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipePriceBreakdownByIDAsync($id)
    {
        return $this->getRecipePriceBreakdownByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipePriceBreakdownByIDAsyncWithHttpInfo
     *
     * Get Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipePriceBreakdownByIDAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getRecipePriceBreakdownByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipePriceBreakdownByID'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecipePriceBreakdownByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipePriceBreakdownByID'
            );
        }

        $resourcePath = '/recipes/{id}/priceBreakdownWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSimilarRecipes
     *
     * Get Similar Recipes
     *
     * @param  float $id The id of the source recipe to which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getSimilarRecipes($id, $number = null)
    {
        list($response) = $this->getSimilarRecipesWithHttpInfo($id, $number);
        return $response;
    }

    /**
     * Operation getSimilarRecipesWithHttpInfo
     *
     * Get Similar Recipes
     *
     * @param  float $id The id of the source recipe to which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSimilarRecipesWithHttpInfo($id, $number = null)
    {
        $request = $this->getSimilarRecipesRequest($id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSimilarRecipesAsync
     *
     * Get Similar Recipes
     *
     * @param  float $id The id of the source recipe to which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarRecipesAsync($id, $number = null)
    {
        return $this->getSimilarRecipesAsyncWithHttpInfo($id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSimilarRecipesAsyncWithHttpInfo
     *
     * Get Similar Recipes
     *
     * @param  float $id The id of the source recipe to which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarRecipesAsyncWithHttpInfo($id, $number = null)
    {
        $returnType = 'object';
        $request = $this->getSimilarRecipesRequest($id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSimilarRecipes'
     *
     * @param  float $id The id of the source recipe to which similar recipes should be found. (required)
     * @param  float $number The number of random recipes to be returned (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSimilarRecipesRequest($id, $number = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSimilarRecipes'
            );
        }

        $resourcePath = '/recipes/{id}/similar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWineDescription
     *
     * Get Wine Description
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getWineDescription($wine)
    {
        list($response) = $this->getWineDescriptionWithHttpInfo($wine);
        return $response;
    }

    /**
     * Operation getWineDescriptionWithHttpInfo
     *
     * Get Wine Description
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWineDescriptionWithHttpInfo($wine)
    {
        $request = $this->getWineDescriptionRequest($wine);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWineDescriptionAsync
     *
     * Get Wine Description
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWineDescriptionAsync($wine)
    {
        return $this->getWineDescriptionAsyncWithHttpInfo($wine)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWineDescriptionAsyncWithHttpInfo
     *
     * Get Wine Description
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWineDescriptionAsyncWithHttpInfo($wine)
    {
        $returnType = 'object';
        $request = $this->getWineDescriptionRequest($wine);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWineDescription'
     *
     * @param  string $wine The name of the wine that should be paired, e.g. \&quot;merlot\&quot;, \&quot;riesling\&quot;, or \&quot;malbec\&quot;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWineDescriptionRequest($wine)
    {
        // verify the required parameter 'wine' is set
        if ($wine === null || (is_array($wine) && count($wine) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wine when calling getWineDescription'
            );
        }

        $resourcePath = '/food/wine/description';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($wine !== null) {
            $queryParams['wine'] = ObjectSerializer::toQueryValue($wine);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWinePairing
     *
     * Get Wine Pairing
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getWinePairing($food, $max_price = null)
    {
        list($response) = $this->getWinePairingWithHttpInfo($food, $max_price);
        return $response;
    }

    /**
     * Operation getWinePairingWithHttpInfo
     *
     * Get Wine Pairing
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWinePairingWithHttpInfo($food, $max_price = null)
    {
        $request = $this->getWinePairingRequest($food, $max_price);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWinePairingAsync
     *
     * Get Wine Pairing
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWinePairingAsync($food, $max_price = null)
    {
        return $this->getWinePairingAsyncWithHttpInfo($food, $max_price)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWinePairingAsyncWithHttpInfo
     *
     * Get Wine Pairing
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWinePairingAsyncWithHttpInfo($food, $max_price = null)
    {
        $returnType = 'object';
        $request = $this->getWinePairingRequest($food, $max_price);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWinePairing'
     *
     * @param  string $food The food to get a pairing for. This can be a dish (\&quot;steak\&quot;), an ingredient (\&quot;salmon\&quot;), or a cuisine (\&quot;italian\&quot;). (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWinePairingRequest($food, $max_price = null)
    {
        // verify the required parameter 'food' is set
        if ($food === null || (is_array($food) && count($food) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $food when calling getWinePairing'
            );
        }

        $resourcePath = '/food/wine/pairing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($food !== null) {
            $queryParams['food'] = ObjectSerializer::toQueryValue($food);
        }
        // query params
        if ($max_price !== null) {
            $queryParams['maxPrice'] = ObjectSerializer::toQueryValue($max_price);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWineRecommendation
     *
     * Get Wine Recommendation
     *
     * @param  string $wine The name of the wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getWineRecommendation($wine, $max_price = null, $min_rating = null, $number = null)
    {
        list($response) = $this->getWineRecommendationWithHttpInfo($wine, $max_price, $min_rating, $number);
        return $response;
    }

    /**
     * Operation getWineRecommendationWithHttpInfo
     *
     * Get Wine Recommendation
     *
     * @param  string $wine The name of the wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWineRecommendationWithHttpInfo($wine, $max_price = null, $min_rating = null, $number = null)
    {
        $request = $this->getWineRecommendationRequest($wine, $max_price, $min_rating, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWineRecommendationAsync
     *
     * Get Wine Recommendation
     *
     * @param  string $wine The name of the wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWineRecommendationAsync($wine, $max_price = null, $min_rating = null, $number = null)
    {
        return $this->getWineRecommendationAsyncWithHttpInfo($wine, $max_price, $min_rating, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWineRecommendationAsyncWithHttpInfo
     *
     * Get Wine Recommendation
     *
     * @param  string $wine The name of the wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWineRecommendationAsyncWithHttpInfo($wine, $max_price = null, $min_rating = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->getWineRecommendationRequest($wine, $max_price, $min_rating, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWineRecommendation'
     *
     * @param  string $wine The name of the wine to get a specific product recommendation for. (required)
     * @param  float $max_price The maximum price for the specific wine recommendation in USD. (optional)
     * @param  float $min_rating The minimum rating of the recommended wine between 0 and 1. For example, 0.8 equals 4 out of 5 stars. (optional)
     * @param  float $number The number of wine recommendations expected (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWineRecommendationRequest($wine, $max_price = null, $min_rating = null, $number = null)
    {
        // verify the required parameter 'wine' is set
        if ($wine === null || (is_array($wine) && count($wine) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wine when calling getWineRecommendation'
            );
        }

        $resourcePath = '/food/wine/recommendation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($wine !== null) {
            $queryParams['wine'] = ObjectSerializer::toQueryValue($wine);
        }
        // query params
        if ($max_price !== null) {
            $queryParams['maxPrice'] = ObjectSerializer::toQueryValue($max_price);
        }
        // query params
        if ($min_rating !== null) {
            $queryParams['minRating'] = ObjectSerializer::toQueryValue($min_rating);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation guessNutritionByDishName
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function guessNutritionByDishName($title)
    {
        list($response) = $this->guessNutritionByDishNameWithHttpInfo($title);
        return $response;
    }

    /**
     * Operation guessNutritionByDishNameWithHttpInfo
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function guessNutritionByDishNameWithHttpInfo($title)
    {
        $request = $this->guessNutritionByDishNameRequest($title);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation guessNutritionByDishNameAsync
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function guessNutritionByDishNameAsync($title)
    {
        return $this->guessNutritionByDishNameAsyncWithHttpInfo($title)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation guessNutritionByDishNameAsyncWithHttpInfo
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function guessNutritionByDishNameAsyncWithHttpInfo($title)
    {
        $returnType = 'object';
        $request = $this->guessNutritionByDishNameRequest($title);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'guessNutritionByDishName'
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function guessNutritionByDishNameRequest($title)
    {
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling guessNutritionByDishName'
            );
        }

        $resourcePath = '/recipes/guessNutrition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($title !== null) {
            $queryParams['title'] = ObjectSerializer::toQueryValue($title);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mapIngredientsToGroceryProducts
     *
     * Map Ingredients to Grocery Products
     *
     * @param  object $body body (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function mapIngredientsToGroceryProducts($body)
    {
        list($response) = $this->mapIngredientsToGroceryProductsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation mapIngredientsToGroceryProductsWithHttpInfo
     *
     * Map Ingredients to Grocery Products
     *
     * @param  object $body (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function mapIngredientsToGroceryProductsWithHttpInfo($body)
    {
        $request = $this->mapIngredientsToGroceryProductsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mapIngredientsToGroceryProductsAsync
     *
     * Map Ingredients to Grocery Products
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mapIngredientsToGroceryProductsAsync($body)
    {
        return $this->mapIngredientsToGroceryProductsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mapIngredientsToGroceryProductsAsyncWithHttpInfo
     *
     * Map Ingredients to Grocery Products
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mapIngredientsToGroceryProductsAsyncWithHttpInfo($body)
    {
        $returnType = 'object';
        $request = $this->mapIngredientsToGroceryProductsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mapIngredientsToGroceryProducts'
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mapIngredientsToGroceryProductsRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling mapIngredientsToGroceryProducts'
            );
        }

        $resourcePath = '/food/ingredients/map';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseIngredients
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function parseIngredients($ingredient_list, $servings, $include_nutrition = null)
    {
        list($response) = $this->parseIngredientsWithHttpInfo($ingredient_list, $servings, $include_nutrition);
        return $response;
    }

    /**
     * Operation parseIngredientsWithHttpInfo
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseIngredientsWithHttpInfo($ingredient_list, $servings, $include_nutrition = null)
    {
        $request = $this->parseIngredientsRequest($ingredient_list, $servings, $include_nutrition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseIngredientsAsync
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseIngredientsAsync($ingredient_list, $servings, $include_nutrition = null)
    {
        return $this->parseIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $include_nutrition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseIngredientsAsyncWithHttpInfo
     *
     * Parse Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $include_nutrition = null)
    {
        $returnType = 'object';
        $request = $this->parseIngredientsRequest($ingredient_list, $servings, $include_nutrition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseIngredients'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings that you can make from the ingredients. (required)
     * @param  bool $include_nutrition Whether nutrition data should be added to correctly parsed ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function parseIngredientsRequest($ingredient_list, $servings, $include_nutrition = null)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling parseIngredients'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling parseIngredients'
            );
        }

        $resourcePath = '/recipes/parseIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($include_nutrition !== null) {
            $formParams['includeNutrition'] = ObjectSerializer::toFormValue($include_nutrition);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickAnswer
     *
     * Quick Answer
     *
     * @param  string $q The nutrition-related question. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function quickAnswer($q)
    {
        list($response) = $this->quickAnswerWithHttpInfo($q);
        return $response;
    }

    /**
     * Operation quickAnswerWithHttpInfo
     *
     * Quick Answer
     *
     * @param  string $q The nutrition-related question. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickAnswerWithHttpInfo($q)
    {
        $request = $this->quickAnswerRequest($q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation quickAnswerAsync
     *
     * Quick Answer
     *
     * @param  string $q The nutrition-related question. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickAnswerAsync($q)
    {
        return $this->quickAnswerAsyncWithHttpInfo($q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickAnswerAsyncWithHttpInfo
     *
     * Quick Answer
     *
     * @param  string $q The nutrition-related question. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickAnswerAsyncWithHttpInfo($q)
    {
        $returnType = 'object';
        $request = $this->quickAnswerRequest($q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickAnswer'
     *
     * @param  string $q The nutrition-related question. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickAnswerRequest($q)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling quickAnswer'
            );
        }

        $resourcePath = '/recipes/quickAnswer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchFoodVideos
     *
     * Search Food Videos
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchFoodVideos($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        list($response) = $this->searchFoodVideosWithHttpInfo($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number);
        return $response;
    }

    /**
     * Operation searchFoodVideosWithHttpInfo
     *
     * Search Food Videos
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchFoodVideosWithHttpInfo($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        $request = $this->searchFoodVideosRequest($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchFoodVideosAsync
     *
     * Search Food Videos
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFoodVideosAsync($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        return $this->searchFoodVideosAsyncWithHttpInfo($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchFoodVideosAsyncWithHttpInfo
     *
     * Search Food Videos
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFoodVideosAsyncWithHttpInfo($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->searchFoodVideosRequest($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchFoodVideos'
     *
     * @param  string $query The search query. (required)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchFoodVideosRequest($query, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchFoodVideos'
            );
        }

        $resourcePath = '/food/videos/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($cuisine !== null) {
            $queryParams['cuisine'] = ObjectSerializer::toQueryValue($cuisine);
        }
        // query params
        if ($diet !== null) {
            $queryParams['diet'] = ObjectSerializer::toQueryValue($diet);
        }
        // query params
        if ($include_ingredients !== null) {
            $queryParams['includeIngredients'] = ObjectSerializer::toQueryValue($include_ingredients);
        }
        // query params
        if ($exclude_ingredients !== null) {
            $queryParams['excludeIngredients'] = ObjectSerializer::toQueryValue($exclude_ingredients);
        }
        // query params
        if ($min_length !== null) {
            $queryParams['minLength'] = ObjectSerializer::toQueryValue($min_length);
        }
        // query params
        if ($max_length !== null) {
            $queryParams['maxLength'] = ObjectSerializer::toQueryValue($max_length);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchGroceryProducts
     *
     * Search Grocery Products
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the product must have. (optional)
     * @param  float $max_calories The maximum number of calories the product can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the product can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchGroceryProducts($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        list($response) = $this->searchGroceryProductsWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);
        return $response;
    }

    /**
     * Operation searchGroceryProductsWithHttpInfo
     *
     * Search Grocery Products
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the product must have. (optional)
     * @param  float $max_calories The maximum number of calories the product can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the product can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchGroceryProductsWithHttpInfo($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        $request = $this->searchGroceryProductsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchGroceryProductsAsync
     *
     * Search Grocery Products
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the product must have. (optional)
     * @param  float $max_calories The maximum number of calories the product can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the product can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsAsync($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        return $this->searchGroceryProductsAsyncWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchGroceryProductsAsyncWithHttpInfo
     *
     * Search Grocery Products
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the product must have. (optional)
     * @param  float $max_calories The maximum number of calories the product can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the product can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsAsyncWithHttpInfo($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->searchGroceryProductsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchGroceryProducts'
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the product must have. (optional)
     * @param  float $max_calories The maximum number of calories the product can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the product must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the product can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the product must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the product can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the product must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the product can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchGroceryProductsRequest($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchGroceryProducts'
            );
        }

        $resourcePath = '/food/products/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($min_calories !== null) {
            $queryParams['minCalories'] = ObjectSerializer::toQueryValue($min_calories);
        }
        // query params
        if ($max_calories !== null) {
            $queryParams['maxCalories'] = ObjectSerializer::toQueryValue($max_calories);
        }
        // query params
        if ($min_carbs !== null) {
            $queryParams['minCarbs'] = ObjectSerializer::toQueryValue($min_carbs);
        }
        // query params
        if ($max_carbs !== null) {
            $queryParams['maxCarbs'] = ObjectSerializer::toQueryValue($max_carbs);
        }
        // query params
        if ($min_protein !== null) {
            $queryParams['minProtein'] = ObjectSerializer::toQueryValue($min_protein);
        }
        // query params
        if ($max_protein !== null) {
            $queryParams['maxProtein'] = ObjectSerializer::toQueryValue($max_protein);
        }
        // query params
        if ($min_fat !== null) {
            $queryParams['minFat'] = ObjectSerializer::toQueryValue($min_fat);
        }
        // query params
        if ($max_fat !== null) {
            $queryParams['maxFat'] = ObjectSerializer::toQueryValue($max_fat);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchGroceryProductsByUPC
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchGroceryProductsByUPC($upc)
    {
        list($response) = $this->searchGroceryProductsByUPCWithHttpInfo($upc);
        return $response;
    }

    /**
     * Operation searchGroceryProductsByUPCWithHttpInfo
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchGroceryProductsByUPCWithHttpInfo($upc)
    {
        $request = $this->searchGroceryProductsByUPCRequest($upc);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchGroceryProductsByUPCAsync
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsByUPCAsync($upc)
    {
        return $this->searchGroceryProductsByUPCAsyncWithHttpInfo($upc)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchGroceryProductsByUPCAsyncWithHttpInfo
     *
     * Search Grocery Products by UPC
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGroceryProductsByUPCAsyncWithHttpInfo($upc)
    {
        $returnType = 'object';
        $request = $this->searchGroceryProductsByUPCRequest($upc);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchGroceryProductsByUPC'
     *
     * @param  float $upc The product&#39;s UPC. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchGroceryProductsByUPCRequest($upc)
    {
        // verify the required parameter 'upc' is set
        if ($upc === null || (is_array($upc) && count($upc) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upc when calling searchGroceryProductsByUPC'
            );
        }

        $resourcePath = '/food/products/upc/{upc}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($upc !== null) {
            $resourcePath = str_replace(
                '{' . 'upc' . '}',
                ObjectSerializer::toPathValue($upc),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchMenuItems
     *
     * Search Menu Items
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum number of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchMenuItems($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        list($response) = $this->searchMenuItemsWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);
        return $response;
    }

    /**
     * Operation searchMenuItemsWithHttpInfo
     *
     * Search Menu Items
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum number of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchMenuItemsWithHttpInfo($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        $request = $this->searchMenuItemsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchMenuItemsAsync
     *
     * Search Menu Items
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum number of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMenuItemsAsync($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        return $this->searchMenuItemsAsyncWithHttpInfo($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchMenuItemsAsyncWithHttpInfo
     *
     * Search Menu Items
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum number of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchMenuItemsAsyncWithHttpInfo($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        $returnType = 'object';
        $request = $this->searchMenuItemsRequest($query, $min_calories, $max_calories, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_fat, $max_fat, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchMenuItems'
     *
     * @param  string $query The search query. (required)
     * @param  float $min_calories The minimum number of calories the menu item must have. (optional)
     * @param  float $max_calories The maximum number of calories the menu item can have. (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the menu item must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the menu item can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the menu item must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the menu item can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the menu item must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the menu item can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchMenuItemsRequest($query, $min_calories = null, $max_calories = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_fat = null, $max_fat = null, $offset = null, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchMenuItems'
            );
        }

        $resourcePath = '/food/menuItems/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($min_calories !== null) {
            $queryParams['minCalories'] = ObjectSerializer::toQueryValue($min_calories);
        }
        // query params
        if ($max_calories !== null) {
            $queryParams['maxCalories'] = ObjectSerializer::toQueryValue($max_calories);
        }
        // query params
        if ($min_carbs !== null) {
            $queryParams['minCarbs'] = ObjectSerializer::toQueryValue($min_carbs);
        }
        // query params
        if ($max_carbs !== null) {
            $queryParams['maxCarbs'] = ObjectSerializer::toQueryValue($max_carbs);
        }
        // query params
        if ($min_protein !== null) {
            $queryParams['minProtein'] = ObjectSerializer::toQueryValue($min_protein);
        }
        // query params
        if ($max_protein !== null) {
            $queryParams['maxProtein'] = ObjectSerializer::toQueryValue($max_protein);
        }
        // query params
        if ($min_fat !== null) {
            $queryParams['minFat'] = ObjectSerializer::toQueryValue($min_fat);
        }
        // query params
        if ($max_fat !== null) {
            $queryParams['maxFat'] = ObjectSerializer::toQueryValue($max_fat);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipes
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $exclude_ingredients An comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchRecipes($query, $cuisine = null, $diet = null, $exclude_ingredients = null, $intolerances = null, $offset = null, $number = null, $limit_license = null, $instructions_required = null)
    {
        list($response) = $this->searchRecipesWithHttpInfo($query, $cuisine, $diet, $exclude_ingredients, $intolerances, $offset, $number, $limit_license, $instructions_required);
        return $response;
    }

    /**
     * Operation searchRecipesWithHttpInfo
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $exclude_ingredients An comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesWithHttpInfo($query, $cuisine = null, $diet = null, $exclude_ingredients = null, $intolerances = null, $offset = null, $number = null, $limit_license = null, $instructions_required = null)
    {
        $request = $this->searchRecipesRequest($query, $cuisine, $diet, $exclude_ingredients, $intolerances, $offset, $number, $limit_license, $instructions_required);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesAsync
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $exclude_ingredients An comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesAsync($query, $cuisine = null, $diet = null, $exclude_ingredients = null, $intolerances = null, $offset = null, $number = null, $limit_license = null, $instructions_required = null)
    {
        return $this->searchRecipesAsyncWithHttpInfo($query, $cuisine, $diet, $exclude_ingredients, $intolerances, $offset, $number, $limit_license, $instructions_required)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesAsyncWithHttpInfo
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $exclude_ingredients An comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesAsyncWithHttpInfo($query, $cuisine = null, $diet = null, $exclude_ingredients = null, $intolerances = null, $offset = null, $number = null, $limit_license = null, $instructions_required = null)
    {
        $returnType = 'object';
        $request = $this->searchRecipesRequest($query, $cuisine, $diet, $exclude_ingredients, $intolerances, $offset, $number, $limit_license, $instructions_required);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipes'
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $exclude_ingredients An comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  float $offset The number of results to skip (between 0 and 900). (optional)
     * @param  float $number The number of results to return (between 1 and 100). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRecipesRequest($query, $cuisine = null, $diet = null, $exclude_ingredients = null, $intolerances = null, $offset = null, $number = null, $limit_license = null, $instructions_required = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchRecipes'
            );
        }

        $resourcePath = '/recipes/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($cuisine !== null) {
            $queryParams['cuisine'] = ObjectSerializer::toQueryValue($cuisine);
        }
        // query params
        if ($diet !== null) {
            $queryParams['diet'] = ObjectSerializer::toQueryValue($diet);
        }
        // query params
        if ($exclude_ingredients !== null) {
            $queryParams['excludeIngredients'] = ObjectSerializer::toQueryValue($exclude_ingredients);
        }
        // query params
        if ($intolerances !== null) {
            $queryParams['intolerances'] = ObjectSerializer::toQueryValue($intolerances);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }
        // query params
        if ($instructions_required !== null) {
            $queryParams['instructionsRequired'] = ObjectSerializer::toQueryValue($instructions_required);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipesByIngredients
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximal number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore pantry ingredients such as water, salt, flour etc. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchRecipesByIngredients($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        list($response) = $this->searchRecipesByIngredientsWithHttpInfo($ingredients, $number, $limit_license, $ranking, $ignore_pantry);
        return $response;
    }

    /**
     * Operation searchRecipesByIngredientsWithHttpInfo
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximal number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore pantry ingredients such as water, salt, flour etc. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesByIngredientsWithHttpInfo($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        $request = $this->searchRecipesByIngredientsRequest($ingredients, $number, $limit_license, $ranking, $ignore_pantry);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesByIngredientsAsync
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximal number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore pantry ingredients such as water, salt, flour etc. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByIngredientsAsync($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        return $this->searchRecipesByIngredientsAsyncWithHttpInfo($ingredients, $number, $limit_license, $ranking, $ignore_pantry)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesByIngredientsAsyncWithHttpInfo
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximal number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore pantry ingredients such as water, salt, flour etc. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByIngredientsAsyncWithHttpInfo($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        $returnType = 'object';
        $request = $this->searchRecipesByIngredientsRequest($ingredients, $number, $limit_license, $ranking, $ignore_pantry);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipesByIngredients'
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (required)
     * @param  float $number The maximal number of recipes to return (between 1 and 100). Defaults to 10. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore pantry ingredients such as water, salt, flour etc. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRecipesByIngredientsRequest($ingredients, $number = null, $limit_license = null, $ranking = null, $ignore_pantry = null)
    {
        // verify the required parameter 'ingredients' is set
        if ($ingredients === null || (is_array($ingredients) && count($ingredients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredients when calling searchRecipesByIngredients'
            );
        }

        $resourcePath = '/recipes/findByIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ingredients !== null) {
            $queryParams['ingredients'] = ObjectSerializer::toQueryValue($ingredients);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }
        // query params
        if ($ranking !== null) {
            $queryParams['ranking'] = ObjectSerializer::toQueryValue($ranking);
        }
        // query params
        if ($ignore_pantry !== null) {
            $queryParams['ignorePantry'] = ObjectSerializer::toQueryValue($ignore_pantry);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipesByNutrients
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchRecipesByNutrients($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {
        list($response) = $this->searchRecipesByNutrientsWithHttpInfo($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license);
        return $response;
    }

    /**
     * Operation searchRecipesByNutrientsWithHttpInfo
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesByNutrientsWithHttpInfo($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {
        $request = $this->searchRecipesByNutrientsRequest($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesByNutrientsAsync
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByNutrientsAsync($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {
        return $this->searchRecipesByNutrientsAsyncWithHttpInfo($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesByNutrientsAsyncWithHttpInfo
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByNutrientsAsyncWithHttpInfo($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {
        $returnType = 'object';
        $request = $this->searchRecipesByNutrientsRequest($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipesByNutrients'
     *
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 100). (optional)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRecipesByNutrientsRequest($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $random = null, $limit_license = null)
    {

        $resourcePath = '/recipes/findByNutrients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($min_carbs !== null) {
            $queryParams['minCarbs'] = ObjectSerializer::toQueryValue($min_carbs);
        }
        // query params
        if ($max_carbs !== null) {
            $queryParams['maxCarbs'] = ObjectSerializer::toQueryValue($max_carbs);
        }
        // query params
        if ($min_protein !== null) {
            $queryParams['minProtein'] = ObjectSerializer::toQueryValue($min_protein);
        }
        // query params
        if ($max_protein !== null) {
            $queryParams['maxProtein'] = ObjectSerializer::toQueryValue($max_protein);
        }
        // query params
        if ($min_calories !== null) {
            $queryParams['minCalories'] = ObjectSerializer::toQueryValue($min_calories);
        }
        // query params
        if ($max_calories !== null) {
            $queryParams['maxCalories'] = ObjectSerializer::toQueryValue($max_calories);
        }
        // query params
        if ($min_fat !== null) {
            $queryParams['minFat'] = ObjectSerializer::toQueryValue($min_fat);
        }
        // query params
        if ($max_fat !== null) {
            $queryParams['maxFat'] = ObjectSerializer::toQueryValue($max_fat);
        }
        // query params
        if ($min_alcohol !== null) {
            $queryParams['minAlcohol'] = ObjectSerializer::toQueryValue($min_alcohol);
        }
        // query params
        if ($max_alcohol !== null) {
            $queryParams['maxAlcohol'] = ObjectSerializer::toQueryValue($max_alcohol);
        }
        // query params
        if ($min_caffeine !== null) {
            $queryParams['minCaffeine'] = ObjectSerializer::toQueryValue($min_caffeine);
        }
        // query params
        if ($max_caffeine !== null) {
            $queryParams['maxCaffeine'] = ObjectSerializer::toQueryValue($max_caffeine);
        }
        // query params
        if ($min_copper !== null) {
            $queryParams['minCopper'] = ObjectSerializer::toQueryValue($min_copper);
        }
        // query params
        if ($max_copper !== null) {
            $queryParams['maxCopper'] = ObjectSerializer::toQueryValue($max_copper);
        }
        // query params
        if ($min_calcium !== null) {
            $queryParams['minCalcium'] = ObjectSerializer::toQueryValue($min_calcium);
        }
        // query params
        if ($max_calcium !== null) {
            $queryParams['maxCalcium'] = ObjectSerializer::toQueryValue($max_calcium);
        }
        // query params
        if ($min_choline !== null) {
            $queryParams['minCholine'] = ObjectSerializer::toQueryValue($min_choline);
        }
        // query params
        if ($max_choline !== null) {
            $queryParams['maxCholine'] = ObjectSerializer::toQueryValue($max_choline);
        }
        // query params
        if ($min_cholesterol !== null) {
            $queryParams['minCholesterol'] = ObjectSerializer::toQueryValue($min_cholesterol);
        }
        // query params
        if ($max_cholesterol !== null) {
            $queryParams['maxCholesterol'] = ObjectSerializer::toQueryValue($max_cholesterol);
        }
        // query params
        if ($min_fluoride !== null) {
            $queryParams['minFluoride'] = ObjectSerializer::toQueryValue($min_fluoride);
        }
        // query params
        if ($max_fluoride !== null) {
            $queryParams['maxFluoride'] = ObjectSerializer::toQueryValue($max_fluoride);
        }
        // query params
        if ($min_saturated_fat !== null) {
            $queryParams['minSaturatedFat'] = ObjectSerializer::toQueryValue($min_saturated_fat);
        }
        // query params
        if ($max_saturated_fat !== null) {
            $queryParams['maxSaturatedFat'] = ObjectSerializer::toQueryValue($max_saturated_fat);
        }
        // query params
        if ($min_vitamin_a !== null) {
            $queryParams['minVitaminA'] = ObjectSerializer::toQueryValue($min_vitamin_a);
        }
        // query params
        if ($max_vitamin_a !== null) {
            $queryParams['maxVitaminA'] = ObjectSerializer::toQueryValue($max_vitamin_a);
        }
        // query params
        if ($min_vitamin_c !== null) {
            $queryParams['minVitaminC'] = ObjectSerializer::toQueryValue($min_vitamin_c);
        }
        // query params
        if ($max_vitamin_c !== null) {
            $queryParams['maxVitaminC'] = ObjectSerializer::toQueryValue($max_vitamin_c);
        }
        // query params
        if ($min_vitamin_d !== null) {
            $queryParams['minVitaminD'] = ObjectSerializer::toQueryValue($min_vitamin_d);
        }
        // query params
        if ($max_vitamin_d !== null) {
            $queryParams['maxVitaminD'] = ObjectSerializer::toQueryValue($max_vitamin_d);
        }
        // query params
        if ($min_vitamin_e !== null) {
            $queryParams['minVitaminE'] = ObjectSerializer::toQueryValue($min_vitamin_e);
        }
        // query params
        if ($max_vitamin_e !== null) {
            $queryParams['maxVitaminE'] = ObjectSerializer::toQueryValue($max_vitamin_e);
        }
        // query params
        if ($min_vitamin_k !== null) {
            $queryParams['minVitaminK'] = ObjectSerializer::toQueryValue($min_vitamin_k);
        }
        // query params
        if ($max_vitamin_k !== null) {
            $queryParams['maxVitaminK'] = ObjectSerializer::toQueryValue($max_vitamin_k);
        }
        // query params
        if ($min_vitamin_b1 !== null) {
            $queryParams['minVitaminB1'] = ObjectSerializer::toQueryValue($min_vitamin_b1);
        }
        // query params
        if ($max_vitamin_b1 !== null) {
            $queryParams['maxVitaminB1'] = ObjectSerializer::toQueryValue($max_vitamin_b1);
        }
        // query params
        if ($min_vitamin_b2 !== null) {
            $queryParams['minVitaminB2'] = ObjectSerializer::toQueryValue($min_vitamin_b2);
        }
        // query params
        if ($max_vitamin_b2 !== null) {
            $queryParams['maxVitaminB2'] = ObjectSerializer::toQueryValue($max_vitamin_b2);
        }
        // query params
        if ($min_vitamin_b5 !== null) {
            $queryParams['minVitaminB5'] = ObjectSerializer::toQueryValue($min_vitamin_b5);
        }
        // query params
        if ($max_vitamin_b5 !== null) {
            $queryParams['maxVitaminB5'] = ObjectSerializer::toQueryValue($max_vitamin_b5);
        }
        // query params
        if ($min_vitamin_b3 !== null) {
            $queryParams['minVitaminB3'] = ObjectSerializer::toQueryValue($min_vitamin_b3);
        }
        // query params
        if ($max_vitamin_b3 !== null) {
            $queryParams['maxVitaminB3'] = ObjectSerializer::toQueryValue($max_vitamin_b3);
        }
        // query params
        if ($min_vitamin_b6 !== null) {
            $queryParams['minVitaminB6'] = ObjectSerializer::toQueryValue($min_vitamin_b6);
        }
        // query params
        if ($max_vitamin_b6 !== null) {
            $queryParams['maxVitaminB6'] = ObjectSerializer::toQueryValue($max_vitamin_b6);
        }
        // query params
        if ($min_vitamin_b12 !== null) {
            $queryParams['minVitaminB12'] = ObjectSerializer::toQueryValue($min_vitamin_b12);
        }
        // query params
        if ($max_vitamin_b12 !== null) {
            $queryParams['maxVitaminB12'] = ObjectSerializer::toQueryValue($max_vitamin_b12);
        }
        // query params
        if ($min_fiber !== null) {
            $queryParams['minFiber'] = ObjectSerializer::toQueryValue($min_fiber);
        }
        // query params
        if ($max_fiber !== null) {
            $queryParams['maxFiber'] = ObjectSerializer::toQueryValue($max_fiber);
        }
        // query params
        if ($min_folate !== null) {
            $queryParams['minFolate'] = ObjectSerializer::toQueryValue($min_folate);
        }
        // query params
        if ($max_folate !== null) {
            $queryParams['maxFolate'] = ObjectSerializer::toQueryValue($max_folate);
        }
        // query params
        if ($min_folic_acid !== null) {
            $queryParams['minFolicAcid'] = ObjectSerializer::toQueryValue($min_folic_acid);
        }
        // query params
        if ($max_folic_acid !== null) {
            $queryParams['maxFolicAcid'] = ObjectSerializer::toQueryValue($max_folic_acid);
        }
        // query params
        if ($min_iodine !== null) {
            $queryParams['minIodine'] = ObjectSerializer::toQueryValue($min_iodine);
        }
        // query params
        if ($max_iodine !== null) {
            $queryParams['maxIodine'] = ObjectSerializer::toQueryValue($max_iodine);
        }
        // query params
        if ($min_iron !== null) {
            $queryParams['minIron'] = ObjectSerializer::toQueryValue($min_iron);
        }
        // query params
        if ($max_iron !== null) {
            $queryParams['maxIron'] = ObjectSerializer::toQueryValue($max_iron);
        }
        // query params
        if ($min_magnesium !== null) {
            $queryParams['minMagnesium'] = ObjectSerializer::toQueryValue($min_magnesium);
        }
        // query params
        if ($max_magnesium !== null) {
            $queryParams['maxMagnesium'] = ObjectSerializer::toQueryValue($max_magnesium);
        }
        // query params
        if ($min_manganese !== null) {
            $queryParams['minManganese'] = ObjectSerializer::toQueryValue($min_manganese);
        }
        // query params
        if ($max_manganese !== null) {
            $queryParams['maxManganese'] = ObjectSerializer::toQueryValue($max_manganese);
        }
        // query params
        if ($min_phosphorus !== null) {
            $queryParams['minPhosphorus'] = ObjectSerializer::toQueryValue($min_phosphorus);
        }
        // query params
        if ($max_phosphorus !== null) {
            $queryParams['maxPhosphorus'] = ObjectSerializer::toQueryValue($max_phosphorus);
        }
        // query params
        if ($min_potassium !== null) {
            $queryParams['minPotassium'] = ObjectSerializer::toQueryValue($min_potassium);
        }
        // query params
        if ($max_potassium !== null) {
            $queryParams['maxPotassium'] = ObjectSerializer::toQueryValue($max_potassium);
        }
        // query params
        if ($min_selenium !== null) {
            $queryParams['minSelenium'] = ObjectSerializer::toQueryValue($min_selenium);
        }
        // query params
        if ($max_selenium !== null) {
            $queryParams['maxSelenium'] = ObjectSerializer::toQueryValue($max_selenium);
        }
        // query params
        if ($min_sodium !== null) {
            $queryParams['minSodium'] = ObjectSerializer::toQueryValue($min_sodium);
        }
        // query params
        if ($max_sodium !== null) {
            $queryParams['maxSodium'] = ObjectSerializer::toQueryValue($max_sodium);
        }
        // query params
        if ($min_sugar !== null) {
            $queryParams['minSugar'] = ObjectSerializer::toQueryValue($min_sugar);
        }
        // query params
        if ($max_sugar !== null) {
            $queryParams['maxSugar'] = ObjectSerializer::toQueryValue($max_sugar);
        }
        // query params
        if ($min_zinc !== null) {
            $queryParams['minZinc'] = ObjectSerializer::toQueryValue($min_zinc);
        }
        // query params
        if ($max_zinc !== null) {
            $queryParams['maxZinc'] = ObjectSerializer::toQueryValue($max_zinc);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($random !== null) {
            $queryParams['random'] = ObjectSerializer::toQueryValue($random);
        }
        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipesComplex
     *
     * Search Recipes Complex
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated (will be iterpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more comma separated (will be iterpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the used and missing ingredients in each recipe. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. This saves the calls to get recipe information. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. (optional)
     * @param  string $title_match A text that has to match in the title of the recipes. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchRecipesComplex($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $author = null, $tags = null, $title_match = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        list($response) = $this->searchRecipesComplexWithHttpInfo($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $author, $tags, $title_match, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license);
        return $response;
    }

    /**
     * Operation searchRecipesComplexWithHttpInfo
     *
     * Search Recipes Complex
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated (will be iterpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more comma separated (will be iterpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the used and missing ingredients in each recipe. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. This saves the calls to get recipe information. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. (optional)
     * @param  string $title_match A text that has to match in the title of the recipes. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesComplexWithHttpInfo($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $author = null, $tags = null, $title_match = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        $request = $this->searchRecipesComplexRequest($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $author, $tags, $title_match, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesComplexAsync
     *
     * Search Recipes Complex
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated (will be iterpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more comma separated (will be iterpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the used and missing ingredients in each recipe. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. This saves the calls to get recipe information. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. (optional)
     * @param  string $title_match A text that has to match in the title of the recipes. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesComplexAsync($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $author = null, $tags = null, $title_match = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        return $this->searchRecipesComplexAsyncWithHttpInfo($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $author, $tags, $title_match, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesComplexAsyncWithHttpInfo
     *
     * Search Recipes Complex
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated (will be iterpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more comma separated (will be iterpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the used and missing ingredients in each recipe. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. This saves the calls to get recipe information. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. (optional)
     * @param  string $title_match A text that has to match in the title of the recipes. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesComplexAsyncWithHttpInfo($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $author = null, $tags = null, $title_match = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        $returnType = 'object';
        $request = $this->searchRecipesComplexRequest($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $author, $tags, $title_match, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipesComplex'
     *
     * @param  string $query The (natural language) recipe search query. (required)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more comma separated (will be iterpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more comma separated (will be iterpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet to which the recipes must be compliant. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All found recipes must not have ingredients that could cause problems for people with one of the given tolerances. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be contained in the recipe. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that must not be contained in the recipes. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the used and missing ingredients in each recipe. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. This saves the calls to get recipe information. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags User defined tags that have to match. (optional)
     * @param  string $title_match A text that has to match in the title of the recipes. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum number of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum number of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum number of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum number of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum number of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum number of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum number of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum number of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum number of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_caffeine The minimum number of milligrams of caffeine the recipe must have. (optional)
     * @param  float $max_caffeine The maximum number of alcohol in grams the recipe must have. (optional)
     * @param  float $min_copper The minimum number of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum number of copper in milligrams the recipe must have. (optional)
     * @param  float $min_calcium The minimum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum number of calcium in milligrams the recipe must have. (optional)
     * @param  float $min_choline The minimum number of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum number of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum number of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $min_fluoride The minimum number of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum number of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum number of saturated fat in grams the recipe must have. (optional)
     * @param  float $min_vitamin_a The minimum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum number of Vitamin A in IU the recipe must have. (optional)
     * @param  float $min_vitamin_c The minimum number of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum number of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum number of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_e The minimum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum number of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_k The minimum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum number of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $min_vitamin_b1 The minimum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum number of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b2 The minimum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum number of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $min_vitamin_b5 The minimum number of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum number of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum number of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum number of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum number of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum number of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum number of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $min_fiber The minimum number of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum number of fiber in grams the recipe must have. (optional)
     * @param  float $min_folate The minimum number of folate in grams the recipe must have. (optional)
     * @param  float $max_folate The maximum number of folate in grams the recipe must have. (optional)
     * @param  float $min_folic_acid The minimum number of folic acid in grams the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum number of folic acid in grams the recipe must have. (optional)
     * @param  float $min_iodine The minimum number of Iodine in grams the recipe must have. (optional)
     * @param  float $max_iodine The maximum number of iodine in grams the recipe must have. (optional)
     * @param  float $min_iron The minimum number of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum number of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum number of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum number of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum number of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum number of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum number of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum number of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum number of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum number of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum number of selenium in grams the recipe must have. (optional)
     * @param  float $max_selenium The maximum number of selenium in grams the recipe must have. (optional)
     * @param  float $min_sodium The minimum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum number of sodium in milligrams the recipe must have. (optional)
     * @param  float $min_sugar The minimum number of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum number of sugar in grams the recipe must have. (optional)
     * @param  float $min_zinc The minimum number of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum number of zinc in milligrams the recipe can have. (optional)
     * @param  float $offset The offset number for paging (between 0 and 990). (optional)
     * @param  float $number The number of expected results (between 1 and 10). (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows for displaying with proper attribution. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRecipesComplexRequest($query, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $author = null, $tags = null, $title_match = null, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = null, $limit_license = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchRecipesComplex'
            );
        }

        $resourcePath = '/recipes/complexSearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }
        // query params
        if ($cuisine !== null) {
            $queryParams['cuisine'] = ObjectSerializer::toQueryValue($cuisine);
        }
        // query params
        if ($exclude_cuisine !== null) {
            $queryParams['excludeCuisine'] = ObjectSerializer::toQueryValue($exclude_cuisine);
        }
        // query params
        if ($diet !== null) {
            $queryParams['diet'] = ObjectSerializer::toQueryValue($diet);
        }
        // query params
        if ($intolerances !== null) {
            $queryParams['intolerances'] = ObjectSerializer::toQueryValue($intolerances);
        }
        // query params
        if ($equipment !== null) {
            $queryParams['equipment'] = ObjectSerializer::toQueryValue($equipment);
        }
        // query params
        if ($include_ingredients !== null) {
            $queryParams['includeIngredients'] = ObjectSerializer::toQueryValue($include_ingredients);
        }
        // query params
        if ($exclude_ingredients !== null) {
            $queryParams['excludeIngredients'] = ObjectSerializer::toQueryValue($exclude_ingredients);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($instructions_required !== null) {
            $queryParams['instructionsRequired'] = ObjectSerializer::toQueryValue($instructions_required);
        }
        // query params
        if ($fill_ingredients !== null) {
            $queryParams['fillIngredients'] = ObjectSerializer::toQueryValue($fill_ingredients);
        }
        // query params
        if ($add_recipe_information !== null) {
            $queryParams['addRecipeInformation'] = ObjectSerializer::toQueryValue($add_recipe_information);
        }
        // query params
        if ($author !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($author);
        }
        // query params
        if ($tags !== null) {
            $queryParams['tags'] = ObjectSerializer::toQueryValue($tags);
        }
        // query params
        if ($title_match !== null) {
            $queryParams['titleMatch'] = ObjectSerializer::toQueryValue($title_match);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($sort_direction !== null) {
            $queryParams['sortDirection'] = ObjectSerializer::toQueryValue($sort_direction);
        }
        // query params
        if ($min_carbs !== null) {
            $queryParams['minCarbs'] = ObjectSerializer::toQueryValue($min_carbs);
        }
        // query params
        if ($max_carbs !== null) {
            $queryParams['maxCarbs'] = ObjectSerializer::toQueryValue($max_carbs);
        }
        // query params
        if ($min_protein !== null) {
            $queryParams['minProtein'] = ObjectSerializer::toQueryValue($min_protein);
        }
        // query params
        if ($max_protein !== null) {
            $queryParams['maxProtein'] = ObjectSerializer::toQueryValue($max_protein);
        }
        // query params
        if ($min_calories !== null) {
            $queryParams['minCalories'] = ObjectSerializer::toQueryValue($min_calories);
        }
        // query params
        if ($max_calories !== null) {
            $queryParams['maxCalories'] = ObjectSerializer::toQueryValue($max_calories);
        }
        // query params
        if ($min_fat !== null) {
            $queryParams['minFat'] = ObjectSerializer::toQueryValue($min_fat);
        }
        // query params
        if ($max_fat !== null) {
            $queryParams['maxFat'] = ObjectSerializer::toQueryValue($max_fat);
        }
        // query params
        if ($min_alcohol !== null) {
            $queryParams['minAlcohol'] = ObjectSerializer::toQueryValue($min_alcohol);
        }
        // query params
        if ($max_alcohol !== null) {
            $queryParams['maxAlcohol'] = ObjectSerializer::toQueryValue($max_alcohol);
        }
        // query params
        if ($min_caffeine !== null) {
            $queryParams['minCaffeine'] = ObjectSerializer::toQueryValue($min_caffeine);
        }
        // query params
        if ($max_caffeine !== null) {
            $queryParams['maxCaffeine'] = ObjectSerializer::toQueryValue($max_caffeine);
        }
        // query params
        if ($min_copper !== null) {
            $queryParams['minCopper'] = ObjectSerializer::toQueryValue($min_copper);
        }
        // query params
        if ($max_copper !== null) {
            $queryParams['maxCopper'] = ObjectSerializer::toQueryValue($max_copper);
        }
        // query params
        if ($min_calcium !== null) {
            $queryParams['minCalcium'] = ObjectSerializer::toQueryValue($min_calcium);
        }
        // query params
        if ($max_calcium !== null) {
            $queryParams['maxCalcium'] = ObjectSerializer::toQueryValue($max_calcium);
        }
        // query params
        if ($min_choline !== null) {
            $queryParams['minCholine'] = ObjectSerializer::toQueryValue($min_choline);
        }
        // query params
        if ($max_choline !== null) {
            $queryParams['maxCholine'] = ObjectSerializer::toQueryValue($max_choline);
        }
        // query params
        if ($min_cholesterol !== null) {
            $queryParams['minCholesterol'] = ObjectSerializer::toQueryValue($min_cholesterol);
        }
        // query params
        if ($max_cholesterol !== null) {
            $queryParams['maxCholesterol'] = ObjectSerializer::toQueryValue($max_cholesterol);
        }
        // query params
        if ($min_fluoride !== null) {
            $queryParams['minFluoride'] = ObjectSerializer::toQueryValue($min_fluoride);
        }
        // query params
        if ($max_fluoride !== null) {
            $queryParams['maxFluoride'] = ObjectSerializer::toQueryValue($max_fluoride);
        }
        // query params
        if ($min_saturated_fat !== null) {
            $queryParams['minSaturatedFat'] = ObjectSerializer::toQueryValue($min_saturated_fat);
        }
        // query params
        if ($max_saturated_fat !== null) {
            $queryParams['maxSaturatedFat'] = ObjectSerializer::toQueryValue($max_saturated_fat);
        }
        // query params
        if ($min_vitamin_a !== null) {
            $queryParams['minVitaminA'] = ObjectSerializer::toQueryValue($min_vitamin_a);
        }
        // query params
        if ($max_vitamin_a !== null) {
            $queryParams['maxVitaminA'] = ObjectSerializer::toQueryValue($max_vitamin_a);
        }
        // query params
        if ($min_vitamin_c !== null) {
            $queryParams['minVitaminC'] = ObjectSerializer::toQueryValue($min_vitamin_c);
        }
        // query params
        if ($max_vitamin_c !== null) {
            $queryParams['maxVitaminC'] = ObjectSerializer::toQueryValue($max_vitamin_c);
        }
        // query params
        if ($min_vitamin_d !== null) {
            $queryParams['minVitaminD'] = ObjectSerializer::toQueryValue($min_vitamin_d);
        }
        // query params
        if ($max_vitamin_d !== null) {
            $queryParams['maxVitaminD'] = ObjectSerializer::toQueryValue($max_vitamin_d);
        }
        // query params
        if ($min_vitamin_e !== null) {
            $queryParams['minVitaminE'] = ObjectSerializer::toQueryValue($min_vitamin_e);
        }
        // query params
        if ($max_vitamin_e !== null) {
            $queryParams['maxVitaminE'] = ObjectSerializer::toQueryValue($max_vitamin_e);
        }
        // query params
        if ($min_vitamin_k !== null) {
            $queryParams['minVitaminK'] = ObjectSerializer::toQueryValue($min_vitamin_k);
        }
        // query params
        if ($max_vitamin_k !== null) {
            $queryParams['maxVitaminK'] = ObjectSerializer::toQueryValue($max_vitamin_k);
        }
        // query params
        if ($min_vitamin_b1 !== null) {
            $queryParams['minVitaminB1'] = ObjectSerializer::toQueryValue($min_vitamin_b1);
        }
        // query params
        if ($max_vitamin_b1 !== null) {
            $queryParams['maxVitaminB1'] = ObjectSerializer::toQueryValue($max_vitamin_b1);
        }
        // query params
        if ($min_vitamin_b2 !== null) {
            $queryParams['minVitaminB2'] = ObjectSerializer::toQueryValue($min_vitamin_b2);
        }
        // query params
        if ($max_vitamin_b2 !== null) {
            $queryParams['maxVitaminB2'] = ObjectSerializer::toQueryValue($max_vitamin_b2);
        }
        // query params
        if ($min_vitamin_b5 !== null) {
            $queryParams['minVitaminB5'] = ObjectSerializer::toQueryValue($min_vitamin_b5);
        }
        // query params
        if ($max_vitamin_b5 !== null) {
            $queryParams['maxVitaminB5'] = ObjectSerializer::toQueryValue($max_vitamin_b5);
        }
        // query params
        if ($min_vitamin_b3 !== null) {
            $queryParams['minVitaminB3'] = ObjectSerializer::toQueryValue($min_vitamin_b3);
        }
        // query params
        if ($max_vitamin_b3 !== null) {
            $queryParams['maxVitaminB3'] = ObjectSerializer::toQueryValue($max_vitamin_b3);
        }
        // query params
        if ($min_vitamin_b6 !== null) {
            $queryParams['minVitaminB6'] = ObjectSerializer::toQueryValue($min_vitamin_b6);
        }
        // query params
        if ($max_vitamin_b6 !== null) {
            $queryParams['maxVitaminB6'] = ObjectSerializer::toQueryValue($max_vitamin_b6);
        }
        // query params
        if ($min_vitamin_b12 !== null) {
            $queryParams['minVitaminB12'] = ObjectSerializer::toQueryValue($min_vitamin_b12);
        }
        // query params
        if ($max_vitamin_b12 !== null) {
            $queryParams['maxVitaminB12'] = ObjectSerializer::toQueryValue($max_vitamin_b12);
        }
        // query params
        if ($min_fiber !== null) {
            $queryParams['minFiber'] = ObjectSerializer::toQueryValue($min_fiber);
        }
        // query params
        if ($max_fiber !== null) {
            $queryParams['maxFiber'] = ObjectSerializer::toQueryValue($max_fiber);
        }
        // query params
        if ($min_folate !== null) {
            $queryParams['minFolate'] = ObjectSerializer::toQueryValue($min_folate);
        }
        // query params
        if ($max_folate !== null) {
            $queryParams['maxFolate'] = ObjectSerializer::toQueryValue($max_folate);
        }
        // query params
        if ($min_folic_acid !== null) {
            $queryParams['minFolicAcid'] = ObjectSerializer::toQueryValue($min_folic_acid);
        }
        // query params
        if ($max_folic_acid !== null) {
            $queryParams['maxFolicAcid'] = ObjectSerializer::toQueryValue($max_folic_acid);
        }
        // query params
        if ($min_iodine !== null) {
            $queryParams['minIodine'] = ObjectSerializer::toQueryValue($min_iodine);
        }
        // query params
        if ($max_iodine !== null) {
            $queryParams['maxIodine'] = ObjectSerializer::toQueryValue($max_iodine);
        }
        // query params
        if ($min_iron !== null) {
            $queryParams['minIron'] = ObjectSerializer::toQueryValue($min_iron);
        }
        // query params
        if ($max_iron !== null) {
            $queryParams['maxIron'] = ObjectSerializer::toQueryValue($max_iron);
        }
        // query params
        if ($min_magnesium !== null) {
            $queryParams['minMagnesium'] = ObjectSerializer::toQueryValue($min_magnesium);
        }
        // query params
        if ($max_magnesium !== null) {
            $queryParams['maxMagnesium'] = ObjectSerializer::toQueryValue($max_magnesium);
        }
        // query params
        if ($min_manganese !== null) {
            $queryParams['minManganese'] = ObjectSerializer::toQueryValue($min_manganese);
        }
        // query params
        if ($max_manganese !== null) {
            $queryParams['maxManganese'] = ObjectSerializer::toQueryValue($max_manganese);
        }
        // query params
        if ($min_phosphorus !== null) {
            $queryParams['minPhosphorus'] = ObjectSerializer::toQueryValue($min_phosphorus);
        }
        // query params
        if ($max_phosphorus !== null) {
            $queryParams['maxPhosphorus'] = ObjectSerializer::toQueryValue($max_phosphorus);
        }
        // query params
        if ($min_potassium !== null) {
            $queryParams['minPotassium'] = ObjectSerializer::toQueryValue($min_potassium);
        }
        // query params
        if ($max_potassium !== null) {
            $queryParams['maxPotassium'] = ObjectSerializer::toQueryValue($max_potassium);
        }
        // query params
        if ($min_selenium !== null) {
            $queryParams['minSelenium'] = ObjectSerializer::toQueryValue($min_selenium);
        }
        // query params
        if ($max_selenium !== null) {
            $queryParams['maxSelenium'] = ObjectSerializer::toQueryValue($max_selenium);
        }
        // query params
        if ($min_sodium !== null) {
            $queryParams['minSodium'] = ObjectSerializer::toQueryValue($min_sodium);
        }
        // query params
        if ($max_sodium !== null) {
            $queryParams['maxSodium'] = ObjectSerializer::toQueryValue($max_sodium);
        }
        // query params
        if ($min_sugar !== null) {
            $queryParams['minSugar'] = ObjectSerializer::toQueryValue($min_sugar);
        }
        // query params
        if ($max_sugar !== null) {
            $queryParams['maxSugar'] = ObjectSerializer::toQueryValue($max_sugar);
        }
        // query params
        if ($min_zinc !== null) {
            $queryParams['minZinc'] = ObjectSerializer::toQueryValue($min_zinc);
        }
        // query params
        if ($max_zinc !== null) {
            $queryParams['maxZinc'] = ObjectSerializer::toQueryValue($max_zinc);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($limit_license !== null) {
            $queryParams['limitLicense'] = ObjectSerializer::toQueryValue($limit_license);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchSiteContent
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function searchSiteContent($query)
    {
        list($response) = $this->searchSiteContentWithHttpInfo($query);
        return $response;
    }

    /**
     * Operation searchSiteContentWithHttpInfo
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchSiteContentWithHttpInfo($query)
    {
        $request = $this->searchSiteContentRequest($query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchSiteContentAsync
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchSiteContentAsync($query)
    {
        return $this->searchSiteContentAsyncWithHttpInfo($query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchSiteContentAsyncWithHttpInfo
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchSiteContentAsyncWithHttpInfo($query)
    {
        $returnType = 'object';
        $request = $this->searchSiteContentRequest($query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchSiteContent'
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchSiteContentRequest($query)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchSiteContent'
            );
        }

        $resourcePath = '/food/site/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation summarizeRecipe
     *
     * Summarize Recipe
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function summarizeRecipe($id)
    {
        list($response) = $this->summarizeRecipeWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation summarizeRecipeWithHttpInfo
     *
     * Summarize Recipe
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function summarizeRecipeWithHttpInfo($id)
    {
        $request = $this->summarizeRecipeRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation summarizeRecipeAsync
     *
     * Summarize Recipe
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeRecipeAsync($id)
    {
        return $this->summarizeRecipeAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation summarizeRecipeAsyncWithHttpInfo
     *
     * Summarize Recipe
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeRecipeAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->summarizeRecipeRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'summarizeRecipe'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function summarizeRecipeRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling summarizeRecipe'
            );
        }

        $resourcePath = '/recipes/{id}/summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation talkToChatbot
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chat bot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function talkToChatbot($text, $context_id = null)
    {
        list($response) = $this->talkToChatbotWithHttpInfo($text, $context_id);
        return $response;
    }

    /**
     * Operation talkToChatbotWithHttpInfo
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chat bot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function talkToChatbotWithHttpInfo($text, $context_id = null)
    {
        $request = $this->talkToChatbotRequest($text, $context_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation talkToChatbotAsync
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chat bot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function talkToChatbotAsync($text, $context_id = null)
    {
        return $this->talkToChatbotAsyncWithHttpInfo($text, $context_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation talkToChatbotAsyncWithHttpInfo
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chat bot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function talkToChatbotAsyncWithHttpInfo($text, $context_id = null)
    {
        $returnType = 'object';
        $request = $this->talkToChatbotRequest($text, $context_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'talkToChatbot'
     *
     * @param  string $text The request / question / answer from the user to the chat bot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function talkToChatbotRequest($text, $context_id = null)
    {
        // verify the required parameter 'text' is set
        if ($text === null || (is_array($text) && count($text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text when calling talkToChatbot'
            );
        }

        $resourcePath = '/food/converse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text);
        }
        // query params
        if ($context_id !== null) {
            $queryParams['contextId'] = ObjectSerializer::toQueryValue($context_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeEquipment
     *
     * Visualize Equipment
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeEquipment($ingredient_list, $servings, $view = null, $default_css = null, $show_backlink = null)
    {
        list($response) = $this->visualizeEquipmentWithHttpInfo($ingredient_list, $servings, $view, $default_css, $show_backlink);
        return $response;
    }

    /**
     * Operation visualizeEquipmentWithHttpInfo
     *
     * Visualize Equipment
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeEquipmentWithHttpInfo($ingredient_list, $servings, $view = null, $default_css = null, $show_backlink = null)
    {
        $request = $this->visualizeEquipmentRequest($ingredient_list, $servings, $view, $default_css, $show_backlink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeEquipmentAsync
     *
     * Visualize Equipment
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeEquipmentAsync($ingredient_list, $servings, $view = null, $default_css = null, $show_backlink = null)
    {
        return $this->visualizeEquipmentAsyncWithHttpInfo($ingredient_list, $servings, $view, $default_css, $show_backlink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeEquipmentAsyncWithHttpInfo
     *
     * Visualize Equipment
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeEquipmentAsyncWithHttpInfo($ingredient_list, $servings, $view = null, $default_css = null, $show_backlink = null)
    {
        $returnType = 'string';
        $request = $this->visualizeEquipmentRequest($ingredient_list, $servings, $view, $default_css, $show_backlink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeEquipment'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeEquipmentRequest($ingredient_list, $servings, $view = null, $default_css = null, $show_backlink = null)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizeEquipment'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling visualizeEquipment'
            );
        }

        $resourcePath = '/recipes/visualizeEquipment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($view !== null) {
            $formParams['view'] = ObjectSerializer::toFormValue($view);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeIngredients
     *
     * Visualize Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The initial measure, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeIngredients($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        list($response) = $this->visualizeIngredientsWithHttpInfo($ingredient_list, $servings, $measure, $view, $default_css, $show_backlink);
        return $response;
    }

    /**
     * Operation visualizeIngredientsWithHttpInfo
     *
     * Visualize Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The initial measure, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeIngredientsWithHttpInfo($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        $request = $this->visualizeIngredientsRequest($ingredient_list, $servings, $measure, $view, $default_css, $show_backlink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeIngredientsAsync
     *
     * Visualize Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The initial measure, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeIngredientsAsync($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        return $this->visualizeIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $measure, $view, $default_css, $show_backlink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeIngredientsAsyncWithHttpInfo
     *
     * Visualize Ingredients
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The initial measure, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeIngredientsAsyncWithHttpInfo($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        $returnType = 'string';
        $request = $this->visualizeIngredientsRequest($ingredient_list, $servings, $measure, $view, $default_css, $show_backlink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeIngredients'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  string $measure The initial measure, either \\\&quot;metric\\\&quot; or \\\&quot;us\\\&quot;. (optional)
     * @param  string $view Either \\\&quot;grid\\\&quot; or \\\&quot;list\\\&quot; as visualization of the equipment. (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeIngredientsRequest($ingredient_list, $servings, $measure = null, $view = null, $default_css = null, $show_backlink = null)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizeIngredients'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling visualizeIngredients'
            );
        }

        $resourcePath = '/recipes/visualizeIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($measure !== null) {
            $formParams['measure'] = ObjectSerializer::toFormValue($measure);
        }
        // form params
        if ($view !== null) {
            $formParams['view'] = ObjectSerializer::toFormValue($view);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeMenuItemNutritionByID
     *
     * Visualize Menu Item Nutrition by ID
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeMenuItemNutritionByID($id, $default_css = null)
    {
        list($response) = $this->visualizeMenuItemNutritionByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeMenuItemNutritionByIDWithHttpInfo
     *
     * Visualize Menu Item Nutrition by ID
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeMenuItemNutritionByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeMenuItemNutritionByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeMenuItemNutritionByIDAsync
     *
     * Visualize Menu Item Nutrition by ID
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeMenuItemNutritionByIDAsync($id, $default_css = null)
    {
        return $this->visualizeMenuItemNutritionByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeMenuItemNutritionByIDAsyncWithHttpInfo
     *
     * Visualize Menu Item Nutrition by ID
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeMenuItemNutritionByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeMenuItemNutritionByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeMenuItemNutritionByID'
     *
     * @param  float $id The menu item id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeMenuItemNutritionByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeMenuItemNutritionByID'
            );
        }

        $resourcePath = '/food/menuItems/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizePriceBreakdown
     *
     * Visualize Price Breakdown
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizePriceBreakdown($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        list($response) = $this->visualizePriceBreakdownWithHttpInfo($ingredient_list, $servings, $mode, $default_css, $show_backlink);
        return $response;
    }

    /**
     * Operation visualizePriceBreakdownWithHttpInfo
     *
     * Visualize Price Breakdown
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizePriceBreakdownWithHttpInfo($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        $request = $this->visualizePriceBreakdownRequest($ingredient_list, $servings, $mode, $default_css, $show_backlink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizePriceBreakdownAsync
     *
     * Visualize Price Breakdown
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizePriceBreakdownAsync($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        return $this->visualizePriceBreakdownAsyncWithHttpInfo($ingredient_list, $servings, $mode, $default_css, $show_backlink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizePriceBreakdownAsyncWithHttpInfo
     *
     * Visualize Price Breakdown
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizePriceBreakdownAsyncWithHttpInfo($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        $returnType = 'string';
        $request = $this->visualizePriceBreakdownRequest($ingredient_list, $servings, $mode, $default_css, $show_backlink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizePriceBreakdown'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  float $mode The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full). (optional)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizePriceBreakdownRequest($ingredient_list, $servings, $mode = null, $default_css = null, $show_backlink = null)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizePriceBreakdown'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling visualizePriceBreakdown'
            );
        }

        $resourcePath = '/recipes/visualizePriceEstimator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($mode !== null) {
            $formParams['mode'] = ObjectSerializer::toFormValue($mode);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeProductNutritionByID
     *
     * Visualize Product Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeProductNutritionByID($id, $default_css = null)
    {
        list($response) = $this->visualizeProductNutritionByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeProductNutritionByIDWithHttpInfo
     *
     * Visualize Product Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeProductNutritionByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeProductNutritionByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeProductNutritionByIDAsync
     *
     * Visualize Product Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeProductNutritionByIDAsync($id, $default_css = null)
    {
        return $this->visualizeProductNutritionByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeProductNutritionByIDAsyncWithHttpInfo
     *
     * Visualize Product Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeProductNutritionByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeProductNutritionByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeProductNutritionByID'
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeProductNutritionByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeProductNutritionByID'
            );
        }

        $resourcePath = '/food/products/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeEquipmentByID
     *
     * Visualize Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeEquipmentByID($id, $default_css = null)
    {
        list($response) = $this->visualizeRecipeEquipmentByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipeEquipmentByIDWithHttpInfo
     *
     * Visualize Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeEquipmentByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeRecipeEquipmentByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeEquipmentByIDAsync
     *
     * Visualize Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeEquipmentByIDAsync($id, $default_css = null)
    {
        return $this->visualizeRecipeEquipmentByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeEquipmentByIDAsyncWithHttpInfo
     *
     * Visualize Recipe Equipment by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeEquipmentByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeEquipmentByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeEquipmentByID'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeEquipmentByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeEquipmentByID'
            );
        }

        $resourcePath = '/recipes/{id}/equipmentWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeIngredientsByID
     *
     * Visualize Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeIngredientsByID($id, $default_css = null)
    {
        list($response) = $this->visualizeRecipeIngredientsByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipeIngredientsByIDWithHttpInfo
     *
     * Visualize Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeIngredientsByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeRecipeIngredientsByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeIngredientsByIDAsync
     *
     * Visualize Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeIngredientsByIDAsync($id, $default_css = null)
    {
        return $this->visualizeRecipeIngredientsByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeIngredientsByIDAsyncWithHttpInfo
     *
     * Visualize Recipe Ingredients by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeIngredientsByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeIngredientsByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeIngredientsByID'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeIngredientsByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeIngredientsByID'
            );
        }

        $resourcePath = '/recipes/{id}/ingredientWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeNutrition
     *
     * Visualize Recipe Nutrition
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeNutrition($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        list($response) = $this->visualizeRecipeNutritionWithHttpInfo($ingredient_list, $servings, $default_css, $show_backlink);
        return $response;
    }

    /**
     * Operation visualizeRecipeNutritionWithHttpInfo
     *
     * Visualize Recipe Nutrition
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeNutritionWithHttpInfo($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        $request = $this->visualizeRecipeNutritionRequest($ingredient_list, $servings, $default_css, $show_backlink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeNutritionAsync
     *
     * Visualize Recipe Nutrition
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionAsync($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        return $this->visualizeRecipeNutritionAsyncWithHttpInfo($ingredient_list, $servings, $default_css, $show_backlink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeNutritionAsyncWithHttpInfo
     *
     * Visualize Recipe Nutrition
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionAsyncWithHttpInfo($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeNutritionRequest($ingredient_list, $servings, $default_css, $show_backlink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeNutrition'
     *
     * @param  string $ingredient_list The ingredient list of the recipe, one ingredient per line. (required)
     * @param  float $servings The number of servings. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     * @param  bool $show_backlink Whether to show a backlink to spoonacular. If set false, this call counts against your quota. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeNutritionRequest($ingredient_list, $servings, $default_css = null, $show_backlink = null)
    {
        // verify the required parameter 'ingredient_list' is set
        if ($ingredient_list === null || (is_array($ingredient_list) && count($ingredient_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_list when calling visualizeRecipeNutrition'
            );
        }
        // verify the required parameter 'servings' is set
        if ($servings === null || (is_array($servings) && count($servings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $servings when calling visualizeRecipeNutrition'
            );
        }

        $resourcePath = '/recipes/visualizeNutrition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($ingredient_list !== null) {
            $formParams['ingredientList'] = ObjectSerializer::toFormValue($ingredient_list);
        }
        // form params
        if ($servings !== null) {
            $formParams['servings'] = ObjectSerializer::toFormValue($servings);
        }
        // form params
        if ($default_css !== null) {
            $formParams['defaultCss'] = ObjectSerializer::toFormValue($default_css);
        }
        // form params
        if ($show_backlink !== null) {
            $formParams['showBacklink'] = ObjectSerializer::toFormValue($show_backlink);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeNutritionByID
     *
     * Visualize Recipe Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeNutritionByID($id, $default_css = null)
    {
        list($response) = $this->visualizeRecipeNutritionByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipeNutritionByIDWithHttpInfo
     *
     * Visualize Recipe Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeNutritionByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeRecipeNutritionByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeNutritionByIDAsync
     *
     * Visualize Recipe Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionByIDAsync($id, $default_css = null)
    {
        return $this->visualizeRecipeNutritionByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeNutritionByIDAsyncWithHttpInfo
     *
     * Visualize Recipe Nutrition by ID
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeNutritionByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeNutritionByID'
     *
     * @param  float $id The id of the product. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipeNutritionByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeNutritionByID'
            );
        }

        $resourcePath = '/recipes/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipePriceBreakdownByID
     *
     * Visualize Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipePriceBreakdownByID($id, $default_css = null)
    {
        list($response) = $this->visualizeRecipePriceBreakdownByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDWithHttpInfo
     *
     * Visualize Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipePriceBreakdownByIDWithHttpInfo($id, $default_css = null)
    {
        $request = $this->visualizeRecipePriceBreakdownByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDAsync
     *
     * Visualize Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipePriceBreakdownByIDAsync($id, $default_css = null)
    {
        return $this->visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo
     *
     * Visualize Recipe Price Breakdown by ID
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo($id, $default_css = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipePriceBreakdownByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipePriceBreakdownByID'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function visualizeRecipePriceBreakdownByIDRequest($id, $default_css = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipePriceBreakdownByID'
            );
        }

        $resourcePath = '/recipes/{id}/priceBreakdownWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($default_css !== null) {
            $queryParams['defaultCss'] = ObjectSerializer::toQueryValue($default_css);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
