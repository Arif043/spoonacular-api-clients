{-
   spoonacular API

   The spoonacular Nutrition, Recipe, and Food API allows you to access over 380,000 recipes, thousands of ingredients, 80,000 food products, and 100,000 menu items. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

   OpenAPI Version: 3.0.0
   spoonacular API API version: 1.0
   Contact: david@spoonacular.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Spoonacular.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Spoonacular.Model where

import Spoonacular.Core
import Spoonacular.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AValue
newtype AValue = AValue { unAValue :: [A.Value] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** AddChildren
newtype AddChildren = AddChildren { unAddChildren :: Bool } deriving (P.Eq, P.Show)

-- ** AddRecipeInformation
newtype AddRecipeInformation = AddRecipeInformation { unAddRecipeInformation :: Bool } deriving (P.Eq, P.Show)

-- ** AddRecipeNutrition
newtype AddRecipeNutrition = AddRecipeNutrition { unAddRecipeNutrition :: Bool } deriving (P.Eq, P.Show)

-- ** Amount
newtype Amount = Amount { unAmount :: Double } deriving (P.Eq, P.Show)

-- ** Analyze
newtype Analyze = Analyze { unAnalyze :: Bool } deriving (P.Eq, P.Show)

-- ** Author
newtype Author = Author { unAuthor :: Text } deriving (P.Eq, P.Show)

-- ** BackgroundColor
newtype BackgroundColor = BackgroundColor { unBackgroundColor :: Text } deriving (P.Eq, P.Show)

-- ** BackgroundImage
newtype BackgroundImage = BackgroundImage { unBackgroundImage :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: A.Value } deriving (P.Eq, P.Show, A.ToJSON)

-- ** ContextId
newtype ContextId = ContextId { unContextId :: Text } deriving (P.Eq, P.Show)

-- ** Cuisine
newtype Cuisine = Cuisine { unCuisine :: Text } deriving (P.Eq, P.Show)

-- ** DefaultCss
newtype DefaultCss = DefaultCss { unDefaultCss :: Bool } deriving (P.Eq, P.Show)

-- ** Diet
newtype Diet = Diet { unDiet :: Text } deriving (P.Eq, P.Show)

-- ** EndDate
newtype EndDate = EndDate { unEndDate :: Text } deriving (P.Eq, P.Show)

-- ** Equipment
newtype Equipment = Equipment { unEquipment :: Text } deriving (P.Eq, P.Show)

-- ** Exclude
newtype Exclude = Exclude { unExclude :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeCuisine
newtype ExcludeCuisine = ExcludeCuisine { unExcludeCuisine :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeIngredients
newtype ExcludeIngredients = ExcludeIngredients { unExcludeIngredients :: Text } deriving (P.Eq, P.Show)

-- ** FillIngredients
newtype FillIngredients = FillIngredients { unFillIngredients :: Bool } deriving (P.Eq, P.Show)

-- ** FontColor
newtype FontColor = FontColor { unFontColor :: Text } deriving (P.Eq, P.Show)

-- ** Food
newtype Food = Food { unFood :: Text } deriving (P.Eq, P.Show)

-- ** ForceExtraction
newtype ForceExtraction = ForceExtraction { unForceExtraction :: Bool } deriving (P.Eq, P.Show)

-- ** Hash
newtype Hash = Hash { unHash :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Double } deriving (P.Eq, P.Show)

-- ** Ids
newtype Ids = Ids { unIds :: Text } deriving (P.Eq, P.Show)

-- ** IgnorePantry
newtype IgnorePantry = IgnorePantry { unIgnorePantry :: Bool } deriving (P.Eq, P.Show)

-- ** Image
newtype Image = Image { unImage :: FilePath } deriving (P.Eq, P.Show)

-- ** ImageUrl
newtype ImageUrl = ImageUrl { unImageUrl :: Text } deriving (P.Eq, P.Show)

-- ** IncludeIngredients
newtype IncludeIngredients = IncludeIngredients { unIncludeIngredients :: Text } deriving (P.Eq, P.Show)

-- ** IncludeNutrition
newtype IncludeNutrition = IncludeNutrition { unIncludeNutrition :: Bool } deriving (P.Eq, P.Show)

-- ** IngredientList
newtype IngredientList = IngredientList { unIngredientList :: Text } deriving (P.Eq, P.Show)

-- ** IngredientName
newtype IngredientName = IngredientName { unIngredientName :: Text } deriving (P.Eq, P.Show)

-- ** Ingredients
newtype Ingredients = Ingredients { unIngredients :: Text } deriving (P.Eq, P.Show)

-- ** Instructions
newtype Instructions = Instructions { unInstructions :: Text } deriving (P.Eq, P.Show)

-- ** InstructionsRequired
newtype InstructionsRequired = InstructionsRequired { unInstructionsRequired :: Bool } deriving (P.Eq, P.Show)

-- ** Intolerances
newtype Intolerances = Intolerances { unIntolerances :: Text } deriving (P.Eq, P.Show)

-- ** LimitLicense
newtype LimitLicense = LimitLicense { unLimitLicense :: Bool } deriving (P.Eq, P.Show)

-- ** Locale
newtype Locale = Locale { unLocale :: Text } deriving (P.Eq, P.Show)

-- ** Mask
newtype Mask = Mask { unMask :: Text } deriving (P.Eq, P.Show)

-- ** MaxAlcohol
newtype MaxAlcohol = MaxAlcohol { unMaxAlcohol :: Double } deriving (P.Eq, P.Show)

-- ** MaxCaffeine
newtype MaxCaffeine = MaxCaffeine { unMaxCaffeine :: Double } deriving (P.Eq, P.Show)

-- ** MaxCalcium
newtype MaxCalcium = MaxCalcium { unMaxCalcium :: Double } deriving (P.Eq, P.Show)

-- ** MaxCalories
newtype MaxCalories = MaxCalories { unMaxCalories :: Double } deriving (P.Eq, P.Show)

-- ** MaxCarbs
newtype MaxCarbs = MaxCarbs { unMaxCarbs :: Double } deriving (P.Eq, P.Show)

-- ** MaxCarbsPercent
newtype MaxCarbsPercent = MaxCarbsPercent { unMaxCarbsPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxCholesterol
newtype MaxCholesterol = MaxCholesterol { unMaxCholesterol :: Double } deriving (P.Eq, P.Show)

-- ** MaxCholine
newtype MaxCholine = MaxCholine { unMaxCholine :: Double } deriving (P.Eq, P.Show)

-- ** MaxCopper
newtype MaxCopper = MaxCopper { unMaxCopper :: Double } deriving (P.Eq, P.Show)

-- ** MaxFat
newtype MaxFat = MaxFat { unMaxFat :: Double } deriving (P.Eq, P.Show)

-- ** MaxFatPercent
newtype MaxFatPercent = MaxFatPercent { unMaxFatPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxFiber
newtype MaxFiber = MaxFiber { unMaxFiber :: Double } deriving (P.Eq, P.Show)

-- ** MaxFluoride
newtype MaxFluoride = MaxFluoride { unMaxFluoride :: Double } deriving (P.Eq, P.Show)

-- ** MaxFolate
newtype MaxFolate = MaxFolate { unMaxFolate :: Double } deriving (P.Eq, P.Show)

-- ** MaxFolicAcid
newtype MaxFolicAcid = MaxFolicAcid { unMaxFolicAcid :: Double } deriving (P.Eq, P.Show)

-- ** MaxIodine
newtype MaxIodine = MaxIodine { unMaxIodine :: Double } deriving (P.Eq, P.Show)

-- ** MaxIron
newtype MaxIron = MaxIron { unMaxIron :: Double } deriving (P.Eq, P.Show)

-- ** MaxLength
newtype MaxLength = MaxLength { unMaxLength :: Double } deriving (P.Eq, P.Show)

-- ** MaxMagnesium
newtype MaxMagnesium = MaxMagnesium { unMaxMagnesium :: Double } deriving (P.Eq, P.Show)

-- ** MaxManganese
newtype MaxManganese = MaxManganese { unMaxManganese :: Double } deriving (P.Eq, P.Show)

-- ** MaxPhosphorus
newtype MaxPhosphorus = MaxPhosphorus { unMaxPhosphorus :: Double } deriving (P.Eq, P.Show)

-- ** MaxPotassium
newtype MaxPotassium = MaxPotassium { unMaxPotassium :: Double } deriving (P.Eq, P.Show)

-- ** MaxPrice
newtype MaxPrice = MaxPrice { unMaxPrice :: Double } deriving (P.Eq, P.Show)

-- ** MaxProtein
newtype MaxProtein = MaxProtein { unMaxProtein :: Double } deriving (P.Eq, P.Show)

-- ** MaxProteinPercent
newtype MaxProteinPercent = MaxProteinPercent { unMaxProteinPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxReadyTime
newtype MaxReadyTime = MaxReadyTime { unMaxReadyTime :: Double } deriving (P.Eq, P.Show)

-- ** MaxSaturatedFat
newtype MaxSaturatedFat = MaxSaturatedFat { unMaxSaturatedFat :: Double } deriving (P.Eq, P.Show)

-- ** MaxSelenium
newtype MaxSelenium = MaxSelenium { unMaxSelenium :: Double } deriving (P.Eq, P.Show)

-- ** MaxSodium
newtype MaxSodium = MaxSodium { unMaxSodium :: Double } deriving (P.Eq, P.Show)

-- ** MaxSugar
newtype MaxSugar = MaxSugar { unMaxSugar :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminA
newtype MaxVitaminA = MaxVitaminA { unMaxVitaminA :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB1
newtype MaxVitaminB1 = MaxVitaminB1 { unMaxVitaminB1 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB12
newtype MaxVitaminB12 = MaxVitaminB12 { unMaxVitaminB12 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB2
newtype MaxVitaminB2 = MaxVitaminB2 { unMaxVitaminB2 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB3
newtype MaxVitaminB3 = MaxVitaminB3 { unMaxVitaminB3 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB5
newtype MaxVitaminB5 = MaxVitaminB5 { unMaxVitaminB5 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB6
newtype MaxVitaminB6 = MaxVitaminB6 { unMaxVitaminB6 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminC
newtype MaxVitaminC = MaxVitaminC { unMaxVitaminC :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminD
newtype MaxVitaminD = MaxVitaminD { unMaxVitaminD :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminE
newtype MaxVitaminE = MaxVitaminE { unMaxVitaminE :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminK
newtype MaxVitaminK = MaxVitaminK { unMaxVitaminK :: Double } deriving (P.Eq, P.Show)

-- ** MaxZinc
newtype MaxZinc = MaxZinc { unMaxZinc :: Double } deriving (P.Eq, P.Show)

-- ** Measure
newtype Measure = Measure { unMeasure :: Text } deriving (P.Eq, P.Show)

-- ** MetaInformation
newtype MetaInformation = MetaInformation { unMetaInformation :: Bool } deriving (P.Eq, P.Show)

-- ** MinAlcohol
newtype MinAlcohol = MinAlcohol { unMinAlcohol :: Double } deriving (P.Eq, P.Show)

-- ** MinCaffeine
newtype MinCaffeine = MinCaffeine { unMinCaffeine :: Double } deriving (P.Eq, P.Show)

-- ** MinCalcium
newtype MinCalcium = MinCalcium { unMinCalcium :: Double } deriving (P.Eq, P.Show)

-- ** MinCalories
newtype MinCalories = MinCalories { unMinCalories :: Double } deriving (P.Eq, P.Show)

-- ** MinCarbs
newtype MinCarbs = MinCarbs { unMinCarbs :: Double } deriving (P.Eq, P.Show)

-- ** MinCarbsPercent
newtype MinCarbsPercent = MinCarbsPercent { unMinCarbsPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinCholesterol
newtype MinCholesterol = MinCholesterol { unMinCholesterol :: Double } deriving (P.Eq, P.Show)

-- ** MinCholine
newtype MinCholine = MinCholine { unMinCholine :: Double } deriving (P.Eq, P.Show)

-- ** MinCopper
newtype MinCopper = MinCopper { unMinCopper :: Double } deriving (P.Eq, P.Show)

-- ** MinFat
newtype MinFat = MinFat { unMinFat :: Double } deriving (P.Eq, P.Show)

-- ** MinFatPercent
newtype MinFatPercent = MinFatPercent { unMinFatPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinFiber
newtype MinFiber = MinFiber { unMinFiber :: Double } deriving (P.Eq, P.Show)

-- ** MinFluoride
newtype MinFluoride = MinFluoride { unMinFluoride :: Double } deriving (P.Eq, P.Show)

-- ** MinFolate
newtype MinFolate = MinFolate { unMinFolate :: Double } deriving (P.Eq, P.Show)

-- ** MinFolicAcid
newtype MinFolicAcid = MinFolicAcid { unMinFolicAcid :: Double } deriving (P.Eq, P.Show)

-- ** MinIodine
newtype MinIodine = MinIodine { unMinIodine :: Double } deriving (P.Eq, P.Show)

-- ** MinIron
newtype MinIron = MinIron { unMinIron :: Double } deriving (P.Eq, P.Show)

-- ** MinLength
newtype MinLength = MinLength { unMinLength :: Double } deriving (P.Eq, P.Show)

-- ** MinMagnesium
newtype MinMagnesium = MinMagnesium { unMinMagnesium :: Double } deriving (P.Eq, P.Show)

-- ** MinManganese
newtype MinManganese = MinManganese { unMinManganese :: Double } deriving (P.Eq, P.Show)

-- ** MinPhosphorus
newtype MinPhosphorus = MinPhosphorus { unMinPhosphorus :: Double } deriving (P.Eq, P.Show)

-- ** MinPotassium
newtype MinPotassium = MinPotassium { unMinPotassium :: Double } deriving (P.Eq, P.Show)

-- ** MinProtein
newtype MinProtein = MinProtein { unMinProtein :: Double } deriving (P.Eq, P.Show)

-- ** MinProteinPercent
newtype MinProteinPercent = MinProteinPercent { unMinProteinPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinRating
newtype MinRating = MinRating { unMinRating :: Double } deriving (P.Eq, P.Show)

-- ** MinSaturatedFat
newtype MinSaturatedFat = MinSaturatedFat { unMinSaturatedFat :: Double } deriving (P.Eq, P.Show)

-- ** MinSelenium
newtype MinSelenium = MinSelenium { unMinSelenium :: Double } deriving (P.Eq, P.Show)

-- ** MinSodium
newtype MinSodium = MinSodium { unMinSodium :: Double } deriving (P.Eq, P.Show)

-- ** MinSugar
newtype MinSugar = MinSugar { unMinSugar :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminA
newtype MinVitaminA = MinVitaminA { unMinVitaminA :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB1
newtype MinVitaminB1 = MinVitaminB1 { unMinVitaminB1 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB12
newtype MinVitaminB12 = MinVitaminB12 { unMinVitaminB12 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB2
newtype MinVitaminB2 = MinVitaminB2 { unMinVitaminB2 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB3
newtype MinVitaminB3 = MinVitaminB3 { unMinVitaminB3 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB5
newtype MinVitaminB5 = MinVitaminB5 { unMinVitaminB5 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB6
newtype MinVitaminB6 = MinVitaminB6 { unMinVitaminB6 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminC
newtype MinVitaminC = MinVitaminC { unMinVitaminC :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminD
newtype MinVitaminD = MinVitaminD { unMinVitaminD :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminE
newtype MinVitaminE = MinVitaminE { unMinVitaminE :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminK
newtype MinVitaminK = MinVitaminK { unMinVitaminK :: Double } deriving (P.Eq, P.Show)

-- ** MinZinc
newtype MinZinc = MinZinc { unMinZinc :: Double } deriving (P.Eq, P.Show)

-- ** Mode
newtype Mode = Mode { unMode :: Double } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Double } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Double } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Text } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: Text } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Text } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** Random
newtype Random = Random { unRandom :: Bool } deriving (P.Eq, P.Show)

-- ** Ranking
newtype Ranking = Ranking { unRanking :: Double } deriving (P.Eq, P.Show)

-- ** ReadyInMinutes
newtype ReadyInMinutes = ReadyInMinutes { unReadyInMinutes :: Double } deriving (P.Eq, P.Show)

-- ** RecipeBoxId
newtype RecipeBoxId = RecipeBoxId { unRecipeBoxId :: Double } deriving (P.Eq, P.Show)

-- ** Servings
newtype Servings = Servings { unServings :: Double } deriving (P.Eq, P.Show)

-- ** ShowBacklink
newtype ShowBacklink = ShowBacklink { unShowBacklink :: Bool } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: Text } deriving (P.Eq, P.Show)

-- ** Source
newtype Source = Source { unSource :: Text } deriving (P.Eq, P.Show)

-- ** SourceAmount
newtype SourceAmount = SourceAmount { unSourceAmount :: Double } deriving (P.Eq, P.Show)

-- ** SourceUnit
newtype SourceUnit = SourceUnit { unSourceUnit :: Text } deriving (P.Eq, P.Show)

-- ** StartDate
newtype StartDate = StartDate { unStartDate :: Text } deriving (P.Eq, P.Show)

-- ** StepBreakdown
newtype StepBreakdown = StepBreakdown { unStepBreakdown :: Bool } deriving (P.Eq, P.Show)

-- ** Tags
newtype Tags = Tags { unTags :: Text } deriving (P.Eq, P.Show)

-- ** TargetCalories
newtype TargetCalories = TargetCalories { unTargetCalories :: Double } deriving (P.Eq, P.Show)

-- ** TargetUnit
newtype TargetUnit = TargetUnit { unTargetUnit :: Text } deriving (P.Eq, P.Show)

-- ** TimeFrame
newtype TimeFrame = TimeFrame { unTimeFrame :: Text } deriving (P.Eq, P.Show)

-- ** Title
newtype Title = Title { unTitle :: Text } deriving (P.Eq, P.Show)

-- ** TitleMatch
newtype TitleMatch = TitleMatch { unTitleMatch :: Text } deriving (P.Eq, P.Show)

-- ** Unit
newtype Unit = Unit { unUnit :: Text } deriving (P.Eq, P.Show)

-- ** Upc
newtype Upc = Upc { unUpc :: Double } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- ** Username
newtype Username = Username { unUsername :: Text } deriving (P.Eq, P.Show)

-- ** View
newtype View = View { unView :: Text } deriving (P.Eq, P.Show)

-- ** Wine
newtype Wine = Wine { unWine :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** InlineObject
-- | InlineObject
data InlineObject = InlineObject
  { inlineObjectIngredientList :: !(Text) -- ^ /Required/ "ingredientList" - The ingredient list of the recipe, one ingredient per line.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject
instance A.FromJSON InlineObject where
  parseJSON = A.withObject "InlineObject" $ \o ->
    InlineObject
      <$> (o .:  "ingredientList")

-- | ToJSON InlineObject
instance A.ToJSON InlineObject where
  toJSON InlineObject {..} =
   _omitNulls
      [ "ingredientList" .= inlineObjectIngredientList
      ]


-- | Construct a value of type 'InlineObject' (by applying it's required fields, if any)
mkInlineObject
  :: Text -- ^ 'inlineObjectIngredientList': The ingredient list of the recipe, one ingredient per line.
  -> InlineObject
mkInlineObject inlineObjectIngredientList =
  InlineObject
  { inlineObjectIngredientList
  }

-- ** InlineObject1
-- | InlineObject1
data InlineObject1 = InlineObject1
  { inlineObject1IngredientList :: !(Text) -- ^ /Required/ "ingredientList" - The ingredient list of the recipe, one ingredient per line.
  , inlineObject1Servings :: !(Double) -- ^ /Required/ "servings" - The number of servings.
  , inlineObject1DefaultCss :: !(Maybe Bool) -- ^ "defaultCss" - Whether the default CSS should be added to the response.
  , inlineObject1ShowBacklink :: !(Maybe Bool) -- ^ "showBacklink" - Whether to show a backlink to spoonacular. If set false, this call counts against your quota.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject1
instance A.FromJSON InlineObject1 where
  parseJSON = A.withObject "InlineObject1" $ \o ->
    InlineObject1
      <$> (o .:  "ingredientList")
      <*> (o .:  "servings")
      <*> (o .:? "defaultCss")
      <*> (o .:? "showBacklink")

-- | ToJSON InlineObject1
instance A.ToJSON InlineObject1 where
  toJSON InlineObject1 {..} =
   _omitNulls
      [ "ingredientList" .= inlineObject1IngredientList
      , "servings" .= inlineObject1Servings
      , "defaultCss" .= inlineObject1DefaultCss
      , "showBacklink" .= inlineObject1ShowBacklink
      ]


-- | Construct a value of type 'InlineObject1' (by applying it's required fields, if any)
mkInlineObject1
  :: Text -- ^ 'inlineObject1IngredientList': The ingredient list of the recipe, one ingredient per line.
  -> Double -- ^ 'inlineObject1Servings': The number of servings.
  -> InlineObject1
mkInlineObject1 inlineObject1IngredientList inlineObject1Servings =
  InlineObject1
  { inlineObject1IngredientList
  , inlineObject1Servings
  , inlineObject1DefaultCss = Nothing
  , inlineObject1ShowBacklink = Nothing
  }

-- ** InlineObject10
-- | InlineObject10
data InlineObject10 = InlineObject10
  { inlineObject10Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject10Date :: !(Text) -- ^ /Required/ "date" - The date in the format yyyy-mm-dd.
  , inlineObject10Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject10
instance A.FromJSON InlineObject10 where
  parseJSON = A.withObject "InlineObject10" $ \o ->
    InlineObject10
      <$> (o .:  "username")
      <*> (o .:  "date")
      <*> (o .:  "hash")

-- | ToJSON InlineObject10
instance A.ToJSON InlineObject10 where
  toJSON InlineObject10 {..} =
   _omitNulls
      [ "username" .= inlineObject10Username
      , "date" .= inlineObject10Date
      , "hash" .= inlineObject10Hash
      ]


-- | Construct a value of type 'InlineObject10' (by applying it's required fields, if any)
mkInlineObject10
  :: Text -- ^ 'inlineObject10Username': The username.
  -> Text -- ^ 'inlineObject10Date': The date in the format yyyy-mm-dd.
  -> Text -- ^ 'inlineObject10Hash': The private hash for the username.
  -> InlineObject10
mkInlineObject10 inlineObject10Username inlineObject10Date inlineObject10Hash =
  InlineObject10
  { inlineObject10Username
  , inlineObject10Date
  , inlineObject10Hash
  }

-- ** InlineObject11
-- | InlineObject11
data InlineObject11 = InlineObject11
  { inlineObject11Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject11Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject11
instance A.FromJSON InlineObject11 where
  parseJSON = A.withObject "InlineObject11" $ \o ->
    InlineObject11
      <$> (o .:  "username")
      <*> (o .:  "hash")

-- | ToJSON InlineObject11
instance A.ToJSON InlineObject11 where
  toJSON InlineObject11 {..} =
   _omitNulls
      [ "username" .= inlineObject11Username
      , "hash" .= inlineObject11Hash
      ]


-- | Construct a value of type 'InlineObject11' (by applying it's required fields, if any)
mkInlineObject11
  :: Text -- ^ 'inlineObject11Username': The username.
  -> Text -- ^ 'inlineObject11Hash': The private hash for the username.
  -> InlineObject11
mkInlineObject11 inlineObject11Username inlineObject11Hash =
  InlineObject11
  { inlineObject11Username
  , inlineObject11Hash
  }

-- ** InlineObject12
-- | InlineObject12
data InlineObject12 = InlineObject12
  { inlineObject12Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject12Id :: !(Double) -- ^ /Required/ "id" - The shopping list item id.
  , inlineObject12Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject12
instance A.FromJSON InlineObject12 where
  parseJSON = A.withObject "InlineObject12" $ \o ->
    InlineObject12
      <$> (o .:  "username")
      <*> (o .:  "id")
      <*> (o .:  "hash")

-- | ToJSON InlineObject12
instance A.ToJSON InlineObject12 where
  toJSON InlineObject12 {..} =
   _omitNulls
      [ "username" .= inlineObject12Username
      , "id" .= inlineObject12Id
      , "hash" .= inlineObject12Hash
      ]


-- | Construct a value of type 'InlineObject12' (by applying it's required fields, if any)
mkInlineObject12
  :: Text -- ^ 'inlineObject12Username': The username.
  -> Double -- ^ 'inlineObject12Id': The shopping list item id.
  -> Text -- ^ 'inlineObject12Hash': The private hash for the username.
  -> InlineObject12
mkInlineObject12 inlineObject12Username inlineObject12Id inlineObject12Hash =
  InlineObject12
  { inlineObject12Username
  , inlineObject12Id
  , inlineObject12Hash
  }

-- ** InlineObject13
-- | InlineObject13
data InlineObject13 = InlineObject13
  { inlineObject13Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject13StartDate :: !(Text) -- ^ /Required/ "start-date" - The start date in the format yyyy-mm-dd.
  , inlineObject13EndDate :: !(Text) -- ^ /Required/ "end-date" - The end date in the format yyyy-mm-dd.
  , inlineObject13Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject13
instance A.FromJSON InlineObject13 where
  parseJSON = A.withObject "InlineObject13" $ \o ->
    InlineObject13
      <$> (o .:  "username")
      <*> (o .:  "start-date")
      <*> (o .:  "end-date")
      <*> (o .:  "hash")

-- | ToJSON InlineObject13
instance A.ToJSON InlineObject13 where
  toJSON InlineObject13 {..} =
   _omitNulls
      [ "username" .= inlineObject13Username
      , "start-date" .= inlineObject13StartDate
      , "end-date" .= inlineObject13EndDate
      , "hash" .= inlineObject13Hash
      ]


-- | Construct a value of type 'InlineObject13' (by applying it's required fields, if any)
mkInlineObject13
  :: Text -- ^ 'inlineObject13Username': The username.
  -> Text -- ^ 'inlineObject13StartDate': The start date in the format yyyy-mm-dd.
  -> Text -- ^ 'inlineObject13EndDate': The end date in the format yyyy-mm-dd.
  -> Text -- ^ 'inlineObject13Hash': The private hash for the username.
  -> InlineObject13
mkInlineObject13 inlineObject13Username inlineObject13StartDate inlineObject13EndDate inlineObject13Hash =
  InlineObject13
  { inlineObject13Username
  , inlineObject13StartDate
  , inlineObject13EndDate
  , inlineObject13Hash
  }

-- ** InlineObject14
-- | InlineObject14
data InlineObject14 = InlineObject14
  { inlineObject14Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject14Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject14
instance A.FromJSON InlineObject14 where
  parseJSON = A.withObject "InlineObject14" $ \o ->
    InlineObject14
      <$> (o .:  "username")
      <*> (o .:  "hash")

-- | ToJSON InlineObject14
instance A.ToJSON InlineObject14 where
  toJSON InlineObject14 {..} =
   _omitNulls
      [ "username" .= inlineObject14Username
      , "hash" .= inlineObject14Hash
      ]


-- | Construct a value of type 'InlineObject14' (by applying it's required fields, if any)
mkInlineObject14
  :: Text -- ^ 'inlineObject14Username': The username.
  -> Text -- ^ 'inlineObject14Hash': The private hash for the username.
  -> InlineObject14
mkInlineObject14 inlineObject14Username inlineObject14Hash =
  InlineObject14
  { inlineObject14Username
  , inlineObject14Hash
  }

-- ** InlineObject15
-- | InlineObject15
data InlineObject15 = InlineObject15
  { inlineObject15Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject15Id :: !(Double) -- ^ /Required/ "id" - The shopping list item id.
  , inlineObject15Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject15
instance A.FromJSON InlineObject15 where
  parseJSON = A.withObject "InlineObject15" $ \o ->
    InlineObject15
      <$> (o .:  "username")
      <*> (o .:  "id")
      <*> (o .:  "hash")

-- | ToJSON InlineObject15
instance A.ToJSON InlineObject15 where
  toJSON InlineObject15 {..} =
   _omitNulls
      [ "username" .= inlineObject15Username
      , "id" .= inlineObject15Id
      , "hash" .= inlineObject15Hash
      ]


-- | Construct a value of type 'InlineObject15' (by applying it's required fields, if any)
mkInlineObject15
  :: Text -- ^ 'inlineObject15Username': The username.
  -> Double -- ^ 'inlineObject15Id': The shopping list item id.
  -> Text -- ^ 'inlineObject15Hash': The private hash for the username.
  -> InlineObject15
mkInlineObject15 inlineObject15Username inlineObject15Id inlineObject15Hash =
  InlineObject15
  { inlineObject15Username
  , inlineObject15Id
  , inlineObject15Hash
  }

-- ** InlineObject16
-- | InlineObject16
data InlineObject16 = InlineObject16
  { inlineObject16Text :: !(Text) -- ^ /Required/ "text" - The text in which food items, such as dish names and ingredients, should be detected in.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject16
instance A.FromJSON InlineObject16 where
  parseJSON = A.withObject "InlineObject16" $ \o ->
    InlineObject16
      <$> (o .:  "text")

-- | ToJSON InlineObject16
instance A.ToJSON InlineObject16 where
  toJSON InlineObject16 {..} =
   _omitNulls
      [ "text" .= inlineObject16Text
      ]


-- | Construct a value of type 'InlineObject16' (by applying it's required fields, if any)
mkInlineObject16
  :: Text -- ^ 'inlineObject16Text': The text in which food items, such as dish names and ingredients, should be detected in.
  -> InlineObject16
mkInlineObject16 inlineObject16Text =
  InlineObject16
  { inlineObject16Text
  }

-- ** InlineObject2
-- | InlineObject2
data InlineObject2 = InlineObject2
  { inlineObject2IngredientList :: !(Text) -- ^ /Required/ "ingredientList" - The ingredient list of the recipe, one ingredient per line.
  , inlineObject2Servings :: !(Double) -- ^ /Required/ "servings" - The number of servings.
  , inlineObject2Mode :: !(Maybe Double) -- ^ "mode" - The mode in which the widget should be delivered. 1 &#x3D; separate views (compact), 2 &#x3D; all in one view (full).
  , inlineObject2DefaultCss :: !(Maybe Bool) -- ^ "defaultCss" - Whether the default CSS should be added to the response.
  , inlineObject2ShowBacklink :: !(Maybe Bool) -- ^ "showBacklink" - Whether to show a backlink to spoonacular. If set false, this call counts against your quota.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject2
instance A.FromJSON InlineObject2 where
  parseJSON = A.withObject "InlineObject2" $ \o ->
    InlineObject2
      <$> (o .:  "ingredientList")
      <*> (o .:  "servings")
      <*> (o .:? "mode")
      <*> (o .:? "defaultCss")
      <*> (o .:? "showBacklink")

-- | ToJSON InlineObject2
instance A.ToJSON InlineObject2 where
  toJSON InlineObject2 {..} =
   _omitNulls
      [ "ingredientList" .= inlineObject2IngredientList
      , "servings" .= inlineObject2Servings
      , "mode" .= inlineObject2Mode
      , "defaultCss" .= inlineObject2DefaultCss
      , "showBacklink" .= inlineObject2ShowBacklink
      ]


-- | Construct a value of type 'InlineObject2' (by applying it's required fields, if any)
mkInlineObject2
  :: Text -- ^ 'inlineObject2IngredientList': The ingredient list of the recipe, one ingredient per line.
  -> Double -- ^ 'inlineObject2Servings': The number of servings.
  -> InlineObject2
mkInlineObject2 inlineObject2IngredientList inlineObject2Servings =
  InlineObject2
  { inlineObject2IngredientList
  , inlineObject2Servings
  , inlineObject2Mode = Nothing
  , inlineObject2DefaultCss = Nothing
  , inlineObject2ShowBacklink = Nothing
  }

-- ** InlineObject3
-- | InlineObject3
data InlineObject3 = InlineObject3
  { inlineObject3Instructions :: !(Text) -- ^ /Required/ "instructions" - The recipe&#39;s instructions.
  , inlineObject3View :: !(Maybe Text) -- ^ "view" - How to visualize the equipment, either \&quot;grid\&quot; or \&quot;list\&quot;.
  , inlineObject3DefaultCss :: !(Maybe Bool) -- ^ "defaultCss" - Whether the default CSS should be added to the response.
  , inlineObject3ShowBacklink :: !(Maybe Bool) -- ^ "showBacklink" - Whether to show a backlink to spoonacular. If set false, this call counts against your quota.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject3
instance A.FromJSON InlineObject3 where
  parseJSON = A.withObject "InlineObject3" $ \o ->
    InlineObject3
      <$> (o .:  "instructions")
      <*> (o .:? "view")
      <*> (o .:? "defaultCss")
      <*> (o .:? "showBacklink")

-- | ToJSON InlineObject3
instance A.ToJSON InlineObject3 where
  toJSON InlineObject3 {..} =
   _omitNulls
      [ "instructions" .= inlineObject3Instructions
      , "view" .= inlineObject3View
      , "defaultCss" .= inlineObject3DefaultCss
      , "showBacklink" .= inlineObject3ShowBacklink
      ]


-- | Construct a value of type 'InlineObject3' (by applying it's required fields, if any)
mkInlineObject3
  :: Text -- ^ 'inlineObject3Instructions': The recipe's instructions.
  -> InlineObject3
mkInlineObject3 inlineObject3Instructions =
  InlineObject3
  { inlineObject3Instructions
  , inlineObject3View = Nothing
  , inlineObject3DefaultCss = Nothing
  , inlineObject3ShowBacklink = Nothing
  }

-- ** InlineObject4
-- | InlineObject4
data InlineObject4 = InlineObject4
  { inlineObject4Title :: !(Text) -- ^ /Required/ "title" - The title of the recipe.
  , inlineObject4Image :: !(FilePath) -- ^ /Required/ "image" - The binary image of the recipe as jpg.
  , inlineObject4Ingredients :: !(Text) -- ^ /Required/ "ingredients" - The ingredient list of the recipe, one ingredient per line (separate lines with \\n).
  , inlineObject4Instructions :: !(Text) -- ^ /Required/ "instructions" - The instructions to make the recipe. One step per line (separate lines with \\n).
  , inlineObject4ReadyInMinutes :: !(Double) -- ^ /Required/ "readyInMinutes" - The number of minutes it takes to get the recipe on the table.
  , inlineObject4Servings :: !(Double) -- ^ /Required/ "servings" - The number of servings the recipe makes.
  , inlineObject4Mask :: !(Text) -- ^ /Required/ "mask" - The mask to put over the recipe image (\&quot;ellipseMask\&quot;, \&quot;diamondMask\&quot;, \&quot;starMask\&quot;, \&quot;heartMask\&quot;, \&quot;potMask\&quot;, \&quot;fishMask\&quot;).
  , inlineObject4BackgroundImage :: !(Text) -- ^ /Required/ "backgroundImage" - The background image (\&quot;none\&quot;,\&quot;background1\&quot;, or \&quot;background2\&quot;).
  , inlineObject4Author :: !(Maybe Text) -- ^ "author" - The author of the recipe.
  , inlineObject4BackgroundColor :: !(Maybe Text) -- ^ "backgroundColor" - The background color for the recipe card as a hex-string.
  , inlineObject4FontColor :: !(Maybe Text) -- ^ "fontColor" - The font color for the recipe card as a hex-string.
  , inlineObject4Source :: !(Maybe Text) -- ^ "source" - The source of the recipe.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject4
instance A.FromJSON InlineObject4 where
  parseJSON = A.withObject "InlineObject4" $ \o ->
    InlineObject4
      <$> (o .:  "title")
      <*> (o .:  "image")
      <*> (o .:  "ingredients")
      <*> (o .:  "instructions")
      <*> (o .:  "readyInMinutes")
      <*> (o .:  "servings")
      <*> (o .:  "mask")
      <*> (o .:  "backgroundImage")
      <*> (o .:? "author")
      <*> (o .:? "backgroundColor")
      <*> (o .:? "fontColor")
      <*> (o .:? "source")

-- | ToJSON InlineObject4
instance A.ToJSON InlineObject4 where
  toJSON InlineObject4 {..} =
   _omitNulls
      [ "title" .= inlineObject4Title
      , "image" .= inlineObject4Image
      , "ingredients" .= inlineObject4Ingredients
      , "instructions" .= inlineObject4Instructions
      , "readyInMinutes" .= inlineObject4ReadyInMinutes
      , "servings" .= inlineObject4Servings
      , "mask" .= inlineObject4Mask
      , "backgroundImage" .= inlineObject4BackgroundImage
      , "author" .= inlineObject4Author
      , "backgroundColor" .= inlineObject4BackgroundColor
      , "fontColor" .= inlineObject4FontColor
      , "source" .= inlineObject4Source
      ]


-- | Construct a value of type 'InlineObject4' (by applying it's required fields, if any)
mkInlineObject4
  :: Text -- ^ 'inlineObject4Title': The title of the recipe.
  -> FilePath -- ^ 'inlineObject4Image': The binary image of the recipe as jpg.
  -> Text -- ^ 'inlineObject4Ingredients': The ingredient list of the recipe, one ingredient per line (separate lines with \\n).
  -> Text -- ^ 'inlineObject4Instructions': The instructions to make the recipe. One step per line (separate lines with \\n).
  -> Double -- ^ 'inlineObject4ReadyInMinutes': The number of minutes it takes to get the recipe on the table.
  -> Double -- ^ 'inlineObject4Servings': The number of servings the recipe makes.
  -> Text -- ^ 'inlineObject4Mask': The mask to put over the recipe image (\"ellipseMask\", \"diamondMask\", \"starMask\", \"heartMask\", \"potMask\", \"fishMask\").
  -> Text -- ^ 'inlineObject4BackgroundImage': The background image (\"none\",\"background1\", or \"background2\").
  -> InlineObject4
mkInlineObject4 inlineObject4Title inlineObject4Image inlineObject4Ingredients inlineObject4Instructions inlineObject4ReadyInMinutes inlineObject4Servings inlineObject4Mask inlineObject4BackgroundImage =
  InlineObject4
  { inlineObject4Title
  , inlineObject4Image
  , inlineObject4Ingredients
  , inlineObject4Instructions
  , inlineObject4ReadyInMinutes
  , inlineObject4Servings
  , inlineObject4Mask
  , inlineObject4BackgroundImage
  , inlineObject4Author = Nothing
  , inlineObject4BackgroundColor = Nothing
  , inlineObject4FontColor = Nothing
  , inlineObject4Source = Nothing
  }

-- ** InlineObject5
-- | InlineObject5
data InlineObject5 = InlineObject5
  { inlineObject5Instructions :: !(Text) -- ^ /Required/ "instructions" - The instructions to be analyzed.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject5
instance A.FromJSON InlineObject5 where
  parseJSON = A.withObject "InlineObject5" $ \o ->
    InlineObject5
      <$> (o .:  "instructions")

-- | ToJSON InlineObject5
instance A.ToJSON InlineObject5 where
  toJSON InlineObject5 {..} =
   _omitNulls
      [ "instructions" .= inlineObject5Instructions
      ]


-- | Construct a value of type 'InlineObject5' (by applying it's required fields, if any)
mkInlineObject5
  :: Text -- ^ 'inlineObject5Instructions': The instructions to be analyzed.
  -> InlineObject5
mkInlineObject5 inlineObject5Instructions =
  InlineObject5
  { inlineObject5Instructions
  }

-- ** InlineObject6
-- | InlineObject6
data InlineObject6 = InlineObject6
  { inlineObject6Title :: !(Text) -- ^ /Required/ "title" - The title of the recipe.
  , inlineObject6IngredientList :: !(Text) -- ^ /Required/ "ingredientList" - The ingredient list of the recipe, one ingredient per line (separate lines with \\n).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject6
instance A.FromJSON InlineObject6 where
  parseJSON = A.withObject "InlineObject6" $ \o ->
    InlineObject6
      <$> (o .:  "title")
      <*> (o .:  "ingredientList")

-- | ToJSON InlineObject6
instance A.ToJSON InlineObject6 where
  toJSON InlineObject6 {..} =
   _omitNulls
      [ "title" .= inlineObject6Title
      , "ingredientList" .= inlineObject6IngredientList
      ]


-- | Construct a value of type 'InlineObject6' (by applying it's required fields, if any)
mkInlineObject6
  :: Text -- ^ 'inlineObject6Title': The title of the recipe.
  -> Text -- ^ 'inlineObject6IngredientList': The ingredient list of the recipe, one ingredient per line (separate lines with \\n).
  -> InlineObject6
mkInlineObject6 inlineObject6Title inlineObject6IngredientList =
  InlineObject6
  { inlineObject6Title
  , inlineObject6IngredientList
  }

-- ** InlineObject7
-- | InlineObject7
data InlineObject7 = InlineObject7
  { inlineObject7IngredientList :: !(Text) -- ^ /Required/ "ingredientList" - The ingredient list of the recipe, one ingredient per line.
  , inlineObject7Servings :: !(Double) -- ^ /Required/ "servings" - The number of servings that you can make from the ingredients.
  , inlineObject7IncludeNutrition :: !(Maybe Bool) -- ^ "includeNutrition" - Whether nutrition data should be added to correctly parsed ingredients.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject7
instance A.FromJSON InlineObject7 where
  parseJSON = A.withObject "InlineObject7" $ \o ->
    InlineObject7
      <$> (o .:  "ingredientList")
      <*> (o .:  "servings")
      <*> (o .:? "includeNutrition")

-- | ToJSON InlineObject7
instance A.ToJSON InlineObject7 where
  toJSON InlineObject7 {..} =
   _omitNulls
      [ "ingredientList" .= inlineObject7IngredientList
      , "servings" .= inlineObject7Servings
      , "includeNutrition" .= inlineObject7IncludeNutrition
      ]


-- | Construct a value of type 'InlineObject7' (by applying it's required fields, if any)
mkInlineObject7
  :: Text -- ^ 'inlineObject7IngredientList': The ingredient list of the recipe, one ingredient per line.
  -> Double -- ^ 'inlineObject7Servings': The number of servings that you can make from the ingredients.
  -> InlineObject7
mkInlineObject7 inlineObject7IngredientList inlineObject7Servings =
  InlineObject7
  { inlineObject7IngredientList
  , inlineObject7Servings
  , inlineObject7IncludeNutrition = Nothing
  }

-- ** InlineObject8
-- | InlineObject8
data InlineObject8 = InlineObject8
  { inlineObject8IngredientList :: !(Text) -- ^ /Required/ "ingredientList" - The ingredient list of the recipe, one ingredient per line.
  , inlineObject8Servings :: !(Double) -- ^ /Required/ "servings" - The number of servings.
  , inlineObject8Measure :: !(Maybe Text) -- ^ "measure" - The original system of measurement, either \&quot;metric\&quot; or \&quot;us\&quot;.
  , inlineObject8View :: !(Maybe Text) -- ^ "view" - How to visualize the ingredients, either \&quot;grid\&quot; or \&quot;list\&quot;.
  , inlineObject8DefaultCss :: !(Maybe Bool) -- ^ "defaultCss" - Whether the default CSS should be added to the response.
  , inlineObject8ShowBacklink :: !(Maybe Bool) -- ^ "showBacklink" - Whether to show a backlink to spoonacular. If set false, this call counts against your quota.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject8
instance A.FromJSON InlineObject8 where
  parseJSON = A.withObject "InlineObject8" $ \o ->
    InlineObject8
      <$> (o .:  "ingredientList")
      <*> (o .:  "servings")
      <*> (o .:? "measure")
      <*> (o .:? "view")
      <*> (o .:? "defaultCss")
      <*> (o .:? "showBacklink")

-- | ToJSON InlineObject8
instance A.ToJSON InlineObject8 where
  toJSON InlineObject8 {..} =
   _omitNulls
      [ "ingredientList" .= inlineObject8IngredientList
      , "servings" .= inlineObject8Servings
      , "measure" .= inlineObject8Measure
      , "view" .= inlineObject8View
      , "defaultCss" .= inlineObject8DefaultCss
      , "showBacklink" .= inlineObject8ShowBacklink
      ]


-- | Construct a value of type 'InlineObject8' (by applying it's required fields, if any)
mkInlineObject8
  :: Text -- ^ 'inlineObject8IngredientList': The ingredient list of the recipe, one ingredient per line.
  -> Double -- ^ 'inlineObject8Servings': The number of servings.
  -> InlineObject8
mkInlineObject8 inlineObject8IngredientList inlineObject8Servings =
  InlineObject8
  { inlineObject8IngredientList
  , inlineObject8Servings
  , inlineObject8Measure = Nothing
  , inlineObject8View = Nothing
  , inlineObject8DefaultCss = Nothing
  , inlineObject8ShowBacklink = Nothing
  }

-- ** InlineObject9
-- | InlineObject9
data InlineObject9 = InlineObject9
  { inlineObject9Locale :: !(Maybe Text) -- ^ "locale" - The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject9
instance A.FromJSON InlineObject9 where
  parseJSON = A.withObject "InlineObject9" $ \o ->
    InlineObject9
      <$> (o .:? "locale")

-- | ToJSON InlineObject9
instance A.ToJSON InlineObject9 where
  toJSON InlineObject9 {..} =
   _omitNulls
      [ "locale" .= inlineObject9Locale
      ]


-- | Construct a value of type 'InlineObject9' (by applying it's required fields, if any)
mkInlineObject9
  :: InlineObject9
mkInlineObject9 =
  InlineObject9
  { inlineObject9Locale = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKeyScheme
data AuthApiKeyApiKeyScheme =
  AuthApiKeyApiKeyScheme Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKeyScheme where
  applyAuthMethod _ a@(AuthApiKeyApiKeyScheme secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("apiKey", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


