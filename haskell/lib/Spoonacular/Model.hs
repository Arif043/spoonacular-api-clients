{-
   spoonacular API

   The spoonacular Nutrition, Recipe, and Food API allows you to access over 380,000 recipes, thousands of ingredients, 800,000 food products, and 100,000 menu items. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

   OpenAPI Version: 3.0.0
   spoonacular API API version: 1.0
   Contact: mail@spoonacular.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Spoonacular.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Spoonacular.Model where

import Spoonacular.Core
import Spoonacular.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AddChildren
newtype AddChildren = AddChildren { unAddChildren :: Bool } deriving (P.Eq, P.Show)

-- ** AddRecipeInformation
newtype AddRecipeInformation = AddRecipeInformation { unAddRecipeInformation :: Bool } deriving (P.Eq, P.Show)

-- ** AddRecipeNutrition
newtype AddRecipeNutrition = AddRecipeNutrition { unAddRecipeNutrition :: Bool } deriving (P.Eq, P.Show)

-- ** Amount
newtype Amount = Amount { unAmount :: Double } deriving (P.Eq, P.Show)

-- ** Analyze
newtype Analyze = Analyze { unAnalyze :: Bool } deriving (P.Eq, P.Show)

-- ** Author
newtype Author = Author { unAuthor :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: A.Value } deriving (P.Eq, P.Show, A.ToJSON)

-- ** ContextId
newtype ContextId = ContextId { unContextId :: Text } deriving (P.Eq, P.Show)

-- ** Cuisine
newtype Cuisine = Cuisine { unCuisine :: Text } deriving (P.Eq, P.Show)

-- ** DefaultCss
newtype DefaultCss = DefaultCss { unDefaultCss :: Bool } deriving (P.Eq, P.Show)

-- ** Diet
newtype Diet = Diet { unDiet :: Text } deriving (P.Eq, P.Show)

-- ** EndDate
newtype EndDate = EndDate { unEndDate :: Text } deriving (P.Eq, P.Show)

-- ** Equipment
newtype Equipment = Equipment { unEquipment :: Text } deriving (P.Eq, P.Show)

-- ** Exclude
newtype Exclude = Exclude { unExclude :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeCuisine
newtype ExcludeCuisine = ExcludeCuisine { unExcludeCuisine :: Text } deriving (P.Eq, P.Show)

-- ** ExcludeIngredients
newtype ExcludeIngredients = ExcludeIngredients { unExcludeIngredients :: Text } deriving (P.Eq, P.Show)

-- ** FillIngredients
newtype FillIngredients = FillIngredients { unFillIngredients :: Bool } deriving (P.Eq, P.Show)

-- ** Food
newtype Food = Food { unFood :: Text } deriving (P.Eq, P.Show)

-- ** ForceExtraction
newtype ForceExtraction = ForceExtraction { unForceExtraction :: Bool } deriving (P.Eq, P.Show)

-- ** Hash
newtype Hash = Hash { unHash :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Int } deriving (P.Eq, P.Show)

-- ** IdDouble
newtype IdDouble = IdDouble { unIdDouble :: Double } deriving (P.Eq, P.Show)

-- ** Ids
newtype Ids = Ids { unIds :: Text } deriving (P.Eq, P.Show)

-- ** IgnorePantry
newtype IgnorePantry = IgnorePantry { unIgnorePantry :: Bool } deriving (P.Eq, P.Show)

-- ** ImageUrl
newtype ImageUrl = ImageUrl { unImageUrl :: Text } deriving (P.Eq, P.Show)

-- ** IncludeIngredients
newtype IncludeIngredients = IncludeIngredients { unIncludeIngredients :: Text } deriving (P.Eq, P.Show)

-- ** IncludeNutrition
newtype IncludeNutrition = IncludeNutrition { unIncludeNutrition :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeTaste
newtype IncludeTaste = IncludeTaste { unIncludeTaste :: Bool } deriving (P.Eq, P.Show)

-- ** IngredientName
newtype IngredientName = IngredientName { unIngredientName :: Text } deriving (P.Eq, P.Show)

-- ** Ingredients
newtype Ingredients = Ingredients { unIngredients :: Text } deriving (P.Eq, P.Show)

-- ** InlineObject9
newtype InlineObject9 = InlineObject9 { unInlineObject9 :: [InlineObject] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InstructionsRequired
newtype InstructionsRequired = InstructionsRequired { unInstructionsRequired :: Bool } deriving (P.Eq, P.Show)

-- ** Intolerances
newtype Intolerances = Intolerances { unIntolerances :: Text } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: E'Language } deriving (P.Eq, P.Show)

-- ** LimitLicense
newtype LimitLicense = LimitLicense { unLimitLicense :: Bool } deriving (P.Eq, P.Show)

-- ** Locale
newtype Locale = Locale { unLocale :: E'Locale } deriving (P.Eq, P.Show)

-- ** LocaleText
newtype LocaleText = LocaleText { unLocaleText :: Text } deriving (P.Eq, P.Show)

-- ** MaxAlcohol
newtype MaxAlcohol = MaxAlcohol { unMaxAlcohol :: Double } deriving (P.Eq, P.Show)

-- ** MaxCaffeine
newtype MaxCaffeine = MaxCaffeine { unMaxCaffeine :: Double } deriving (P.Eq, P.Show)

-- ** MaxCalcium
newtype MaxCalcium = MaxCalcium { unMaxCalcium :: Double } deriving (P.Eq, P.Show)

-- ** MaxCalories
newtype MaxCalories = MaxCalories { unMaxCalories :: Double } deriving (P.Eq, P.Show)

-- ** MaxCarbs
newtype MaxCarbs = MaxCarbs { unMaxCarbs :: Double } deriving (P.Eq, P.Show)

-- ** MaxCarbsPercent
newtype MaxCarbsPercent = MaxCarbsPercent { unMaxCarbsPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxCholesterol
newtype MaxCholesterol = MaxCholesterol { unMaxCholesterol :: Double } deriving (P.Eq, P.Show)

-- ** MaxCholine
newtype MaxCholine = MaxCholine { unMaxCholine :: Double } deriving (P.Eq, P.Show)

-- ** MaxCopper
newtype MaxCopper = MaxCopper { unMaxCopper :: Double } deriving (P.Eq, P.Show)

-- ** MaxFat
newtype MaxFat = MaxFat { unMaxFat :: Double } deriving (P.Eq, P.Show)

-- ** MaxFatPercent
newtype MaxFatPercent = MaxFatPercent { unMaxFatPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxFiber
newtype MaxFiber = MaxFiber { unMaxFiber :: Double } deriving (P.Eq, P.Show)

-- ** MaxFluoride
newtype MaxFluoride = MaxFluoride { unMaxFluoride :: Double } deriving (P.Eq, P.Show)

-- ** MaxFolate
newtype MaxFolate = MaxFolate { unMaxFolate :: Double } deriving (P.Eq, P.Show)

-- ** MaxFolicAcid
newtype MaxFolicAcid = MaxFolicAcid { unMaxFolicAcid :: Double } deriving (P.Eq, P.Show)

-- ** MaxIodine
newtype MaxIodine = MaxIodine { unMaxIodine :: Double } deriving (P.Eq, P.Show)

-- ** MaxIron
newtype MaxIron = MaxIron { unMaxIron :: Double } deriving (P.Eq, P.Show)

-- ** MaxLength
newtype MaxLength = MaxLength { unMaxLength :: Double } deriving (P.Eq, P.Show)

-- ** MaxMagnesium
newtype MaxMagnesium = MaxMagnesium { unMaxMagnesium :: Double } deriving (P.Eq, P.Show)

-- ** MaxManganese
newtype MaxManganese = MaxManganese { unMaxManganese :: Double } deriving (P.Eq, P.Show)

-- ** MaxPhosphorus
newtype MaxPhosphorus = MaxPhosphorus { unMaxPhosphorus :: Double } deriving (P.Eq, P.Show)

-- ** MaxPotassium
newtype MaxPotassium = MaxPotassium { unMaxPotassium :: Double } deriving (P.Eq, P.Show)

-- ** MaxPrice
newtype MaxPrice = MaxPrice { unMaxPrice :: Double } deriving (P.Eq, P.Show)

-- ** MaxProtein
newtype MaxProtein = MaxProtein { unMaxProtein :: Double } deriving (P.Eq, P.Show)

-- ** MaxProteinPercent
newtype MaxProteinPercent = MaxProteinPercent { unMaxProteinPercent :: Double } deriving (P.Eq, P.Show)

-- ** MaxReadyTime
newtype MaxReadyTime = MaxReadyTime { unMaxReadyTime :: Double } deriving (P.Eq, P.Show)

-- ** MaxSaturatedFat
newtype MaxSaturatedFat = MaxSaturatedFat { unMaxSaturatedFat :: Double } deriving (P.Eq, P.Show)

-- ** MaxSelenium
newtype MaxSelenium = MaxSelenium { unMaxSelenium :: Double } deriving (P.Eq, P.Show)

-- ** MaxSodium
newtype MaxSodium = MaxSodium { unMaxSodium :: Double } deriving (P.Eq, P.Show)

-- ** MaxSugar
newtype MaxSugar = MaxSugar { unMaxSugar :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminA
newtype MaxVitaminA = MaxVitaminA { unMaxVitaminA :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB1
newtype MaxVitaminB1 = MaxVitaminB1 { unMaxVitaminB1 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB12
newtype MaxVitaminB12 = MaxVitaminB12 { unMaxVitaminB12 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB2
newtype MaxVitaminB2 = MaxVitaminB2 { unMaxVitaminB2 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB3
newtype MaxVitaminB3 = MaxVitaminB3 { unMaxVitaminB3 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB5
newtype MaxVitaminB5 = MaxVitaminB5 { unMaxVitaminB5 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminB6
newtype MaxVitaminB6 = MaxVitaminB6 { unMaxVitaminB6 :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminC
newtype MaxVitaminC = MaxVitaminC { unMaxVitaminC :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminD
newtype MaxVitaminD = MaxVitaminD { unMaxVitaminD :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminE
newtype MaxVitaminE = MaxVitaminE { unMaxVitaminE :: Double } deriving (P.Eq, P.Show)

-- ** MaxVitaminK
newtype MaxVitaminK = MaxVitaminK { unMaxVitaminK :: Double } deriving (P.Eq, P.Show)

-- ** MaxZinc
newtype MaxZinc = MaxZinc { unMaxZinc :: Double } deriving (P.Eq, P.Show)

-- ** Measure
newtype Measure = Measure { unMeasure :: E'Measure } deriving (P.Eq, P.Show)

-- ** MetaInformation
newtype MetaInformation = MetaInformation { unMetaInformation :: Bool } deriving (P.Eq, P.Show)

-- ** MinAlcohol
newtype MinAlcohol = MinAlcohol { unMinAlcohol :: Double } deriving (P.Eq, P.Show)

-- ** MinCaffeine
newtype MinCaffeine = MinCaffeine { unMinCaffeine :: Double } deriving (P.Eq, P.Show)

-- ** MinCalcium
newtype MinCalcium = MinCalcium { unMinCalcium :: Double } deriving (P.Eq, P.Show)

-- ** MinCalories
newtype MinCalories = MinCalories { unMinCalories :: Double } deriving (P.Eq, P.Show)

-- ** MinCarbs
newtype MinCarbs = MinCarbs { unMinCarbs :: Double } deriving (P.Eq, P.Show)

-- ** MinCarbsPercent
newtype MinCarbsPercent = MinCarbsPercent { unMinCarbsPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinCholesterol
newtype MinCholesterol = MinCholesterol { unMinCholesterol :: Double } deriving (P.Eq, P.Show)

-- ** MinCholine
newtype MinCholine = MinCholine { unMinCholine :: Double } deriving (P.Eq, P.Show)

-- ** MinCopper
newtype MinCopper = MinCopper { unMinCopper :: Double } deriving (P.Eq, P.Show)

-- ** MinFat
newtype MinFat = MinFat { unMinFat :: Double } deriving (P.Eq, P.Show)

-- ** MinFatPercent
newtype MinFatPercent = MinFatPercent { unMinFatPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinFiber
newtype MinFiber = MinFiber { unMinFiber :: Double } deriving (P.Eq, P.Show)

-- ** MinFluoride
newtype MinFluoride = MinFluoride { unMinFluoride :: Double } deriving (P.Eq, P.Show)

-- ** MinFolate
newtype MinFolate = MinFolate { unMinFolate :: Double } deriving (P.Eq, P.Show)

-- ** MinFolicAcid
newtype MinFolicAcid = MinFolicAcid { unMinFolicAcid :: Double } deriving (P.Eq, P.Show)

-- ** MinIodine
newtype MinIodine = MinIodine { unMinIodine :: Double } deriving (P.Eq, P.Show)

-- ** MinIron
newtype MinIron = MinIron { unMinIron :: Double } deriving (P.Eq, P.Show)

-- ** MinLength
newtype MinLength = MinLength { unMinLength :: Double } deriving (P.Eq, P.Show)

-- ** MinMagnesium
newtype MinMagnesium = MinMagnesium { unMinMagnesium :: Double } deriving (P.Eq, P.Show)

-- ** MinManganese
newtype MinManganese = MinManganese { unMinManganese :: Double } deriving (P.Eq, P.Show)

-- ** MinPhosphorus
newtype MinPhosphorus = MinPhosphorus { unMinPhosphorus :: Double } deriving (P.Eq, P.Show)

-- ** MinPotassium
newtype MinPotassium = MinPotassium { unMinPotassium :: Double } deriving (P.Eq, P.Show)

-- ** MinProtein
newtype MinProtein = MinProtein { unMinProtein :: Double } deriving (P.Eq, P.Show)

-- ** MinProteinPercent
newtype MinProteinPercent = MinProteinPercent { unMinProteinPercent :: Double } deriving (P.Eq, P.Show)

-- ** MinRating
newtype MinRating = MinRating { unMinRating :: Double } deriving (P.Eq, P.Show)

-- ** MinSaturatedFat
newtype MinSaturatedFat = MinSaturatedFat { unMinSaturatedFat :: Double } deriving (P.Eq, P.Show)

-- ** MinSelenium
newtype MinSelenium = MinSelenium { unMinSelenium :: Double } deriving (P.Eq, P.Show)

-- ** MinSodium
newtype MinSodium = MinSodium { unMinSodium :: Double } deriving (P.Eq, P.Show)

-- ** MinSugar
newtype MinSugar = MinSugar { unMinSugar :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminA
newtype MinVitaminA = MinVitaminA { unMinVitaminA :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB1
newtype MinVitaminB1 = MinVitaminB1 { unMinVitaminB1 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB12
newtype MinVitaminB12 = MinVitaminB12 { unMinVitaminB12 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB2
newtype MinVitaminB2 = MinVitaminB2 { unMinVitaminB2 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB3
newtype MinVitaminB3 = MinVitaminB3 { unMinVitaminB3 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB5
newtype MinVitaminB5 = MinVitaminB5 { unMinVitaminB5 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminB6
newtype MinVitaminB6 = MinVitaminB6 { unMinVitaminB6 :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminC
newtype MinVitaminC = MinVitaminC { unMinVitaminC :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminD
newtype MinVitaminD = MinVitaminD { unMinVitaminD :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminE
newtype MinVitaminE = MinVitaminE { unMinVitaminE :: Double } deriving (P.Eq, P.Show)

-- ** MinVitaminK
newtype MinVitaminK = MinVitaminK { unMinVitaminK :: Double } deriving (P.Eq, P.Show)

-- ** MinZinc
newtype MinZinc = MinZinc { unMinZinc :: Double } deriving (P.Eq, P.Show)

-- ** Normalize
newtype Normalize = Normalize { unNormalize :: E'Normalize } deriving (P.Eq, P.Show)

-- ** Normalize2
newtype Normalize2 = Normalize2 { unNormalize2 :: E'Normalize2 } deriving (P.Eq, P.Show)

-- ** NormalizeBool
newtype NormalizeBool = NormalizeBool { unNormalizeBool :: Bool } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** NumberDouble
newtype NumberDouble = NumberDouble { unNumberDouble :: Double } deriving (P.Eq, P.Show)

-- ** Nutrient
newtype Nutrient = Nutrient { unNutrient :: Text } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** ParamAccept
newtype ParamAccept = ParamAccept { unParamAccept :: E'Accept } deriving (P.Eq, P.Show)

-- ** ParamContentType
newtype ParamContentType = ParamContentType { unParamContentType :: E'ContentType } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Text } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: Text } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Text } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** Random
newtype Random = Random { unRandom :: Bool } deriving (P.Eq, P.Show)

-- ** Ranking
newtype Ranking = Ranking { unRanking :: Double } deriving (P.Eq, P.Show)

-- ** RecipeBoxId
newtype RecipeBoxId = RecipeBoxId { unRecipeBoxId :: Double } deriving (P.Eq, P.Show)

-- ** Rgb
newtype Rgb = Rgb { unRgb :: Text } deriving (P.Eq, P.Show)

-- ** ShowIngredients
newtype ShowIngredients = ShowIngredients { unShowIngredients :: Bool } deriving (P.Eq, P.Show)

-- ** ShowOptionalNutrients
newtype ShowOptionalNutrients = ShowOptionalNutrients { unShowOptionalNutrients :: Bool } deriving (P.Eq, P.Show)

-- ** ShowZeroValues
newtype ShowZeroValues = ShowZeroValues { unShowZeroValues :: Bool } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: Text } deriving (P.Eq, P.Show)

-- ** SourceAmount
newtype SourceAmount = SourceAmount { unSourceAmount :: Double } deriving (P.Eq, P.Show)

-- ** SourceUnit
newtype SourceUnit = SourceUnit { unSourceUnit :: Text } deriving (P.Eq, P.Show)

-- ** StartDate
newtype StartDate = StartDate { unStartDate :: Text } deriving (P.Eq, P.Show)

-- ** StepBreakdown
newtype StepBreakdown = StepBreakdown { unStepBreakdown :: Bool } deriving (P.Eq, P.Show)

-- ** Tags
newtype Tags = Tags { unTags :: Text } deriving (P.Eq, P.Show)

-- ** Target
newtype Target = Target { unTarget :: Double } deriving (P.Eq, P.Show)

-- ** TargetCalories
newtype TargetCalories = TargetCalories { unTargetCalories :: Double } deriving (P.Eq, P.Show)

-- ** TargetUnit
newtype TargetUnit = TargetUnit { unTargetUnit :: Text } deriving (P.Eq, P.Show)

-- ** TimeFrame
newtype TimeFrame = TimeFrame { unTimeFrame :: Text } deriving (P.Eq, P.Show)

-- ** Title
newtype Title = Title { unTitle :: Text } deriving (P.Eq, P.Show)

-- ** TitleMatch
newtype TitleMatch = TitleMatch { unTitleMatch :: Text } deriving (P.Eq, P.Show)

-- ** Unit
newtype Unit = Unit { unUnit :: Text } deriving (P.Eq, P.Show)

-- ** Upc
newtype Upc = Upc { unUpc :: Double } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- ** Username
newtype Username = Username { unUsername :: Text } deriving (P.Eq, P.Show)

-- ** Wine
newtype Wine = Wine { unWine :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** FoodIngredientsMapProducts
-- | FoodIngredientsMapProducts
data FoodIngredientsMapProducts = FoodIngredientsMapProducts
  { foodIngredientsMapProductsId :: !(Int) -- ^ /Required/ "id"
  , foodIngredientsMapProductsTitle :: !(Text) -- ^ /Required/ "title"
  , foodIngredientsMapProductsUpc :: !(Text) -- ^ /Required/ "upc"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FoodIngredientsMapProducts
instance A.FromJSON FoodIngredientsMapProducts where
  parseJSON = A.withObject "FoodIngredientsMapProducts" $ \o ->
    FoodIngredientsMapProducts
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "upc")

-- | ToJSON FoodIngredientsMapProducts
instance A.ToJSON FoodIngredientsMapProducts where
  toJSON FoodIngredientsMapProducts {..} =
   _omitNulls
      [ "id" .= foodIngredientsMapProductsId
      , "title" .= foodIngredientsMapProductsTitle
      , "upc" .= foodIngredientsMapProductsUpc
      ]


-- | Construct a value of type 'FoodIngredientsMapProducts' (by applying it's required fields, if any)
mkFoodIngredientsMapProducts
  :: Int -- ^ 'foodIngredientsMapProductsId' 
  -> Text -- ^ 'foodIngredientsMapProductsTitle' 
  -> Text -- ^ 'foodIngredientsMapProductsUpc' 
  -> FoodIngredientsMapProducts
mkFoodIngredientsMapProducts foodIngredientsMapProductsId foodIngredientsMapProductsTitle foodIngredientsMapProductsUpc =
  FoodIngredientsMapProducts
  { foodIngredientsMapProductsId
  , foodIngredientsMapProductsTitle
  , foodIngredientsMapProductsUpc
  }

-- ** InlineObject
-- | InlineObject
data InlineObject = InlineObject
  { inlineObjectTitle :: !(Text) -- ^ /Required/ "title"
  , inlineObjectUpc :: !(Text) -- ^ /Required/ "upc"
  , inlineObjectPluCode :: !(Text) -- ^ /Required/ "plu_code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject
instance A.FromJSON InlineObject where
  parseJSON = A.withObject "InlineObject" $ \o ->
    InlineObject
      <$> (o .:  "title")
      <*> (o .:  "upc")
      <*> (o .:  "plu_code")

-- | ToJSON InlineObject
instance A.ToJSON InlineObject where
  toJSON InlineObject {..} =
   _omitNulls
      [ "title" .= inlineObjectTitle
      , "upc" .= inlineObjectUpc
      , "plu_code" .= inlineObjectPluCode
      ]


-- | Construct a value of type 'InlineObject' (by applying it's required fields, if any)
mkInlineObject
  :: Text -- ^ 'inlineObjectTitle' 
  -> Text -- ^ 'inlineObjectUpc' 
  -> Text -- ^ 'inlineObjectPluCode' 
  -> InlineObject
mkInlineObject inlineObjectTitle inlineObjectUpc inlineObjectPluCode =
  InlineObject
  { inlineObjectTitle
  , inlineObjectUpc
  , inlineObjectPluCode
  }

-- ** InlineObject1
-- | InlineObject1
data InlineObject1 = InlineObject1
  { inlineObject1Title :: !(Text) -- ^ /Required/ "title"
  , inlineObject1Upc :: !(Text) -- ^ /Required/ "upc"
  , inlineObject1PluCode :: !(Text) -- ^ /Required/ "plu_code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject1
instance A.FromJSON InlineObject1 where
  parseJSON = A.withObject "InlineObject1" $ \o ->
    InlineObject1
      <$> (o .:  "title")
      <*> (o .:  "upc")
      <*> (o .:  "plu_code")

-- | ToJSON InlineObject1
instance A.ToJSON InlineObject1 where
  toJSON InlineObject1 {..} =
   _omitNulls
      [ "title" .= inlineObject1Title
      , "upc" .= inlineObject1Upc
      , "plu_code" .= inlineObject1PluCode
      ]


-- | Construct a value of type 'InlineObject1' (by applying it's required fields, if any)
mkInlineObject1
  :: Text -- ^ 'inlineObject1Title' 
  -> Text -- ^ 'inlineObject1Upc' 
  -> Text -- ^ 'inlineObject1PluCode' 
  -> InlineObject1
mkInlineObject1 inlineObject1Title inlineObject1Upc inlineObject1PluCode =
  InlineObject1
  { inlineObject1Title
  , inlineObject1Upc
  , inlineObject1PluCode
  }

-- ** InlineObject2
-- | InlineObject2
data InlineObject2 = InlineObject2
  { inlineObject2Ingredients :: !([Text]) -- ^ /Required/ "ingredients"
  , inlineObject2Servings :: !(Double) -- ^ /Required/ "servings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject2
instance A.FromJSON InlineObject2 where
  parseJSON = A.withObject "InlineObject2" $ \o ->
    InlineObject2
      <$> (o .:  "ingredients")
      <*> (o .:  "servings")

-- | ToJSON InlineObject2
instance A.ToJSON InlineObject2 where
  toJSON InlineObject2 {..} =
   _omitNulls
      [ "ingredients" .= inlineObject2Ingredients
      , "servings" .= inlineObject2Servings
      ]


-- | Construct a value of type 'InlineObject2' (by applying it's required fields, if any)
mkInlineObject2
  :: [Text] -- ^ 'inlineObject2Ingredients' 
  -> Double -- ^ 'inlineObject2Servings' 
  -> InlineObject2
mkInlineObject2 inlineObject2Ingredients inlineObject2Servings =
  InlineObject2
  { inlineObject2Ingredients
  , inlineObject2Servings
  }

-- ** InlineObject3
-- | InlineObject3
data InlineObject3 = InlineObject3
  { inlineObject3Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject3Date :: !(Text) -- ^ /Required/ "date" - The date in the format yyyy-mm-dd.
  , inlineObject3Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject3
instance A.FromJSON InlineObject3 where
  parseJSON = A.withObject "InlineObject3" $ \o ->
    InlineObject3
      <$> (o .:  "username")
      <*> (o .:  "date")
      <*> (o .:  "hash")

-- | ToJSON InlineObject3
instance A.ToJSON InlineObject3 where
  toJSON InlineObject3 {..} =
   _omitNulls
      [ "username" .= inlineObject3Username
      , "date" .= inlineObject3Date
      , "hash" .= inlineObject3Hash
      ]


-- | Construct a value of type 'InlineObject3' (by applying it's required fields, if any)
mkInlineObject3
  :: Text -- ^ 'inlineObject3Username': The username.
  -> Text -- ^ 'inlineObject3Date': The date in the format yyyy-mm-dd.
  -> Text -- ^ 'inlineObject3Hash': The private hash for the username.
  -> InlineObject3
mkInlineObject3 inlineObject3Username inlineObject3Date inlineObject3Hash =
  InlineObject3
  { inlineObject3Username
  , inlineObject3Date
  , inlineObject3Hash
  }

-- ** InlineObject4
-- | InlineObject4
data InlineObject4 = InlineObject4
  { inlineObject4Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject4Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject4
instance A.FromJSON InlineObject4 where
  parseJSON = A.withObject "InlineObject4" $ \o ->
    InlineObject4
      <$> (o .:  "username")
      <*> (o .:  "hash")

-- | ToJSON InlineObject4
instance A.ToJSON InlineObject4 where
  toJSON InlineObject4 {..} =
   _omitNulls
      [ "username" .= inlineObject4Username
      , "hash" .= inlineObject4Hash
      ]


-- | Construct a value of type 'InlineObject4' (by applying it's required fields, if any)
mkInlineObject4
  :: Text -- ^ 'inlineObject4Username': The username.
  -> Text -- ^ 'inlineObject4Hash': The private hash for the username.
  -> InlineObject4
mkInlineObject4 inlineObject4Username inlineObject4Hash =
  InlineObject4
  { inlineObject4Username
  , inlineObject4Hash
  }

-- ** InlineObject5
-- | InlineObject5
data InlineObject5 = InlineObject5
  { inlineObject5Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject5Id :: !(Double) -- ^ /Required/ "id" - The shopping list item id.
  , inlineObject5Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject5
instance A.FromJSON InlineObject5 where
  parseJSON = A.withObject "InlineObject5" $ \o ->
    InlineObject5
      <$> (o .:  "username")
      <*> (o .:  "id")
      <*> (o .:  "hash")

-- | ToJSON InlineObject5
instance A.ToJSON InlineObject5 where
  toJSON InlineObject5 {..} =
   _omitNulls
      [ "username" .= inlineObject5Username
      , "id" .= inlineObject5Id
      , "hash" .= inlineObject5Hash
      ]


-- | Construct a value of type 'InlineObject5' (by applying it's required fields, if any)
mkInlineObject5
  :: Text -- ^ 'inlineObject5Username': The username.
  -> Double -- ^ 'inlineObject5Id': The shopping list item id.
  -> Text -- ^ 'inlineObject5Hash': The private hash for the username.
  -> InlineObject5
mkInlineObject5 inlineObject5Username inlineObject5Id inlineObject5Hash =
  InlineObject5
  { inlineObject5Username
  , inlineObject5Id
  , inlineObject5Hash
  }

-- ** InlineObject6
-- | InlineObject6
data InlineObject6 = InlineObject6
  { inlineObject6Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject6StartDate :: !(Text) -- ^ /Required/ "start-date" - The start date in the format yyyy-mm-dd.
  , inlineObject6EndDate :: !(Text) -- ^ /Required/ "end-date" - The end date in the format yyyy-mm-dd.
  , inlineObject6Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject6
instance A.FromJSON InlineObject6 where
  parseJSON = A.withObject "InlineObject6" $ \o ->
    InlineObject6
      <$> (o .:  "username")
      <*> (o .:  "start-date")
      <*> (o .:  "end-date")
      <*> (o .:  "hash")

-- | ToJSON InlineObject6
instance A.ToJSON InlineObject6 where
  toJSON InlineObject6 {..} =
   _omitNulls
      [ "username" .= inlineObject6Username
      , "start-date" .= inlineObject6StartDate
      , "end-date" .= inlineObject6EndDate
      , "hash" .= inlineObject6Hash
      ]


-- | Construct a value of type 'InlineObject6' (by applying it's required fields, if any)
mkInlineObject6
  :: Text -- ^ 'inlineObject6Username': The username.
  -> Text -- ^ 'inlineObject6StartDate': The start date in the format yyyy-mm-dd.
  -> Text -- ^ 'inlineObject6EndDate': The end date in the format yyyy-mm-dd.
  -> Text -- ^ 'inlineObject6Hash': The private hash for the username.
  -> InlineObject6
mkInlineObject6 inlineObject6Username inlineObject6StartDate inlineObject6EndDate inlineObject6Hash =
  InlineObject6
  { inlineObject6Username
  , inlineObject6StartDate
  , inlineObject6EndDate
  , inlineObject6Hash
  }

-- ** InlineObject7
-- | InlineObject7
data InlineObject7 = InlineObject7
  { inlineObject7Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject7Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject7
instance A.FromJSON InlineObject7 where
  parseJSON = A.withObject "InlineObject7" $ \o ->
    InlineObject7
      <$> (o .:  "username")
      <*> (o .:  "hash")

-- | ToJSON InlineObject7
instance A.ToJSON InlineObject7 where
  toJSON InlineObject7 {..} =
   _omitNulls
      [ "username" .= inlineObject7Username
      , "hash" .= inlineObject7Hash
      ]


-- | Construct a value of type 'InlineObject7' (by applying it's required fields, if any)
mkInlineObject7
  :: Text -- ^ 'inlineObject7Username': The username.
  -> Text -- ^ 'inlineObject7Hash': The private hash for the username.
  -> InlineObject7
mkInlineObject7 inlineObject7Username inlineObject7Hash =
  InlineObject7
  { inlineObject7Username
  , inlineObject7Hash
  }

-- ** InlineObject8
-- | InlineObject8
data InlineObject8 = InlineObject8
  { inlineObject8Username :: !(Text) -- ^ /Required/ "username" - The username.
  , inlineObject8Id :: !(Double) -- ^ /Required/ "id" - The shopping list item id.
  , inlineObject8Hash :: !(Text) -- ^ /Required/ "hash" - The private hash for the username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject8
instance A.FromJSON InlineObject8 where
  parseJSON = A.withObject "InlineObject8" $ \o ->
    InlineObject8
      <$> (o .:  "username")
      <*> (o .:  "id")
      <*> (o .:  "hash")

-- | ToJSON InlineObject8
instance A.ToJSON InlineObject8 where
  toJSON InlineObject8 {..} =
   _omitNulls
      [ "username" .= inlineObject8Username
      , "id" .= inlineObject8Id
      , "hash" .= inlineObject8Hash
      ]


-- | Construct a value of type 'InlineObject8' (by applying it's required fields, if any)
mkInlineObject8
  :: Text -- ^ 'inlineObject8Username': The username.
  -> Double -- ^ 'inlineObject8Id': The shopping list item id.
  -> Text -- ^ 'inlineObject8Hash': The private hash for the username.
  -> InlineObject8
mkInlineObject8 inlineObject8Username inlineObject8Id inlineObject8Hash =
  InlineObject8
  { inlineObject8Username
  , inlineObject8Id
  , inlineObject8Hash
  }

-- ** InlineResponse200
-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { inlineResponse200Offset :: !(Int) -- ^ /Required/ "offset"
  , inlineResponse200Number :: !(Int) -- ^ /Required/ "number"
  , inlineResponse200Results :: !([InlineResponse200Results]) -- ^ /Required/ "results"
  , inlineResponse200TotalResults :: !(Int) -- ^ /Required/ "totalResults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:  "offset")
      <*> (o .:  "number")
      <*> (o .:  "results")
      <*> (o .:  "totalResults")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "offset" .= inlineResponse200Offset
      , "number" .= inlineResponse200Number
      , "results" .= inlineResponse200Results
      , "totalResults" .= inlineResponse200TotalResults
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: Int -- ^ 'inlineResponse200Offset' 
  -> Int -- ^ 'inlineResponse200Number' 
  -> [InlineResponse200Results] -- ^ 'inlineResponse200Results' 
  -> Int -- ^ 'inlineResponse200TotalResults' 
  -> InlineResponse200
mkInlineResponse200 inlineResponse200Offset inlineResponse200Number inlineResponse200Results inlineResponse200TotalResults =
  InlineResponse200
  { inlineResponse200Offset
  , inlineResponse200Number
  , inlineResponse200Results
  , inlineResponse200TotalResults
  }

-- ** InlineResponse2001
-- | InlineResponse2001
data InlineResponse2001 = InlineResponse2001
  { inlineResponse2001Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2001Image :: !(Text) -- ^ /Required/ "image"
  , inlineResponse2001ImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse2001Likes :: !(Int) -- ^ /Required/ "likes"
  , inlineResponse2001MissedIngredientCount :: !(Int) -- ^ /Required/ "missedIngredientCount"
  , inlineResponse2001MissedIngredients :: !([RecipesFindByIngredientsMissedIngredients]) -- ^ /Required/ "missedIngredients"
  , inlineResponse2001Title :: !(Text) -- ^ /Required/ "title"
  , inlineResponse2001UnusedIngredients :: !([A.Value]) -- ^ /Required/ "unusedIngredients"
  , inlineResponse2001UsedIngredientCount :: !(Double) -- ^ /Required/ "usedIngredientCount"
  , inlineResponse2001UsedIngredients :: !([RecipesFindByIngredientsMissedIngredients]) -- ^ /Required/ "usedIngredients"
  , inlineResponse2001 :: !(Maybe Text) -- ^ ""
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2001
instance A.FromJSON InlineResponse2001 where
  parseJSON = A.withObject "InlineResponse2001" $ \o ->
    InlineResponse2001
      <$> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "likes")
      <*> (o .:  "missedIngredientCount")
      <*> (o .:  "missedIngredients")
      <*> (o .:  "title")
      <*> (o .:  "unusedIngredients")
      <*> (o .:  "usedIngredientCount")
      <*> (o .:  "usedIngredients")
      <*> (o .:? "")

-- | ToJSON InlineResponse2001
instance A.ToJSON InlineResponse2001 where
  toJSON InlineResponse2001 {..} =
   _omitNulls
      [ "id" .= inlineResponse2001Id
      , "image" .= inlineResponse2001Image
      , "imageType" .= inlineResponse2001ImageType
      , "likes" .= inlineResponse2001Likes
      , "missedIngredientCount" .= inlineResponse2001MissedIngredientCount
      , "missedIngredients" .= inlineResponse2001MissedIngredients
      , "title" .= inlineResponse2001Title
      , "unusedIngredients" .= inlineResponse2001UnusedIngredients
      , "usedIngredientCount" .= inlineResponse2001UsedIngredientCount
      , "usedIngredients" .= inlineResponse2001UsedIngredients
      , "" .= inlineResponse2001
      ]


-- | Construct a value of type 'InlineResponse2001' (by applying it's required fields, if any)
mkInlineResponse2001
  :: Int -- ^ 'inlineResponse2001Id' 
  -> Text -- ^ 'inlineResponse2001Image' 
  -> Text -- ^ 'inlineResponse2001ImageType' 
  -> Int -- ^ 'inlineResponse2001Likes' 
  -> Int -- ^ 'inlineResponse2001MissedIngredientCount' 
  -> [RecipesFindByIngredientsMissedIngredients] -- ^ 'inlineResponse2001MissedIngredients' 
  -> Text -- ^ 'inlineResponse2001Title' 
  -> [A.Value] -- ^ 'inlineResponse2001UnusedIngredients' 
  -> Double -- ^ 'inlineResponse2001UsedIngredientCount' 
  -> [RecipesFindByIngredientsMissedIngredients] -- ^ 'inlineResponse2001UsedIngredients' 
  -> InlineResponse2001
mkInlineResponse2001 inlineResponse2001Id inlineResponse2001Image inlineResponse2001ImageType inlineResponse2001Likes inlineResponse2001MissedIngredientCount inlineResponse2001MissedIngredients inlineResponse2001Title inlineResponse2001UnusedIngredients inlineResponse2001UsedIngredientCount inlineResponse2001UsedIngredients =
  InlineResponse2001
  { inlineResponse2001Id
  , inlineResponse2001Image
  , inlineResponse2001ImageType
  , inlineResponse2001Likes
  , inlineResponse2001MissedIngredientCount
  , inlineResponse2001MissedIngredients
  , inlineResponse2001Title
  , inlineResponse2001UnusedIngredients
  , inlineResponse2001UsedIngredientCount
  , inlineResponse2001UsedIngredients
  , inlineResponse2001 = Nothing
  }

-- ** InlineResponse20010
-- | InlineResponse20010
data InlineResponse20010 = InlineResponse20010
  { inlineResponse20010Ingredients :: !([InlineResponse20010Ingredients]) -- ^ /Required/ "ingredients"
  , inlineResponse20010TotalCost :: !(Double) -- ^ /Required/ "totalCost"
  , inlineResponse20010TotalCostPerServing :: !(Double) -- ^ /Required/ "totalCostPerServing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010
instance A.FromJSON InlineResponse20010 where
  parseJSON = A.withObject "InlineResponse20010" $ \o ->
    InlineResponse20010
      <$> (o .:  "ingredients")
      <*> (o .:  "totalCost")
      <*> (o .:  "totalCostPerServing")

-- | ToJSON InlineResponse20010
instance A.ToJSON InlineResponse20010 where
  toJSON InlineResponse20010 {..} =
   _omitNulls
      [ "ingredients" .= inlineResponse20010Ingredients
      , "totalCost" .= inlineResponse20010TotalCost
      , "totalCostPerServing" .= inlineResponse20010TotalCostPerServing
      ]


-- | Construct a value of type 'InlineResponse20010' (by applying it's required fields, if any)
mkInlineResponse20010
  :: [InlineResponse20010Ingredients] -- ^ 'inlineResponse20010Ingredients' 
  -> Double -- ^ 'inlineResponse20010TotalCost' 
  -> Double -- ^ 'inlineResponse20010TotalCostPerServing' 
  -> InlineResponse20010
mkInlineResponse20010 inlineResponse20010Ingredients inlineResponse20010TotalCost inlineResponse20010TotalCostPerServing =
  InlineResponse20010
  { inlineResponse20010Ingredients
  , inlineResponse20010TotalCost
  , inlineResponse20010TotalCostPerServing
  }

-- ** InlineResponse20010Amount
-- | InlineResponse20010Amount
data InlineResponse20010Amount = InlineResponse20010Amount
  { inlineResponse20010AmountMetric :: !(InlineResponse20010AmountMetric) -- ^ /Required/ "metric"
  , inlineResponse20010AmountUs :: !(InlineResponse20010AmountMetric) -- ^ /Required/ "us"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010Amount
instance A.FromJSON InlineResponse20010Amount where
  parseJSON = A.withObject "InlineResponse20010Amount" $ \o ->
    InlineResponse20010Amount
      <$> (o .:  "metric")
      <*> (o .:  "us")

-- | ToJSON InlineResponse20010Amount
instance A.ToJSON InlineResponse20010Amount where
  toJSON InlineResponse20010Amount {..} =
   _omitNulls
      [ "metric" .= inlineResponse20010AmountMetric
      , "us" .= inlineResponse20010AmountUs
      ]


-- | Construct a value of type 'InlineResponse20010Amount' (by applying it's required fields, if any)
mkInlineResponse20010Amount
  :: InlineResponse20010AmountMetric -- ^ 'inlineResponse20010AmountMetric' 
  -> InlineResponse20010AmountMetric -- ^ 'inlineResponse20010AmountUs' 
  -> InlineResponse20010Amount
mkInlineResponse20010Amount inlineResponse20010AmountMetric inlineResponse20010AmountUs =
  InlineResponse20010Amount
  { inlineResponse20010AmountMetric
  , inlineResponse20010AmountUs
  }

-- ** InlineResponse20010AmountMetric
-- | InlineResponse20010AmountMetric
data InlineResponse20010AmountMetric = InlineResponse20010AmountMetric
  { inlineResponse20010AmountMetricUnit :: !(Text) -- ^ /Required/ "unit"
  , inlineResponse20010AmountMetricValue :: !(Double) -- ^ /Required/ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010AmountMetric
instance A.FromJSON InlineResponse20010AmountMetric where
  parseJSON = A.withObject "InlineResponse20010AmountMetric" $ \o ->
    InlineResponse20010AmountMetric
      <$> (o .:  "unit")
      <*> (o .:  "value")

-- | ToJSON InlineResponse20010AmountMetric
instance A.ToJSON InlineResponse20010AmountMetric where
  toJSON InlineResponse20010AmountMetric {..} =
   _omitNulls
      [ "unit" .= inlineResponse20010AmountMetricUnit
      , "value" .= inlineResponse20010AmountMetricValue
      ]


-- | Construct a value of type 'InlineResponse20010AmountMetric' (by applying it's required fields, if any)
mkInlineResponse20010AmountMetric
  :: Text -- ^ 'inlineResponse20010AmountMetricUnit' 
  -> Double -- ^ 'inlineResponse20010AmountMetricValue' 
  -> InlineResponse20010AmountMetric
mkInlineResponse20010AmountMetric inlineResponse20010AmountMetricUnit inlineResponse20010AmountMetricValue =
  InlineResponse20010AmountMetric
  { inlineResponse20010AmountMetricUnit
  , inlineResponse20010AmountMetricValue
  }

-- ** InlineResponse20010Ingredients
-- | InlineResponse20010Ingredients
data InlineResponse20010Ingredients = InlineResponse20010Ingredients
  { inlineResponse20010IngredientsAmount :: !(Maybe InlineResponse20010Amount) -- ^ "amount"
  , inlineResponse20010IngredientsImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20010IngredientsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20010IngredientsPrice :: !(Double) -- ^ /Required/ "price"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20010Ingredients
instance A.FromJSON InlineResponse20010Ingredients where
  parseJSON = A.withObject "InlineResponse20010Ingredients" $ \o ->
    InlineResponse20010Ingredients
      <$> (o .:? "amount")
      <*> (o .:  "image")
      <*> (o .:  "name")
      <*> (o .:  "price")

-- | ToJSON InlineResponse20010Ingredients
instance A.ToJSON InlineResponse20010Ingredients where
  toJSON InlineResponse20010Ingredients {..} =
   _omitNulls
      [ "amount" .= inlineResponse20010IngredientsAmount
      , "image" .= inlineResponse20010IngredientsImage
      , "name" .= inlineResponse20010IngredientsName
      , "price" .= inlineResponse20010IngredientsPrice
      ]


-- | Construct a value of type 'InlineResponse20010Ingredients' (by applying it's required fields, if any)
mkInlineResponse20010Ingredients
  :: Text -- ^ 'inlineResponse20010IngredientsImage' 
  -> Text -- ^ 'inlineResponse20010IngredientsName' 
  -> Double -- ^ 'inlineResponse20010IngredientsPrice' 
  -> InlineResponse20010Ingredients
mkInlineResponse20010Ingredients inlineResponse20010IngredientsImage inlineResponse20010IngredientsName inlineResponse20010IngredientsPrice =
  InlineResponse20010Ingredients
  { inlineResponse20010IngredientsAmount = Nothing
  , inlineResponse20010IngredientsImage
  , inlineResponse20010IngredientsName
  , inlineResponse20010IngredientsPrice
  }

-- ** InlineResponse20011
-- | InlineResponse20011
data InlineResponse20011 = InlineResponse20011
  { inlineResponse20011Ingredients :: !([InlineResponse20011Ingredients]) -- ^ /Required/ "ingredients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20011
instance A.FromJSON InlineResponse20011 where
  parseJSON = A.withObject "InlineResponse20011" $ \o ->
    InlineResponse20011
      <$> (o .:  "ingredients")

-- | ToJSON InlineResponse20011
instance A.ToJSON InlineResponse20011 where
  toJSON InlineResponse20011 {..} =
   _omitNulls
      [ "ingredients" .= inlineResponse20011Ingredients
      ]


-- | Construct a value of type 'InlineResponse20011' (by applying it's required fields, if any)
mkInlineResponse20011
  :: [InlineResponse20011Ingredients] -- ^ 'inlineResponse20011Ingredients' 
  -> InlineResponse20011
mkInlineResponse20011 inlineResponse20011Ingredients =
  InlineResponse20011
  { inlineResponse20011Ingredients
  }

-- ** InlineResponse20011Ingredients
-- | InlineResponse20011Ingredients
data InlineResponse20011Ingredients = InlineResponse20011Ingredients
  { inlineResponse20011IngredientsAmount :: !(Maybe InlineResponse20010Amount) -- ^ "amount"
  , inlineResponse20011IngredientsImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20011IngredientsName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20011Ingredients
instance A.FromJSON InlineResponse20011Ingredients where
  parseJSON = A.withObject "InlineResponse20011Ingredients" $ \o ->
    InlineResponse20011Ingredients
      <$> (o .:? "amount")
      <*> (o .:  "image")
      <*> (o .:  "name")

-- | ToJSON InlineResponse20011Ingredients
instance A.ToJSON InlineResponse20011Ingredients where
  toJSON InlineResponse20011Ingredients {..} =
   _omitNulls
      [ "amount" .= inlineResponse20011IngredientsAmount
      , "image" .= inlineResponse20011IngredientsImage
      , "name" .= inlineResponse20011IngredientsName
      ]


-- | Construct a value of type 'InlineResponse20011Ingredients' (by applying it's required fields, if any)
mkInlineResponse20011Ingredients
  :: Text -- ^ 'inlineResponse20011IngredientsImage' 
  -> Text -- ^ 'inlineResponse20011IngredientsName' 
  -> InlineResponse20011Ingredients
mkInlineResponse20011Ingredients inlineResponse20011IngredientsImage inlineResponse20011IngredientsName =
  InlineResponse20011Ingredients
  { inlineResponse20011IngredientsAmount = Nothing
  , inlineResponse20011IngredientsImage
  , inlineResponse20011IngredientsName
  }

-- ** InlineResponse20012
-- | InlineResponse20012
data InlineResponse20012 = InlineResponse20012
  { inlineResponse20012Calories :: !(Text) -- ^ /Required/ "calories"
  , inlineResponse20012Carbs :: !(Text) -- ^ /Required/ "carbs"
  , inlineResponse20012Fat :: !(Text) -- ^ /Required/ "fat"
  , inlineResponse20012Protein :: !(Text) -- ^ /Required/ "protein"
  , inlineResponse20012Bad :: !([A.Value]) -- ^ /Required/ "bad"
  , inlineResponse20012Good :: !([A.Value]) -- ^ /Required/ "good"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20012
instance A.FromJSON InlineResponse20012 where
  parseJSON = A.withObject "InlineResponse20012" $ \o ->
    InlineResponse20012
      <$> (o .:  "calories")
      <*> (o .:  "carbs")
      <*> (o .:  "fat")
      <*> (o .:  "protein")
      <*> (o .:  "bad")
      <*> (o .:  "good")

-- | ToJSON InlineResponse20012
instance A.ToJSON InlineResponse20012 where
  toJSON InlineResponse20012 {..} =
   _omitNulls
      [ "calories" .= inlineResponse20012Calories
      , "carbs" .= inlineResponse20012Carbs
      , "fat" .= inlineResponse20012Fat
      , "protein" .= inlineResponse20012Protein
      , "bad" .= inlineResponse20012Bad
      , "good" .= inlineResponse20012Good
      ]


-- | Construct a value of type 'InlineResponse20012' (by applying it's required fields, if any)
mkInlineResponse20012
  :: Text -- ^ 'inlineResponse20012Calories' 
  -> Text -- ^ 'inlineResponse20012Carbs' 
  -> Text -- ^ 'inlineResponse20012Fat' 
  -> Text -- ^ 'inlineResponse20012Protein' 
  -> [A.Value] -- ^ 'inlineResponse20012Bad' 
  -> [A.Value] -- ^ 'inlineResponse20012Good' 
  -> InlineResponse20012
mkInlineResponse20012 inlineResponse20012Calories inlineResponse20012Carbs inlineResponse20012Fat inlineResponse20012Protein inlineResponse20012Bad inlineResponse20012Good =
  InlineResponse20012
  { inlineResponse20012Calories
  , inlineResponse20012Carbs
  , inlineResponse20012Fat
  , inlineResponse20012Protein
  , inlineResponse20012Bad
  , inlineResponse20012Good
  }

-- ** InlineResponse20013
-- | InlineResponse20013
data InlineResponse20013 = InlineResponse20013
  { inlineResponse20013ParsedInstructions :: !([InlineResponse20013ParsedInstructions]) -- ^ /Required/ "parsedInstructions"
  , inlineResponse20013Ingredients :: !([InlineResponse20013Ingredients1]) -- ^ /Required/ "ingredients"
  , inlineResponse20013Equipment :: !([InlineResponse20013Ingredients1]) -- ^ /Required/ "equipment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20013
instance A.FromJSON InlineResponse20013 where
  parseJSON = A.withObject "InlineResponse20013" $ \o ->
    InlineResponse20013
      <$> (o .:  "parsedInstructions")
      <*> (o .:  "ingredients")
      <*> (o .:  "equipment")

-- | ToJSON InlineResponse20013
instance A.ToJSON InlineResponse20013 where
  toJSON InlineResponse20013 {..} =
   _omitNulls
      [ "parsedInstructions" .= inlineResponse20013ParsedInstructions
      , "ingredients" .= inlineResponse20013Ingredients
      , "equipment" .= inlineResponse20013Equipment
      ]


-- | Construct a value of type 'InlineResponse20013' (by applying it's required fields, if any)
mkInlineResponse20013
  :: [InlineResponse20013ParsedInstructions] -- ^ 'inlineResponse20013ParsedInstructions' 
  -> [InlineResponse20013Ingredients1] -- ^ 'inlineResponse20013Ingredients' 
  -> [InlineResponse20013Ingredients1] -- ^ 'inlineResponse20013Equipment' 
  -> InlineResponse20013
mkInlineResponse20013 inlineResponse20013ParsedInstructions inlineResponse20013Ingredients inlineResponse20013Equipment =
  InlineResponse20013
  { inlineResponse20013ParsedInstructions
  , inlineResponse20013Ingredients
  , inlineResponse20013Equipment
  }

-- ** InlineResponse20013Ingredients
-- | InlineResponse20013Ingredients
data InlineResponse20013Ingredients = InlineResponse20013Ingredients
  { inlineResponse20013IngredientsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20013IngredientsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20013IngredientsLocalizedName :: !(Text) -- ^ /Required/ "localizedName"
  , inlineResponse20013IngredientsImage :: !(Text) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20013Ingredients
instance A.FromJSON InlineResponse20013Ingredients where
  parseJSON = A.withObject "InlineResponse20013Ingredients" $ \o ->
    InlineResponse20013Ingredients
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "localizedName")
      <*> (o .:  "image")

-- | ToJSON InlineResponse20013Ingredients
instance A.ToJSON InlineResponse20013Ingredients where
  toJSON InlineResponse20013Ingredients {..} =
   _omitNulls
      [ "id" .= inlineResponse20013IngredientsId
      , "name" .= inlineResponse20013IngredientsName
      , "localizedName" .= inlineResponse20013IngredientsLocalizedName
      , "image" .= inlineResponse20013IngredientsImage
      ]


-- | Construct a value of type 'InlineResponse20013Ingredients' (by applying it's required fields, if any)
mkInlineResponse20013Ingredients
  :: Int -- ^ 'inlineResponse20013IngredientsId' 
  -> Text -- ^ 'inlineResponse20013IngredientsName' 
  -> Text -- ^ 'inlineResponse20013IngredientsLocalizedName' 
  -> Text -- ^ 'inlineResponse20013IngredientsImage' 
  -> InlineResponse20013Ingredients
mkInlineResponse20013Ingredients inlineResponse20013IngredientsId inlineResponse20013IngredientsName inlineResponse20013IngredientsLocalizedName inlineResponse20013IngredientsImage =
  InlineResponse20013Ingredients
  { inlineResponse20013IngredientsId
  , inlineResponse20013IngredientsName
  , inlineResponse20013IngredientsLocalizedName
  , inlineResponse20013IngredientsImage
  }

-- ** InlineResponse20013Ingredients1
-- | InlineResponse20013Ingredients1
data InlineResponse20013Ingredients1 = InlineResponse20013Ingredients1
  { inlineResponse20013Ingredients1Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20013Ingredients1Name :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20013Ingredients1
instance A.FromJSON InlineResponse20013Ingredients1 where
  parseJSON = A.withObject "InlineResponse20013Ingredients1" $ \o ->
    InlineResponse20013Ingredients1
      <$> (o .:  "id")
      <*> (o .:  "name")

-- | ToJSON InlineResponse20013Ingredients1
instance A.ToJSON InlineResponse20013Ingredients1 where
  toJSON InlineResponse20013Ingredients1 {..} =
   _omitNulls
      [ "id" .= inlineResponse20013Ingredients1Id
      , "name" .= inlineResponse20013Ingredients1Name
      ]


-- | Construct a value of type 'InlineResponse20013Ingredients1' (by applying it's required fields, if any)
mkInlineResponse20013Ingredients1
  :: Int -- ^ 'inlineResponse20013Ingredients1Id' 
  -> Text -- ^ 'inlineResponse20013Ingredients1Name' 
  -> InlineResponse20013Ingredients1
mkInlineResponse20013Ingredients1 inlineResponse20013Ingredients1Id inlineResponse20013Ingredients1Name =
  InlineResponse20013Ingredients1
  { inlineResponse20013Ingredients1Id
  , inlineResponse20013Ingredients1Name
  }

-- ** InlineResponse20013ParsedInstructions
-- | InlineResponse20013ParsedInstructions
data InlineResponse20013ParsedInstructions = InlineResponse20013ParsedInstructions
  { inlineResponse20013ParsedInstructionsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20013ParsedInstructionsSteps :: !(Maybe [InlineResponse20013Steps]) -- ^ "steps"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20013ParsedInstructions
instance A.FromJSON InlineResponse20013ParsedInstructions where
  parseJSON = A.withObject "InlineResponse20013ParsedInstructions" $ \o ->
    InlineResponse20013ParsedInstructions
      <$> (o .:  "name")
      <*> (o .:? "steps")

-- | ToJSON InlineResponse20013ParsedInstructions
instance A.ToJSON InlineResponse20013ParsedInstructions where
  toJSON InlineResponse20013ParsedInstructions {..} =
   _omitNulls
      [ "name" .= inlineResponse20013ParsedInstructionsName
      , "steps" .= inlineResponse20013ParsedInstructionsSteps
      ]


-- | Construct a value of type 'InlineResponse20013ParsedInstructions' (by applying it's required fields, if any)
mkInlineResponse20013ParsedInstructions
  :: Text -- ^ 'inlineResponse20013ParsedInstructionsName' 
  -> InlineResponse20013ParsedInstructions
mkInlineResponse20013ParsedInstructions inlineResponse20013ParsedInstructionsName =
  InlineResponse20013ParsedInstructions
  { inlineResponse20013ParsedInstructionsName
  , inlineResponse20013ParsedInstructionsSteps = Nothing
  }

-- ** InlineResponse20013Steps
-- | InlineResponse20013Steps
data InlineResponse20013Steps = InlineResponse20013Steps
  { inlineResponse20013StepsNumber :: !(Double) -- ^ /Required/ "number"
  , inlineResponse20013StepsStep :: !(Text) -- ^ /Required/ "step"
  , inlineResponse20013StepsIngredients :: !(Maybe [InlineResponse20013Ingredients]) -- ^ "ingredients"
  , inlineResponse20013StepsEquipment :: !(Maybe [InlineResponse20013Ingredients]) -- ^ "equipment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20013Steps
instance A.FromJSON InlineResponse20013Steps where
  parseJSON = A.withObject "InlineResponse20013Steps" $ \o ->
    InlineResponse20013Steps
      <$> (o .:  "number")
      <*> (o .:  "step")
      <*> (o .:? "ingredients")
      <*> (o .:? "equipment")

-- | ToJSON InlineResponse20013Steps
instance A.ToJSON InlineResponse20013Steps where
  toJSON InlineResponse20013Steps {..} =
   _omitNulls
      [ "number" .= inlineResponse20013StepsNumber
      , "step" .= inlineResponse20013StepsStep
      , "ingredients" .= inlineResponse20013StepsIngredients
      , "equipment" .= inlineResponse20013StepsEquipment
      ]


-- | Construct a value of type 'InlineResponse20013Steps' (by applying it's required fields, if any)
mkInlineResponse20013Steps
  :: Double -- ^ 'inlineResponse20013StepsNumber' 
  -> Text -- ^ 'inlineResponse20013StepsStep' 
  -> InlineResponse20013Steps
mkInlineResponse20013Steps inlineResponse20013StepsNumber inlineResponse20013StepsStep =
  InlineResponse20013Steps
  { inlineResponse20013StepsNumber
  , inlineResponse20013StepsStep
  , inlineResponse20013StepsIngredients = Nothing
  , inlineResponse20013StepsEquipment = Nothing
  }

-- ** InlineResponse20014
-- | InlineResponse20014
data InlineResponse20014 = InlineResponse20014
  { inlineResponse20014Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20014Summary :: !(Text) -- ^ /Required/ "summary"
  , inlineResponse20014Title :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20014
instance A.FromJSON InlineResponse20014 where
  parseJSON = A.withObject "InlineResponse20014" $ \o ->
    InlineResponse20014
      <$> (o .:  "id")
      <*> (o .:  "summary")
      <*> (o .:  "title")

-- | ToJSON InlineResponse20014
instance A.ToJSON InlineResponse20014 where
  toJSON InlineResponse20014 {..} =
   _omitNulls
      [ "id" .= inlineResponse20014Id
      , "summary" .= inlineResponse20014Summary
      , "title" .= inlineResponse20014Title
      ]


-- | Construct a value of type 'InlineResponse20014' (by applying it's required fields, if any)
mkInlineResponse20014
  :: Int -- ^ 'inlineResponse20014Id' 
  -> Text -- ^ 'inlineResponse20014Summary' 
  -> Text -- ^ 'inlineResponse20014Title' 
  -> InlineResponse20014
mkInlineResponse20014 inlineResponse20014Id inlineResponse20014Summary inlineResponse20014Title =
  InlineResponse20014
  { inlineResponse20014Id
  , inlineResponse20014Summary
  , inlineResponse20014Title
  }

-- ** InlineResponse20015
-- | InlineResponse20015
data InlineResponse20015 = InlineResponse20015
  { inlineResponse20015Url :: !(Text) -- ^ /Required/ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20015
instance A.FromJSON InlineResponse20015 where
  parseJSON = A.withObject "InlineResponse20015" $ \o ->
    InlineResponse20015
      <$> (o .:  "url")

-- | ToJSON InlineResponse20015
instance A.ToJSON InlineResponse20015 where
  toJSON InlineResponse20015 {..} =
   _omitNulls
      [ "url" .= inlineResponse20015Url
      ]


-- | Construct a value of type 'InlineResponse20015' (by applying it's required fields, if any)
mkInlineResponse20015
  :: Text -- ^ 'inlineResponse20015Url' 
  -> InlineResponse20015
mkInlineResponse20015 inlineResponse20015Url =
  InlineResponse20015
  { inlineResponse20015Url
  }

-- ** InlineResponse20016
-- | InlineResponse20016
data InlineResponse20016 = InlineResponse20016
  { inlineResponse20016ParsedInstructions :: !([A.Value]) -- ^ /Required/ "parsedInstructions"
  , inlineResponse20016Ingredients :: !([A.Value]) -- ^ /Required/ "ingredients"
  , inlineResponse20016Equipment :: !([A.Value]) -- ^ /Required/ "equipment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20016
instance A.FromJSON InlineResponse20016 where
  parseJSON = A.withObject "InlineResponse20016" $ \o ->
    InlineResponse20016
      <$> (o .:  "parsedInstructions")
      <*> (o .:  "ingredients")
      <*> (o .:  "equipment")

-- | ToJSON InlineResponse20016
instance A.ToJSON InlineResponse20016 where
  toJSON InlineResponse20016 {..} =
   _omitNulls
      [ "parsedInstructions" .= inlineResponse20016ParsedInstructions
      , "ingredients" .= inlineResponse20016Ingredients
      , "equipment" .= inlineResponse20016Equipment
      ]


-- | Construct a value of type 'InlineResponse20016' (by applying it's required fields, if any)
mkInlineResponse20016
  :: [A.Value] -- ^ 'inlineResponse20016ParsedInstructions' 
  -> [A.Value] -- ^ 'inlineResponse20016Ingredients' 
  -> [A.Value] -- ^ 'inlineResponse20016Equipment' 
  -> InlineResponse20016
mkInlineResponse20016 inlineResponse20016ParsedInstructions inlineResponse20016Ingredients inlineResponse20016Equipment =
  InlineResponse20016
  { inlineResponse20016ParsedInstructions
  , inlineResponse20016Ingredients
  , inlineResponse20016Equipment
  }

-- ** InlineResponse20017
-- | InlineResponse20017
data InlineResponse20017 = InlineResponse20017
  { inlineResponse20017Cuisine :: !(Text) -- ^ /Required/ "cuisine"
  , inlineResponse20017Cuisines :: !([Text]) -- ^ /Required/ "cuisines"
  , inlineResponse20017Confidence :: !(Double) -- ^ /Required/ "confidence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20017
instance A.FromJSON InlineResponse20017 where
  parseJSON = A.withObject "InlineResponse20017" $ \o ->
    InlineResponse20017
      <$> (o .:  "cuisine")
      <*> (o .:  "cuisines")
      <*> (o .:  "confidence")

-- | ToJSON InlineResponse20017
instance A.ToJSON InlineResponse20017 where
  toJSON InlineResponse20017 {..} =
   _omitNulls
      [ "cuisine" .= inlineResponse20017Cuisine
      , "cuisines" .= inlineResponse20017Cuisines
      , "confidence" .= inlineResponse20017Confidence
      ]


-- | Construct a value of type 'InlineResponse20017' (by applying it's required fields, if any)
mkInlineResponse20017
  :: Text -- ^ 'inlineResponse20017Cuisine' 
  -> [Text] -- ^ 'inlineResponse20017Cuisines' 
  -> Double -- ^ 'inlineResponse20017Confidence' 
  -> InlineResponse20017
mkInlineResponse20017 inlineResponse20017Cuisine inlineResponse20017Cuisines inlineResponse20017Confidence =
  InlineResponse20017
  { inlineResponse20017Cuisine
  , inlineResponse20017Cuisines
  , inlineResponse20017Confidence
  }

-- ** InlineResponse20018
-- | InlineResponse20018
data InlineResponse20018 = InlineResponse20018
  { inlineResponse20018Dishes :: !([InlineResponse20018Dishes]) -- ^ /Required/ "dishes"
  , inlineResponse20018Ingredients :: !([InlineResponse20018Ingredients]) -- ^ /Required/ "ingredients"
  , inlineResponse20018Cuisines :: !([Text]) -- ^ /Required/ "cuisines"
  , inlineResponse20018Modifiers :: !([Text]) -- ^ /Required/ "modifiers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018
instance A.FromJSON InlineResponse20018 where
  parseJSON = A.withObject "InlineResponse20018" $ \o ->
    InlineResponse20018
      <$> (o .:  "dishes")
      <*> (o .:  "ingredients")
      <*> (o .:  "cuisines")
      <*> (o .:  "modifiers")

-- | ToJSON InlineResponse20018
instance A.ToJSON InlineResponse20018 where
  toJSON InlineResponse20018 {..} =
   _omitNulls
      [ "dishes" .= inlineResponse20018Dishes
      , "ingredients" .= inlineResponse20018Ingredients
      , "cuisines" .= inlineResponse20018Cuisines
      , "modifiers" .= inlineResponse20018Modifiers
      ]


-- | Construct a value of type 'InlineResponse20018' (by applying it's required fields, if any)
mkInlineResponse20018
  :: [InlineResponse20018Dishes] -- ^ 'inlineResponse20018Dishes' 
  -> [InlineResponse20018Ingredients] -- ^ 'inlineResponse20018Ingredients' 
  -> [Text] -- ^ 'inlineResponse20018Cuisines' 
  -> [Text] -- ^ 'inlineResponse20018Modifiers' 
  -> InlineResponse20018
mkInlineResponse20018 inlineResponse20018Dishes inlineResponse20018Ingredients inlineResponse20018Cuisines inlineResponse20018Modifiers =
  InlineResponse20018
  { inlineResponse20018Dishes
  , inlineResponse20018Ingredients
  , inlineResponse20018Cuisines
  , inlineResponse20018Modifiers
  }

-- ** InlineResponse20018Dishes
-- | InlineResponse20018Dishes
data InlineResponse20018Dishes = InlineResponse20018Dishes
  { inlineResponse20018DishesImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20018DishesName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018Dishes
instance A.FromJSON InlineResponse20018Dishes where
  parseJSON = A.withObject "InlineResponse20018Dishes" $ \o ->
    InlineResponse20018Dishes
      <$> (o .:  "image")
      <*> (o .:  "name")

-- | ToJSON InlineResponse20018Dishes
instance A.ToJSON InlineResponse20018Dishes where
  toJSON InlineResponse20018Dishes {..} =
   _omitNulls
      [ "image" .= inlineResponse20018DishesImage
      , "name" .= inlineResponse20018DishesName
      ]


-- | Construct a value of type 'InlineResponse20018Dishes' (by applying it's required fields, if any)
mkInlineResponse20018Dishes
  :: Text -- ^ 'inlineResponse20018DishesImage' 
  -> Text -- ^ 'inlineResponse20018DishesName' 
  -> InlineResponse20018Dishes
mkInlineResponse20018Dishes inlineResponse20018DishesImage inlineResponse20018DishesName =
  InlineResponse20018Dishes
  { inlineResponse20018DishesImage
  , inlineResponse20018DishesName
  }

-- ** InlineResponse20018Ingredients
-- | InlineResponse20018Ingredients
data InlineResponse20018Ingredients = InlineResponse20018Ingredients
  { inlineResponse20018IngredientsImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20018IngredientsInclude :: !(Bool) -- ^ /Required/ "include"
  , inlineResponse20018IngredientsName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20018Ingredients
instance A.FromJSON InlineResponse20018Ingredients where
  parseJSON = A.withObject "InlineResponse20018Ingredients" $ \o ->
    InlineResponse20018Ingredients
      <$> (o .:  "image")
      <*> (o .:  "include")
      <*> (o .:  "name")

-- | ToJSON InlineResponse20018Ingredients
instance A.ToJSON InlineResponse20018Ingredients where
  toJSON InlineResponse20018Ingredients {..} =
   _omitNulls
      [ "image" .= inlineResponse20018IngredientsImage
      , "include" .= inlineResponse20018IngredientsInclude
      , "name" .= inlineResponse20018IngredientsName
      ]


-- | Construct a value of type 'InlineResponse20018Ingredients' (by applying it's required fields, if any)
mkInlineResponse20018Ingredients
  :: Text -- ^ 'inlineResponse20018IngredientsImage' 
  -> Bool -- ^ 'inlineResponse20018IngredientsInclude' 
  -> Text -- ^ 'inlineResponse20018IngredientsName' 
  -> InlineResponse20018Ingredients
mkInlineResponse20018Ingredients inlineResponse20018IngredientsImage inlineResponse20018IngredientsInclude inlineResponse20018IngredientsName =
  InlineResponse20018Ingredients
  { inlineResponse20018IngredientsImage
  , inlineResponse20018IngredientsInclude
  , inlineResponse20018IngredientsName
  }

-- ** InlineResponse20019
-- | InlineResponse20019
data InlineResponse20019 = InlineResponse20019
  { inlineResponse20019SourceAmount :: !(Double) -- ^ /Required/ "sourceAmount"
  , inlineResponse20019SourceUnit :: !(Text) -- ^ /Required/ "sourceUnit"
  , inlineResponse20019TargetAmount :: !(Double) -- ^ /Required/ "targetAmount"
  , inlineResponse20019TargetUnit :: !(Text) -- ^ /Required/ "targetUnit"
  , inlineResponse20019Answer :: !(Text) -- ^ /Required/ "answer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20019
instance A.FromJSON InlineResponse20019 where
  parseJSON = A.withObject "InlineResponse20019" $ \o ->
    InlineResponse20019
      <$> (o .:  "sourceAmount")
      <*> (o .:  "sourceUnit")
      <*> (o .:  "targetAmount")
      <*> (o .:  "targetUnit")
      <*> (o .:  "answer")

-- | ToJSON InlineResponse20019
instance A.ToJSON InlineResponse20019 where
  toJSON InlineResponse20019 {..} =
   _omitNulls
      [ "sourceAmount" .= inlineResponse20019SourceAmount
      , "sourceUnit" .= inlineResponse20019SourceUnit
      , "targetAmount" .= inlineResponse20019TargetAmount
      , "targetUnit" .= inlineResponse20019TargetUnit
      , "answer" .= inlineResponse20019Answer
      ]


-- | Construct a value of type 'InlineResponse20019' (by applying it's required fields, if any)
mkInlineResponse20019
  :: Double -- ^ 'inlineResponse20019SourceAmount' 
  -> Text -- ^ 'inlineResponse20019SourceUnit' 
  -> Double -- ^ 'inlineResponse20019TargetAmount' 
  -> Text -- ^ 'inlineResponse20019TargetUnit' 
  -> Text -- ^ 'inlineResponse20019Answer' 
  -> InlineResponse20019
mkInlineResponse20019 inlineResponse20019SourceAmount inlineResponse20019SourceUnit inlineResponse20019TargetAmount inlineResponse20019TargetUnit inlineResponse20019Answer =
  InlineResponse20019
  { inlineResponse20019SourceAmount
  , inlineResponse20019SourceUnit
  , inlineResponse20019TargetAmount
  , inlineResponse20019TargetUnit
  , inlineResponse20019Answer
  }

-- ** InlineResponse2002
-- | InlineResponse2002
data InlineResponse2002 = InlineResponse2002
  { inlineResponse2002Calories :: !(Double) -- ^ /Required/ "calories"
  , inlineResponse2002Carbs :: !(Text) -- ^ /Required/ "carbs"
  , inlineResponse2002Fat :: !(Text) -- ^ /Required/ "fat"
  , inlineResponse2002Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2002Image :: !(Text) -- ^ /Required/ "image"
  , inlineResponse2002ImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse2002Protein :: !(Text) -- ^ /Required/ "protein"
  , inlineResponse2002Title :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002
instance A.FromJSON InlineResponse2002 where
  parseJSON = A.withObject "InlineResponse2002" $ \o ->
    InlineResponse2002
      <$> (o .:  "calories")
      <*> (o .:  "carbs")
      <*> (o .:  "fat")
      <*> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "protein")
      <*> (o .:  "title")

-- | ToJSON InlineResponse2002
instance A.ToJSON InlineResponse2002 where
  toJSON InlineResponse2002 {..} =
   _omitNulls
      [ "calories" .= inlineResponse2002Calories
      , "carbs" .= inlineResponse2002Carbs
      , "fat" .= inlineResponse2002Fat
      , "id" .= inlineResponse2002Id
      , "image" .= inlineResponse2002Image
      , "imageType" .= inlineResponse2002ImageType
      , "protein" .= inlineResponse2002Protein
      , "title" .= inlineResponse2002Title
      ]


-- | Construct a value of type 'InlineResponse2002' (by applying it's required fields, if any)
mkInlineResponse2002
  :: Double -- ^ 'inlineResponse2002Calories' 
  -> Text -- ^ 'inlineResponse2002Carbs' 
  -> Text -- ^ 'inlineResponse2002Fat' 
  -> Int -- ^ 'inlineResponse2002Id' 
  -> Text -- ^ 'inlineResponse2002Image' 
  -> Text -- ^ 'inlineResponse2002ImageType' 
  -> Text -- ^ 'inlineResponse2002Protein' 
  -> Text -- ^ 'inlineResponse2002Title' 
  -> InlineResponse2002
mkInlineResponse2002 inlineResponse2002Calories inlineResponse2002Carbs inlineResponse2002Fat inlineResponse2002Id inlineResponse2002Image inlineResponse2002ImageType inlineResponse2002Protein inlineResponse2002Title =
  InlineResponse2002
  { inlineResponse2002Calories
  , inlineResponse2002Carbs
  , inlineResponse2002Fat
  , inlineResponse2002Id
  , inlineResponse2002Image
  , inlineResponse2002ImageType
  , inlineResponse2002Protein
  , inlineResponse2002Title
  }

-- ** InlineResponse20020
-- | InlineResponse20020
data InlineResponse20020 = InlineResponse20020
  { inlineResponse20020Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20020Original :: !(Text) -- ^ /Required/ "original"
  , inlineResponse20020OriginalName :: !(Text) -- ^ /Required/ "originalName"
  , inlineResponse20020Name :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20020NameClean :: !(Text) -- ^ /Required/ "nameClean"
  , inlineResponse20020Amount :: !(Double) -- ^ /Required/ "amount"
  , inlineResponse20020Unit :: !(Text) -- ^ /Required/ "unit"
  , inlineResponse20020UnitShort :: !(Text) -- ^ /Required/ "unitShort"
  , inlineResponse20020UnitLong :: !(Text) -- ^ /Required/ "unitLong"
  , inlineResponse20020PossibleUnits :: !([Text]) -- ^ /Required/ "possibleUnits"
  , inlineResponse20020EstimatedCost :: !(RecipesParseIngredientsEstimatedCost) -- ^ /Required/ "estimatedCost"
  , inlineResponse20020Consistency :: !(Text) -- ^ /Required/ "consistency"
  , inlineResponse20020Aisle :: !(Text) -- ^ /Required/ "aisle"
  , inlineResponse20020Image :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20020Meta :: !([Text]) -- ^ /Required/ "meta"
  , inlineResponse20020Nutrition :: !(RecipesParseIngredientsNutrition) -- ^ /Required/ "nutrition"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20020
instance A.FromJSON InlineResponse20020 where
  parseJSON = A.withObject "InlineResponse20020" $ \o ->
    InlineResponse20020
      <$> (o .:  "id")
      <*> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "name")
      <*> (o .:  "nameClean")
      <*> (o .:  "amount")
      <*> (o .:  "unit")
      <*> (o .:  "unitShort")
      <*> (o .:  "unitLong")
      <*> (o .:  "possibleUnits")
      <*> (o .:  "estimatedCost")
      <*> (o .:  "consistency")
      <*> (o .:  "aisle")
      <*> (o .:  "image")
      <*> (o .:  "meta")
      <*> (o .:  "nutrition")

-- | ToJSON InlineResponse20020
instance A.ToJSON InlineResponse20020 where
  toJSON InlineResponse20020 {..} =
   _omitNulls
      [ "id" .= inlineResponse20020Id
      , "original" .= inlineResponse20020Original
      , "originalName" .= inlineResponse20020OriginalName
      , "name" .= inlineResponse20020Name
      , "nameClean" .= inlineResponse20020NameClean
      , "amount" .= inlineResponse20020Amount
      , "unit" .= inlineResponse20020Unit
      , "unitShort" .= inlineResponse20020UnitShort
      , "unitLong" .= inlineResponse20020UnitLong
      , "possibleUnits" .= inlineResponse20020PossibleUnits
      , "estimatedCost" .= inlineResponse20020EstimatedCost
      , "consistency" .= inlineResponse20020Consistency
      , "aisle" .= inlineResponse20020Aisle
      , "image" .= inlineResponse20020Image
      , "meta" .= inlineResponse20020Meta
      , "nutrition" .= inlineResponse20020Nutrition
      ]


-- | Construct a value of type 'InlineResponse20020' (by applying it's required fields, if any)
mkInlineResponse20020
  :: Int -- ^ 'inlineResponse20020Id' 
  -> Text -- ^ 'inlineResponse20020Original' 
  -> Text -- ^ 'inlineResponse20020OriginalName' 
  -> Text -- ^ 'inlineResponse20020Name' 
  -> Text -- ^ 'inlineResponse20020NameClean' 
  -> Double -- ^ 'inlineResponse20020Amount' 
  -> Text -- ^ 'inlineResponse20020Unit' 
  -> Text -- ^ 'inlineResponse20020UnitShort' 
  -> Text -- ^ 'inlineResponse20020UnitLong' 
  -> [Text] -- ^ 'inlineResponse20020PossibleUnits' 
  -> RecipesParseIngredientsEstimatedCost -- ^ 'inlineResponse20020EstimatedCost' 
  -> Text -- ^ 'inlineResponse20020Consistency' 
  -> Text -- ^ 'inlineResponse20020Aisle' 
  -> Text -- ^ 'inlineResponse20020Image' 
  -> [Text] -- ^ 'inlineResponse20020Meta' 
  -> RecipesParseIngredientsNutrition -- ^ 'inlineResponse20020Nutrition' 
  -> InlineResponse20020
mkInlineResponse20020 inlineResponse20020Id inlineResponse20020Original inlineResponse20020OriginalName inlineResponse20020Name inlineResponse20020NameClean inlineResponse20020Amount inlineResponse20020Unit inlineResponse20020UnitShort inlineResponse20020UnitLong inlineResponse20020PossibleUnits inlineResponse20020EstimatedCost inlineResponse20020Consistency inlineResponse20020Aisle inlineResponse20020Image inlineResponse20020Meta inlineResponse20020Nutrition =
  InlineResponse20020
  { inlineResponse20020Id
  , inlineResponse20020Original
  , inlineResponse20020OriginalName
  , inlineResponse20020Name
  , inlineResponse20020NameClean
  , inlineResponse20020Amount
  , inlineResponse20020Unit
  , inlineResponse20020UnitShort
  , inlineResponse20020UnitLong
  , inlineResponse20020PossibleUnits
  , inlineResponse20020EstimatedCost
  , inlineResponse20020Consistency
  , inlineResponse20020Aisle
  , inlineResponse20020Image
  , inlineResponse20020Meta
  , inlineResponse20020Nutrition
  }

-- ** InlineResponse20021
-- | InlineResponse20021
data InlineResponse20021 = InlineResponse20021
  { inlineResponse20021Calories :: !(InlineResponse20021Calories) -- ^ /Required/ "calories"
  , inlineResponse20021Carbs :: !(InlineResponse20021Calories) -- ^ /Required/ "carbs"
  , inlineResponse20021Fat :: !(InlineResponse20021Calories) -- ^ /Required/ "fat"
  , inlineResponse20021Protein :: !(InlineResponse20021Calories) -- ^ /Required/ "protein"
  , inlineResponse20021RecipesUsed :: !(Int) -- ^ /Required/ "recipesUsed"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20021
instance A.FromJSON InlineResponse20021 where
  parseJSON = A.withObject "InlineResponse20021" $ \o ->
    InlineResponse20021
      <$> (o .:  "calories")
      <*> (o .:  "carbs")
      <*> (o .:  "fat")
      <*> (o .:  "protein")
      <*> (o .:  "recipesUsed")

-- | ToJSON InlineResponse20021
instance A.ToJSON InlineResponse20021 where
  toJSON InlineResponse20021 {..} =
   _omitNulls
      [ "calories" .= inlineResponse20021Calories
      , "carbs" .= inlineResponse20021Carbs
      , "fat" .= inlineResponse20021Fat
      , "protein" .= inlineResponse20021Protein
      , "recipesUsed" .= inlineResponse20021RecipesUsed
      ]


-- | Construct a value of type 'InlineResponse20021' (by applying it's required fields, if any)
mkInlineResponse20021
  :: InlineResponse20021Calories -- ^ 'inlineResponse20021Calories' 
  -> InlineResponse20021Calories -- ^ 'inlineResponse20021Carbs' 
  -> InlineResponse20021Calories -- ^ 'inlineResponse20021Fat' 
  -> InlineResponse20021Calories -- ^ 'inlineResponse20021Protein' 
  -> Int -- ^ 'inlineResponse20021RecipesUsed' 
  -> InlineResponse20021
mkInlineResponse20021 inlineResponse20021Calories inlineResponse20021Carbs inlineResponse20021Fat inlineResponse20021Protein inlineResponse20021RecipesUsed =
  InlineResponse20021
  { inlineResponse20021Calories
  , inlineResponse20021Carbs
  , inlineResponse20021Fat
  , inlineResponse20021Protein
  , inlineResponse20021RecipesUsed
  }

-- ** InlineResponse20021Calories
-- | InlineResponse20021Calories
data InlineResponse20021Calories = InlineResponse20021Calories
  { inlineResponse20021CaloriesConfidenceRange95Percent :: !(InlineResponse20021CaloriesConfidenceRange95Percent) -- ^ /Required/ "confidenceRange95Percent"
  , inlineResponse20021CaloriesStandardDeviation :: !(Double) -- ^ /Required/ "standardDeviation"
  , inlineResponse20021CaloriesUnit :: !(Text) -- ^ /Required/ "unit"
  , inlineResponse20021CaloriesValue :: !(Double) -- ^ /Required/ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20021Calories
instance A.FromJSON InlineResponse20021Calories where
  parseJSON = A.withObject "InlineResponse20021Calories" $ \o ->
    InlineResponse20021Calories
      <$> (o .:  "confidenceRange95Percent")
      <*> (o .:  "standardDeviation")
      <*> (o .:  "unit")
      <*> (o .:  "value")

-- | ToJSON InlineResponse20021Calories
instance A.ToJSON InlineResponse20021Calories where
  toJSON InlineResponse20021Calories {..} =
   _omitNulls
      [ "confidenceRange95Percent" .= inlineResponse20021CaloriesConfidenceRange95Percent
      , "standardDeviation" .= inlineResponse20021CaloriesStandardDeviation
      , "unit" .= inlineResponse20021CaloriesUnit
      , "value" .= inlineResponse20021CaloriesValue
      ]


-- | Construct a value of type 'InlineResponse20021Calories' (by applying it's required fields, if any)
mkInlineResponse20021Calories
  :: InlineResponse20021CaloriesConfidenceRange95Percent -- ^ 'inlineResponse20021CaloriesConfidenceRange95Percent' 
  -> Double -- ^ 'inlineResponse20021CaloriesStandardDeviation' 
  -> Text -- ^ 'inlineResponse20021CaloriesUnit' 
  -> Double -- ^ 'inlineResponse20021CaloriesValue' 
  -> InlineResponse20021Calories
mkInlineResponse20021Calories inlineResponse20021CaloriesConfidenceRange95Percent inlineResponse20021CaloriesStandardDeviation inlineResponse20021CaloriesUnit inlineResponse20021CaloriesValue =
  InlineResponse20021Calories
  { inlineResponse20021CaloriesConfidenceRange95Percent
  , inlineResponse20021CaloriesStandardDeviation
  , inlineResponse20021CaloriesUnit
  , inlineResponse20021CaloriesValue
  }

-- ** InlineResponse20021CaloriesConfidenceRange95Percent
-- | InlineResponse20021CaloriesConfidenceRange95Percent
data InlineResponse20021CaloriesConfidenceRange95Percent = InlineResponse20021CaloriesConfidenceRange95Percent
  { inlineResponse20021CaloriesConfidenceRange95PercentMax :: !(Double) -- ^ /Required/ "max"
  , inlineResponse20021CaloriesConfidenceRange95PercentMin :: !(Double) -- ^ /Required/ "min"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20021CaloriesConfidenceRange95Percent
instance A.FromJSON InlineResponse20021CaloriesConfidenceRange95Percent where
  parseJSON = A.withObject "InlineResponse20021CaloriesConfidenceRange95Percent" $ \o ->
    InlineResponse20021CaloriesConfidenceRange95Percent
      <$> (o .:  "max")
      <*> (o .:  "min")

-- | ToJSON InlineResponse20021CaloriesConfidenceRange95Percent
instance A.ToJSON InlineResponse20021CaloriesConfidenceRange95Percent where
  toJSON InlineResponse20021CaloriesConfidenceRange95Percent {..} =
   _omitNulls
      [ "max" .= inlineResponse20021CaloriesConfidenceRange95PercentMax
      , "min" .= inlineResponse20021CaloriesConfidenceRange95PercentMin
      ]


-- | Construct a value of type 'InlineResponse20021CaloriesConfidenceRange95Percent' (by applying it's required fields, if any)
mkInlineResponse20021CaloriesConfidenceRange95Percent
  :: Double -- ^ 'inlineResponse20021CaloriesConfidenceRange95PercentMax' 
  -> Double -- ^ 'inlineResponse20021CaloriesConfidenceRange95PercentMin' 
  -> InlineResponse20021CaloriesConfidenceRange95Percent
mkInlineResponse20021CaloriesConfidenceRange95Percent inlineResponse20021CaloriesConfidenceRange95PercentMax inlineResponse20021CaloriesConfidenceRange95PercentMin =
  InlineResponse20021CaloriesConfidenceRange95Percent
  { inlineResponse20021CaloriesConfidenceRange95PercentMax
  , inlineResponse20021CaloriesConfidenceRange95PercentMin
  }

-- ** InlineResponse20022
-- | InlineResponse20022
data InlineResponse20022 = InlineResponse20022
  { inlineResponse20022Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20022Original :: !(Text) -- ^ /Required/ "original"
  , inlineResponse20022OriginalName :: !(Text) -- ^ /Required/ "originalName"
  , inlineResponse20022Name :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20022NameClean :: !(Text) -- ^ /Required/ "nameClean"
  , inlineResponse20022Amount :: !(Double) -- ^ /Required/ "amount"
  , inlineResponse20022Unit :: !(Text) -- ^ /Required/ "unit"
  , inlineResponse20022UnitShort :: !(Text) -- ^ /Required/ "unitShort"
  , inlineResponse20022UnitLong :: !(Text) -- ^ /Required/ "unitLong"
  , inlineResponse20022PossibleUnits :: !([Text]) -- ^ /Required/ "possibleUnits"
  , inlineResponse20022EstimatedCost :: !(RecipesParseIngredientsEstimatedCost) -- ^ /Required/ "estimatedCost"
  , inlineResponse20022Consistency :: !(Text) -- ^ /Required/ "consistency"
  , inlineResponse20022ShoppingListUnits :: !([Text]) -- ^ /Required/ "shoppingListUnits"
  , inlineResponse20022Aisle :: !(Text) -- ^ /Required/ "aisle"
  , inlineResponse20022Image :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20022Meta :: !([A.Value]) -- ^ /Required/ "meta"
  , inlineResponse20022Nutrition :: !(InlineResponse20022Nutrition) -- ^ /Required/ "nutrition"
  , inlineResponse20022CategoryPath :: !([Text]) -- ^ /Required/ "categoryPath"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20022
instance A.FromJSON InlineResponse20022 where
  parseJSON = A.withObject "InlineResponse20022" $ \o ->
    InlineResponse20022
      <$> (o .:  "id")
      <*> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "name")
      <*> (o .:  "nameClean")
      <*> (o .:  "amount")
      <*> (o .:  "unit")
      <*> (o .:  "unitShort")
      <*> (o .:  "unitLong")
      <*> (o .:  "possibleUnits")
      <*> (o .:  "estimatedCost")
      <*> (o .:  "consistency")
      <*> (o .:  "shoppingListUnits")
      <*> (o .:  "aisle")
      <*> (o .:  "image")
      <*> (o .:  "meta")
      <*> (o .:  "nutrition")
      <*> (o .:  "categoryPath")

-- | ToJSON InlineResponse20022
instance A.ToJSON InlineResponse20022 where
  toJSON InlineResponse20022 {..} =
   _omitNulls
      [ "id" .= inlineResponse20022Id
      , "original" .= inlineResponse20022Original
      , "originalName" .= inlineResponse20022OriginalName
      , "name" .= inlineResponse20022Name
      , "nameClean" .= inlineResponse20022NameClean
      , "amount" .= inlineResponse20022Amount
      , "unit" .= inlineResponse20022Unit
      , "unitShort" .= inlineResponse20022UnitShort
      , "unitLong" .= inlineResponse20022UnitLong
      , "possibleUnits" .= inlineResponse20022PossibleUnits
      , "estimatedCost" .= inlineResponse20022EstimatedCost
      , "consistency" .= inlineResponse20022Consistency
      , "shoppingListUnits" .= inlineResponse20022ShoppingListUnits
      , "aisle" .= inlineResponse20022Aisle
      , "image" .= inlineResponse20022Image
      , "meta" .= inlineResponse20022Meta
      , "nutrition" .= inlineResponse20022Nutrition
      , "categoryPath" .= inlineResponse20022CategoryPath
      ]


-- | Construct a value of type 'InlineResponse20022' (by applying it's required fields, if any)
mkInlineResponse20022
  :: Int -- ^ 'inlineResponse20022Id' 
  -> Text -- ^ 'inlineResponse20022Original' 
  -> Text -- ^ 'inlineResponse20022OriginalName' 
  -> Text -- ^ 'inlineResponse20022Name' 
  -> Text -- ^ 'inlineResponse20022NameClean' 
  -> Double -- ^ 'inlineResponse20022Amount' 
  -> Text -- ^ 'inlineResponse20022Unit' 
  -> Text -- ^ 'inlineResponse20022UnitShort' 
  -> Text -- ^ 'inlineResponse20022UnitLong' 
  -> [Text] -- ^ 'inlineResponse20022PossibleUnits' 
  -> RecipesParseIngredientsEstimatedCost -- ^ 'inlineResponse20022EstimatedCost' 
  -> Text -- ^ 'inlineResponse20022Consistency' 
  -> [Text] -- ^ 'inlineResponse20022ShoppingListUnits' 
  -> Text -- ^ 'inlineResponse20022Aisle' 
  -> Text -- ^ 'inlineResponse20022Image' 
  -> [A.Value] -- ^ 'inlineResponse20022Meta' 
  -> InlineResponse20022Nutrition -- ^ 'inlineResponse20022Nutrition' 
  -> [Text] -- ^ 'inlineResponse20022CategoryPath' 
  -> InlineResponse20022
mkInlineResponse20022 inlineResponse20022Id inlineResponse20022Original inlineResponse20022OriginalName inlineResponse20022Name inlineResponse20022NameClean inlineResponse20022Amount inlineResponse20022Unit inlineResponse20022UnitShort inlineResponse20022UnitLong inlineResponse20022PossibleUnits inlineResponse20022EstimatedCost inlineResponse20022Consistency inlineResponse20022ShoppingListUnits inlineResponse20022Aisle inlineResponse20022Image inlineResponse20022Meta inlineResponse20022Nutrition inlineResponse20022CategoryPath =
  InlineResponse20022
  { inlineResponse20022Id
  , inlineResponse20022Original
  , inlineResponse20022OriginalName
  , inlineResponse20022Name
  , inlineResponse20022NameClean
  , inlineResponse20022Amount
  , inlineResponse20022Unit
  , inlineResponse20022UnitShort
  , inlineResponse20022UnitLong
  , inlineResponse20022PossibleUnits
  , inlineResponse20022EstimatedCost
  , inlineResponse20022Consistency
  , inlineResponse20022ShoppingListUnits
  , inlineResponse20022Aisle
  , inlineResponse20022Image
  , inlineResponse20022Meta
  , inlineResponse20022Nutrition
  , inlineResponse20022CategoryPath
  }

-- ** InlineResponse20022Nutrition
-- | InlineResponse20022Nutrition
data InlineResponse20022Nutrition = InlineResponse20022Nutrition
  { inlineResponse20022NutritionNutrients :: !([RecipesParseIngredientsNutritionNutrients]) -- ^ /Required/ "nutrients"
  , inlineResponse20022NutritionProperties :: !([RecipesParseIngredientsNutritionProperties]) -- ^ /Required/ "properties"
  , inlineResponse20022NutritionCaloricBreakdown :: !(RecipesParseIngredientsNutritionCaloricBreakdown) -- ^ /Required/ "caloricBreakdown"
  , inlineResponse20022NutritionWeightPerServing :: !(RecipesParseIngredientsNutritionWeightPerServing) -- ^ /Required/ "weightPerServing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20022Nutrition
instance A.FromJSON InlineResponse20022Nutrition where
  parseJSON = A.withObject "InlineResponse20022Nutrition" $ \o ->
    InlineResponse20022Nutrition
      <$> (o .:  "nutrients")
      <*> (o .:  "properties")
      <*> (o .:  "caloricBreakdown")
      <*> (o .:  "weightPerServing")

-- | ToJSON InlineResponse20022Nutrition
instance A.ToJSON InlineResponse20022Nutrition where
  toJSON InlineResponse20022Nutrition {..} =
   _omitNulls
      [ "nutrients" .= inlineResponse20022NutritionNutrients
      , "properties" .= inlineResponse20022NutritionProperties
      , "caloricBreakdown" .= inlineResponse20022NutritionCaloricBreakdown
      , "weightPerServing" .= inlineResponse20022NutritionWeightPerServing
      ]


-- | Construct a value of type 'InlineResponse20022Nutrition' (by applying it's required fields, if any)
mkInlineResponse20022Nutrition
  :: [RecipesParseIngredientsNutritionNutrients] -- ^ 'inlineResponse20022NutritionNutrients' 
  -> [RecipesParseIngredientsNutritionProperties] -- ^ 'inlineResponse20022NutritionProperties' 
  -> RecipesParseIngredientsNutritionCaloricBreakdown -- ^ 'inlineResponse20022NutritionCaloricBreakdown' 
  -> RecipesParseIngredientsNutritionWeightPerServing -- ^ 'inlineResponse20022NutritionWeightPerServing' 
  -> InlineResponse20022Nutrition
mkInlineResponse20022Nutrition inlineResponse20022NutritionNutrients inlineResponse20022NutritionProperties inlineResponse20022NutritionCaloricBreakdown inlineResponse20022NutritionWeightPerServing =
  InlineResponse20022Nutrition
  { inlineResponse20022NutritionNutrients
  , inlineResponse20022NutritionProperties
  , inlineResponse20022NutritionCaloricBreakdown
  , inlineResponse20022NutritionWeightPerServing
  }

-- ** InlineResponse20023
-- | InlineResponse20023
data InlineResponse20023 = InlineResponse20023
  { inlineResponse20023TotalGlycemicLoad :: !(Double) -- ^ /Required/ "totalGlycemicLoad"
  , inlineResponse20023Ingredients :: !([InlineResponse20023Ingredients]) -- ^ /Required/ "ingredients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20023
instance A.FromJSON InlineResponse20023 where
  parseJSON = A.withObject "InlineResponse20023" $ \o ->
    InlineResponse20023
      <$> (o .:  "totalGlycemicLoad")
      <*> (o .:  "ingredients")

-- | ToJSON InlineResponse20023
instance A.ToJSON InlineResponse20023 where
  toJSON InlineResponse20023 {..} =
   _omitNulls
      [ "totalGlycemicLoad" .= inlineResponse20023TotalGlycemicLoad
      , "ingredients" .= inlineResponse20023Ingredients
      ]


-- | Construct a value of type 'InlineResponse20023' (by applying it's required fields, if any)
mkInlineResponse20023
  :: Double -- ^ 'inlineResponse20023TotalGlycemicLoad' 
  -> [InlineResponse20023Ingredients] -- ^ 'inlineResponse20023Ingredients' 
  -> InlineResponse20023
mkInlineResponse20023 inlineResponse20023TotalGlycemicLoad inlineResponse20023Ingredients =
  InlineResponse20023
  { inlineResponse20023TotalGlycemicLoad
  , inlineResponse20023Ingredients
  }

-- ** InlineResponse20023Ingredients
-- | InlineResponse20023Ingredients
data InlineResponse20023Ingredients = InlineResponse20023Ingredients
  { inlineResponse20023IngredientsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20023IngredientsOriginal :: !(Text) -- ^ /Required/ "original"
  , inlineResponse20023IngredientsGlycemicIndex :: !(Double) -- ^ /Required/ "glycemicIndex"
  , inlineResponse20023IngredientsGlycemicLoad :: !(Double) -- ^ /Required/ "glycemicLoad"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20023Ingredients
instance A.FromJSON InlineResponse20023Ingredients where
  parseJSON = A.withObject "InlineResponse20023Ingredients" $ \o ->
    InlineResponse20023Ingredients
      <$> (o .:  "id")
      <*> (o .:  "original")
      <*> (o .:  "glycemicIndex")
      <*> (o .:  "glycemicLoad")

-- | ToJSON InlineResponse20023Ingredients
instance A.ToJSON InlineResponse20023Ingredients where
  toJSON InlineResponse20023Ingredients {..} =
   _omitNulls
      [ "id" .= inlineResponse20023IngredientsId
      , "original" .= inlineResponse20023IngredientsOriginal
      , "glycemicIndex" .= inlineResponse20023IngredientsGlycemicIndex
      , "glycemicLoad" .= inlineResponse20023IngredientsGlycemicLoad
      ]


-- | Construct a value of type 'InlineResponse20023Ingredients' (by applying it's required fields, if any)
mkInlineResponse20023Ingredients
  :: Int -- ^ 'inlineResponse20023IngredientsId' 
  -> Text -- ^ 'inlineResponse20023IngredientsOriginal' 
  -> Double -- ^ 'inlineResponse20023IngredientsGlycemicIndex' 
  -> Double -- ^ 'inlineResponse20023IngredientsGlycemicLoad' 
  -> InlineResponse20023Ingredients
mkInlineResponse20023Ingredients inlineResponse20023IngredientsId inlineResponse20023IngredientsOriginal inlineResponse20023IngredientsGlycemicIndex inlineResponse20023IngredientsGlycemicLoad =
  InlineResponse20023Ingredients
  { inlineResponse20023IngredientsId
  , inlineResponse20023IngredientsOriginal
  , inlineResponse20023IngredientsGlycemicIndex
  , inlineResponse20023IngredientsGlycemicLoad
  }

-- ** InlineResponse20024
-- | InlineResponse20024
data InlineResponse20024 = InlineResponse20024
  { inlineResponse20024Name :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20024Image :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20024Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20024Aisle :: !(Text) -- ^ /Required/ "aisle"
  , inlineResponse20024PossibleUnits :: !([Text]) -- ^ /Required/ "possibleUnits"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20024
instance A.FromJSON InlineResponse20024 where
  parseJSON = A.withObject "InlineResponse20024" $ \o ->
    InlineResponse20024
      <$> (o .:  "name")
      <*> (o .:  "image")
      <*> (o .:  "id")
      <*> (o .:  "aisle")
      <*> (o .:  "possibleUnits")

-- | ToJSON InlineResponse20024
instance A.ToJSON InlineResponse20024 where
  toJSON InlineResponse20024 {..} =
   _omitNulls
      [ "name" .= inlineResponse20024Name
      , "image" .= inlineResponse20024Image
      , "id" .= inlineResponse20024Id
      , "aisle" .= inlineResponse20024Aisle
      , "possibleUnits" .= inlineResponse20024PossibleUnits
      ]


-- | Construct a value of type 'InlineResponse20024' (by applying it's required fields, if any)
mkInlineResponse20024
  :: Text -- ^ 'inlineResponse20024Name' 
  -> Text -- ^ 'inlineResponse20024Image' 
  -> Int -- ^ 'inlineResponse20024Id' 
  -> Text -- ^ 'inlineResponse20024Aisle' 
  -> [Text] -- ^ 'inlineResponse20024PossibleUnits' 
  -> InlineResponse20024
mkInlineResponse20024 inlineResponse20024Name inlineResponse20024Image inlineResponse20024Id inlineResponse20024Aisle inlineResponse20024PossibleUnits =
  InlineResponse20024
  { inlineResponse20024Name
  , inlineResponse20024Image
  , inlineResponse20024Id
  , inlineResponse20024Aisle
  , inlineResponse20024PossibleUnits
  }

-- ** InlineResponse20025
-- | InlineResponse20025
data InlineResponse20025 = InlineResponse20025
  { inlineResponse20025Results :: !([InlineResponse20025Results]) -- ^ /Required/ "results"
  , inlineResponse20025Offset :: !(Int) -- ^ /Required/ "offset"
  , inlineResponse20025Number :: !(Int) -- ^ /Required/ "number"
  , inlineResponse20025TotalResults :: !(Int) -- ^ /Required/ "totalResults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20025
instance A.FromJSON InlineResponse20025 where
  parseJSON = A.withObject "InlineResponse20025" $ \o ->
    InlineResponse20025
      <$> (o .:  "results")
      <*> (o .:  "offset")
      <*> (o .:  "number")
      <*> (o .:  "totalResults")

-- | ToJSON InlineResponse20025
instance A.ToJSON InlineResponse20025 where
  toJSON InlineResponse20025 {..} =
   _omitNulls
      [ "results" .= inlineResponse20025Results
      , "offset" .= inlineResponse20025Offset
      , "number" .= inlineResponse20025Number
      , "totalResults" .= inlineResponse20025TotalResults
      ]


-- | Construct a value of type 'InlineResponse20025' (by applying it's required fields, if any)
mkInlineResponse20025
  :: [InlineResponse20025Results] -- ^ 'inlineResponse20025Results' 
  -> Int -- ^ 'inlineResponse20025Offset' 
  -> Int -- ^ 'inlineResponse20025Number' 
  -> Int -- ^ 'inlineResponse20025TotalResults' 
  -> InlineResponse20025
mkInlineResponse20025 inlineResponse20025Results inlineResponse20025Offset inlineResponse20025Number inlineResponse20025TotalResults =
  InlineResponse20025
  { inlineResponse20025Results
  , inlineResponse20025Offset
  , inlineResponse20025Number
  , inlineResponse20025TotalResults
  }

-- ** InlineResponse20025Results
-- | InlineResponse20025Results
data InlineResponse20025Results = InlineResponse20025Results
  { inlineResponse20025ResultsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20025ResultsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20025ResultsImage :: !(Text) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20025Results
instance A.FromJSON InlineResponse20025Results where
  parseJSON = A.withObject "InlineResponse20025Results" $ \o ->
    InlineResponse20025Results
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "image")

-- | ToJSON InlineResponse20025Results
instance A.ToJSON InlineResponse20025Results where
  toJSON InlineResponse20025Results {..} =
   _omitNulls
      [ "id" .= inlineResponse20025ResultsId
      , "name" .= inlineResponse20025ResultsName
      , "image" .= inlineResponse20025ResultsImage
      ]


-- | Construct a value of type 'InlineResponse20025Results' (by applying it's required fields, if any)
mkInlineResponse20025Results
  :: Int -- ^ 'inlineResponse20025ResultsId' 
  -> Text -- ^ 'inlineResponse20025ResultsName' 
  -> Text -- ^ 'inlineResponse20025ResultsImage' 
  -> InlineResponse20025Results
mkInlineResponse20025Results inlineResponse20025ResultsId inlineResponse20025ResultsName inlineResponse20025ResultsImage =
  InlineResponse20025Results
  { inlineResponse20025ResultsId
  , inlineResponse20025ResultsName
  , inlineResponse20025ResultsImage
  }

-- ** InlineResponse20026
-- | InlineResponse20026
data InlineResponse20026 = InlineResponse20026
  { inlineResponse20026Ingredient :: !(Text) -- ^ /Required/ "ingredient"
  , inlineResponse20026Substitutes :: !([Text]) -- ^ /Required/ "substitutes"
  , inlineResponse20026Message :: !(Text) -- ^ /Required/ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20026
instance A.FromJSON InlineResponse20026 where
  parseJSON = A.withObject "InlineResponse20026" $ \o ->
    InlineResponse20026
      <$> (o .:  "ingredient")
      <*> (o .:  "substitutes")
      <*> (o .:  "message")

-- | ToJSON InlineResponse20026
instance A.ToJSON InlineResponse20026 where
  toJSON InlineResponse20026 {..} =
   _omitNulls
      [ "ingredient" .= inlineResponse20026Ingredient
      , "substitutes" .= inlineResponse20026Substitutes
      , "message" .= inlineResponse20026Message
      ]


-- | Construct a value of type 'InlineResponse20026' (by applying it's required fields, if any)
mkInlineResponse20026
  :: Text -- ^ 'inlineResponse20026Ingredient' 
  -> [Text] -- ^ 'inlineResponse20026Substitutes' 
  -> Text -- ^ 'inlineResponse20026Message' 
  -> InlineResponse20026
mkInlineResponse20026 inlineResponse20026Ingredient inlineResponse20026Substitutes inlineResponse20026Message =
  InlineResponse20026
  { inlineResponse20026Ingredient
  , inlineResponse20026Substitutes
  , inlineResponse20026Message
  }

-- ** InlineResponse20027
-- | InlineResponse20027
data InlineResponse20027 = InlineResponse20027
  { inlineResponse20027Products :: !([InlineResponse2007]) -- ^ /Required/ "products"
  , inlineResponse20027TotalProducts :: !(Int) -- ^ /Required/ "totalProducts"
  , inlineResponse20027Type :: !(Text) -- ^ /Required/ "type"
  , inlineResponse20027Offset :: !(Int) -- ^ /Required/ "offset"
  , inlineResponse20027Number :: !(Int) -- ^ /Required/ "number"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20027
instance A.FromJSON InlineResponse20027 where
  parseJSON = A.withObject "InlineResponse20027" $ \o ->
    InlineResponse20027
      <$> (o .:  "products")
      <*> (o .:  "totalProducts")
      <*> (o .:  "type")
      <*> (o .:  "offset")
      <*> (o .:  "number")

-- | ToJSON InlineResponse20027
instance A.ToJSON InlineResponse20027 where
  toJSON InlineResponse20027 {..} =
   _omitNulls
      [ "products" .= inlineResponse20027Products
      , "totalProducts" .= inlineResponse20027TotalProducts
      , "type" .= inlineResponse20027Type
      , "offset" .= inlineResponse20027Offset
      , "number" .= inlineResponse20027Number
      ]


-- | Construct a value of type 'InlineResponse20027' (by applying it's required fields, if any)
mkInlineResponse20027
  :: [InlineResponse2007] -- ^ 'inlineResponse20027Products' 
  -> Int -- ^ 'inlineResponse20027TotalProducts' 
  -> Text -- ^ 'inlineResponse20027Type' 
  -> Int -- ^ 'inlineResponse20027Offset' 
  -> Int -- ^ 'inlineResponse20027Number' 
  -> InlineResponse20027
mkInlineResponse20027 inlineResponse20027Products inlineResponse20027TotalProducts inlineResponse20027Type inlineResponse20027Offset inlineResponse20027Number =
  InlineResponse20027
  { inlineResponse20027Products
  , inlineResponse20027TotalProducts
  , inlineResponse20027Type
  , inlineResponse20027Offset
  , inlineResponse20027Number
  }

-- ** InlineResponse20028
-- | InlineResponse20028
data InlineResponse20028 = InlineResponse20028
  { inlineResponse20028Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20028Title :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20028Badges :: !([Text]) -- ^ /Required/ "badges"
  , inlineResponse20028ImportantBadges :: !([Text]) -- ^ /Required/ "importantBadges"
  , inlineResponse20028Breadcrumbs :: !([Text]) -- ^ /Required/ "breadcrumbs"
  , inlineResponse20028GeneratedText :: !(Text) -- ^ /Required/ "generatedText"
  , inlineResponse20028ImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse20028IngredientCount :: !(Maybe Int) -- ^ "ingredientCount"
  , inlineResponse20028IngredientList :: !(Text) -- ^ /Required/ "ingredientList"
  , inlineResponse20028Ingredients :: !([InlineResponse20028Ingredients]) -- ^ /Required/ "ingredients"
  , inlineResponse20028Likes :: !(Double) -- ^ /Required/ "likes"
  , inlineResponse20028Nutrition :: !(InlineResponse20028Nutrition) -- ^ /Required/ "nutrition"
  , inlineResponse20028Price :: !(Double) -- ^ /Required/ "price"
  , inlineResponse20028Servings :: !(InlineResponse20028Servings) -- ^ /Required/ "servings"
  , inlineResponse20028SpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20028
instance A.FromJSON InlineResponse20028 where
  parseJSON = A.withObject "InlineResponse20028" $ \o ->
    InlineResponse20028
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "badges")
      <*> (o .:  "importantBadges")
      <*> (o .:  "breadcrumbs")
      <*> (o .:  "generatedText")
      <*> (o .:  "imageType")
      <*> (o .:? "ingredientCount")
      <*> (o .:  "ingredientList")
      <*> (o .:  "ingredients")
      <*> (o .:  "likes")
      <*> (o .:  "nutrition")
      <*> (o .:  "price")
      <*> (o .:  "servings")
      <*> (o .:  "spoonacularScore")

-- | ToJSON InlineResponse20028
instance A.ToJSON InlineResponse20028 where
  toJSON InlineResponse20028 {..} =
   _omitNulls
      [ "id" .= inlineResponse20028Id
      , "title" .= inlineResponse20028Title
      , "badges" .= inlineResponse20028Badges
      , "importantBadges" .= inlineResponse20028ImportantBadges
      , "breadcrumbs" .= inlineResponse20028Breadcrumbs
      , "generatedText" .= inlineResponse20028GeneratedText
      , "imageType" .= inlineResponse20028ImageType
      , "ingredientCount" .= inlineResponse20028IngredientCount
      , "ingredientList" .= inlineResponse20028IngredientList
      , "ingredients" .= inlineResponse20028Ingredients
      , "likes" .= inlineResponse20028Likes
      , "nutrition" .= inlineResponse20028Nutrition
      , "price" .= inlineResponse20028Price
      , "servings" .= inlineResponse20028Servings
      , "spoonacularScore" .= inlineResponse20028SpoonacularScore
      ]


-- | Construct a value of type 'InlineResponse20028' (by applying it's required fields, if any)
mkInlineResponse20028
  :: Int -- ^ 'inlineResponse20028Id' 
  -> Text -- ^ 'inlineResponse20028Title' 
  -> [Text] -- ^ 'inlineResponse20028Badges' 
  -> [Text] -- ^ 'inlineResponse20028ImportantBadges' 
  -> [Text] -- ^ 'inlineResponse20028Breadcrumbs' 
  -> Text -- ^ 'inlineResponse20028GeneratedText' 
  -> Text -- ^ 'inlineResponse20028ImageType' 
  -> Text -- ^ 'inlineResponse20028IngredientList' 
  -> [InlineResponse20028Ingredients] -- ^ 'inlineResponse20028Ingredients' 
  -> Double -- ^ 'inlineResponse20028Likes' 
  -> InlineResponse20028Nutrition -- ^ 'inlineResponse20028Nutrition' 
  -> Double -- ^ 'inlineResponse20028Price' 
  -> InlineResponse20028Servings -- ^ 'inlineResponse20028Servings' 
  -> Double -- ^ 'inlineResponse20028SpoonacularScore' 
  -> InlineResponse20028
mkInlineResponse20028 inlineResponse20028Id inlineResponse20028Title inlineResponse20028Badges inlineResponse20028ImportantBadges inlineResponse20028Breadcrumbs inlineResponse20028GeneratedText inlineResponse20028ImageType inlineResponse20028IngredientList inlineResponse20028Ingredients inlineResponse20028Likes inlineResponse20028Nutrition inlineResponse20028Price inlineResponse20028Servings inlineResponse20028SpoonacularScore =
  InlineResponse20028
  { inlineResponse20028Id
  , inlineResponse20028Title
  , inlineResponse20028Badges
  , inlineResponse20028ImportantBadges
  , inlineResponse20028Breadcrumbs
  , inlineResponse20028GeneratedText
  , inlineResponse20028ImageType
  , inlineResponse20028IngredientCount = Nothing
  , inlineResponse20028IngredientList
  , inlineResponse20028Ingredients
  , inlineResponse20028Likes
  , inlineResponse20028Nutrition
  , inlineResponse20028Price
  , inlineResponse20028Servings
  , inlineResponse20028SpoonacularScore
  }

-- ** InlineResponse20028Ingredients
-- | InlineResponse20028Ingredients
data InlineResponse20028Ingredients = InlineResponse20028Ingredients
  { inlineResponse20028IngredientsDescription :: !(Maybe A.Value) -- ^ "description"
  , inlineResponse20028IngredientsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20028IngredientsSafetyLevel :: !(Maybe A.Value) -- ^ "safety_level"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20028Ingredients
instance A.FromJSON InlineResponse20028Ingredients where
  parseJSON = A.withObject "InlineResponse20028Ingredients" $ \o ->
    InlineResponse20028Ingredients
      <$> (o .:? "description")
      <*> (o .:  "name")
      <*> (o .:? "safety_level")

-- | ToJSON InlineResponse20028Ingredients
instance A.ToJSON InlineResponse20028Ingredients where
  toJSON InlineResponse20028Ingredients {..} =
   _omitNulls
      [ "description" .= inlineResponse20028IngredientsDescription
      , "name" .= inlineResponse20028IngredientsName
      , "safety_level" .= inlineResponse20028IngredientsSafetyLevel
      ]


-- | Construct a value of type 'InlineResponse20028Ingredients' (by applying it's required fields, if any)
mkInlineResponse20028Ingredients
  :: Text -- ^ 'inlineResponse20028IngredientsName' 
  -> InlineResponse20028Ingredients
mkInlineResponse20028Ingredients inlineResponse20028IngredientsName =
  InlineResponse20028Ingredients
  { inlineResponse20028IngredientsDescription = Nothing
  , inlineResponse20028IngredientsName
  , inlineResponse20028IngredientsSafetyLevel = Nothing
  }

-- ** InlineResponse20028Nutrition
-- | InlineResponse20028Nutrition
data InlineResponse20028Nutrition = InlineResponse20028Nutrition
  { inlineResponse20028NutritionNutrients :: !([RecipesParseIngredientsNutritionNutrients]) -- ^ /Required/ "nutrients"
  , inlineResponse20028NutritionCaloricBreakdown :: !(RecipesParseIngredientsNutritionCaloricBreakdown) -- ^ /Required/ "caloricBreakdown"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20028Nutrition
instance A.FromJSON InlineResponse20028Nutrition where
  parseJSON = A.withObject "InlineResponse20028Nutrition" $ \o ->
    InlineResponse20028Nutrition
      <$> (o .:  "nutrients")
      <*> (o .:  "caloricBreakdown")

-- | ToJSON InlineResponse20028Nutrition
instance A.ToJSON InlineResponse20028Nutrition where
  toJSON InlineResponse20028Nutrition {..} =
   _omitNulls
      [ "nutrients" .= inlineResponse20028NutritionNutrients
      , "caloricBreakdown" .= inlineResponse20028NutritionCaloricBreakdown
      ]


-- | Construct a value of type 'InlineResponse20028Nutrition' (by applying it's required fields, if any)
mkInlineResponse20028Nutrition
  :: [RecipesParseIngredientsNutritionNutrients] -- ^ 'inlineResponse20028NutritionNutrients' 
  -> RecipesParseIngredientsNutritionCaloricBreakdown -- ^ 'inlineResponse20028NutritionCaloricBreakdown' 
  -> InlineResponse20028Nutrition
mkInlineResponse20028Nutrition inlineResponse20028NutritionNutrients inlineResponse20028NutritionCaloricBreakdown =
  InlineResponse20028Nutrition
  { inlineResponse20028NutritionNutrients
  , inlineResponse20028NutritionCaloricBreakdown
  }

-- ** InlineResponse20028Servings
-- | InlineResponse20028Servings
data InlineResponse20028Servings = InlineResponse20028Servings
  { inlineResponse20028ServingsNumber :: !(Double) -- ^ /Required/ "number"
  , inlineResponse20028ServingsSize :: !(Double) -- ^ /Required/ "size"
  , inlineResponse20028ServingsUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20028Servings
instance A.FromJSON InlineResponse20028Servings where
  parseJSON = A.withObject "InlineResponse20028Servings" $ \o ->
    InlineResponse20028Servings
      <$> (o .:  "number")
      <*> (o .:  "size")
      <*> (o .:  "unit")

-- | ToJSON InlineResponse20028Servings
instance A.ToJSON InlineResponse20028Servings where
  toJSON InlineResponse20028Servings {..} =
   _omitNulls
      [ "number" .= inlineResponse20028ServingsNumber
      , "size" .= inlineResponse20028ServingsSize
      , "unit" .= inlineResponse20028ServingsUnit
      ]


-- | Construct a value of type 'InlineResponse20028Servings' (by applying it's required fields, if any)
mkInlineResponse20028Servings
  :: Double -- ^ 'inlineResponse20028ServingsNumber' 
  -> Double -- ^ 'inlineResponse20028ServingsSize' 
  -> Text -- ^ 'inlineResponse20028ServingsUnit' 
  -> InlineResponse20028Servings
mkInlineResponse20028Servings inlineResponse20028ServingsNumber inlineResponse20028ServingsSize inlineResponse20028ServingsUnit =
  InlineResponse20028Servings
  { inlineResponse20028ServingsNumber
  , inlineResponse20028ServingsSize
  , inlineResponse20028ServingsUnit
  }

-- ** InlineResponse20029
-- | InlineResponse20029
data InlineResponse20029 = InlineResponse20029
  { inlineResponse20029CustomFoods :: !([InlineResponse20029CustomFoods]) -- ^ /Required/ "customFoods"
  , inlineResponse20029Type :: !(Text) -- ^ /Required/ "type"
  , inlineResponse20029Offset :: !(Int) -- ^ /Required/ "offset"
  , inlineResponse20029Number :: !(Int) -- ^ /Required/ "number"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20029
instance A.FromJSON InlineResponse20029 where
  parseJSON = A.withObject "InlineResponse20029" $ \o ->
    InlineResponse20029
      <$> (o .:  "customFoods")
      <*> (o .:  "type")
      <*> (o .:  "offset")
      <*> (o .:  "number")

-- | ToJSON InlineResponse20029
instance A.ToJSON InlineResponse20029 where
  toJSON InlineResponse20029 {..} =
   _omitNulls
      [ "customFoods" .= inlineResponse20029CustomFoods
      , "type" .= inlineResponse20029Type
      , "offset" .= inlineResponse20029Offset
      , "number" .= inlineResponse20029Number
      ]


-- | Construct a value of type 'InlineResponse20029' (by applying it's required fields, if any)
mkInlineResponse20029
  :: [InlineResponse20029CustomFoods] -- ^ 'inlineResponse20029CustomFoods' 
  -> Text -- ^ 'inlineResponse20029Type' 
  -> Int -- ^ 'inlineResponse20029Offset' 
  -> Int -- ^ 'inlineResponse20029Number' 
  -> InlineResponse20029
mkInlineResponse20029 inlineResponse20029CustomFoods inlineResponse20029Type inlineResponse20029Offset inlineResponse20029Number =
  InlineResponse20029
  { inlineResponse20029CustomFoods
  , inlineResponse20029Type
  , inlineResponse20029Offset
  , inlineResponse20029Number
  }

-- ** InlineResponse20029CustomFoods
-- | InlineResponse20029CustomFoods
data InlineResponse20029CustomFoods = InlineResponse20029CustomFoods
  { inlineResponse20029CustomFoodsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20029CustomFoodsTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20029CustomFoodsServings :: !(Double) -- ^ /Required/ "servings"
  , inlineResponse20029CustomFoodsImageUrl :: !(Text) -- ^ /Required/ "imageUrl"
  , inlineResponse20029CustomFoodsPrice :: !(Double) -- ^ /Required/ "price"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20029CustomFoods
instance A.FromJSON InlineResponse20029CustomFoods where
  parseJSON = A.withObject "InlineResponse20029CustomFoods" $ \o ->
    InlineResponse20029CustomFoods
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "servings")
      <*> (o .:  "imageUrl")
      <*> (o .:  "price")

-- | ToJSON InlineResponse20029CustomFoods
instance A.ToJSON InlineResponse20029CustomFoods where
  toJSON InlineResponse20029CustomFoods {..} =
   _omitNulls
      [ "id" .= inlineResponse20029CustomFoodsId
      , "title" .= inlineResponse20029CustomFoodsTitle
      , "servings" .= inlineResponse20029CustomFoodsServings
      , "imageUrl" .= inlineResponse20029CustomFoodsImageUrl
      , "price" .= inlineResponse20029CustomFoodsPrice
      ]


-- | Construct a value of type 'InlineResponse20029CustomFoods' (by applying it's required fields, if any)
mkInlineResponse20029CustomFoods
  :: Int -- ^ 'inlineResponse20029CustomFoodsId' 
  -> Text -- ^ 'inlineResponse20029CustomFoodsTitle' 
  -> Double -- ^ 'inlineResponse20029CustomFoodsServings' 
  -> Text -- ^ 'inlineResponse20029CustomFoodsImageUrl' 
  -> Double -- ^ 'inlineResponse20029CustomFoodsPrice' 
  -> InlineResponse20029CustomFoods
mkInlineResponse20029CustomFoods inlineResponse20029CustomFoodsId inlineResponse20029CustomFoodsTitle inlineResponse20029CustomFoodsServings inlineResponse20029CustomFoodsImageUrl inlineResponse20029CustomFoodsPrice =
  InlineResponse20029CustomFoods
  { inlineResponse20029CustomFoodsId
  , inlineResponse20029CustomFoodsTitle
  , inlineResponse20029CustomFoodsServings
  , inlineResponse20029CustomFoodsImageUrl
  , inlineResponse20029CustomFoodsPrice
  }

-- ** InlineResponse2003
-- | InlineResponse2003
data InlineResponse2003 = InlineResponse2003
  { inlineResponse2003Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2003Title :: !(Text) -- ^ /Required/ "title"
  , inlineResponse2003Image :: !(Text) -- ^ /Required/ "image"
  , inlineResponse2003ImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse2003Servings :: !(Double) -- ^ /Required/ "servings"
  , inlineResponse2003ReadyInMinutes :: !(Int) -- ^ /Required/ "readyInMinutes"
  , inlineResponse2003License :: !(Text) -- ^ /Required/ "license"
  , inlineResponse2003SourceName :: !(Text) -- ^ /Required/ "sourceName"
  , inlineResponse2003SourceUrl :: !(Text) -- ^ /Required/ "sourceUrl"
  , inlineResponse2003SpoonacularSourceUrl :: !(Text) -- ^ /Required/ "spoonacularSourceUrl"
  , inlineResponse2003AggregateLikes :: !(Int) -- ^ /Required/ "aggregateLikes"
  , inlineResponse2003HealthScore :: !(Double) -- ^ /Required/ "healthScore"
  , inlineResponse2003SpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  , inlineResponse2003PricePerServing :: !(Double) -- ^ /Required/ "pricePerServing"
  , inlineResponse2003AnalyzedInstructions :: !([A.Value]) -- ^ /Required/ "analyzedInstructions"
  , inlineResponse2003Cheap :: !(Bool) -- ^ /Required/ "cheap"
  , inlineResponse2003CreditsText :: !(Text) -- ^ /Required/ "creditsText"
  , inlineResponse2003Cuisines :: !([Text]) -- ^ /Required/ "cuisines"
  , inlineResponse2003DairyFree :: !(Bool) -- ^ /Required/ "dairyFree"
  , inlineResponse2003Diets :: !([Text]) -- ^ /Required/ "diets"
  , inlineResponse2003Gaps :: !(Text) -- ^ /Required/ "gaps"
  , inlineResponse2003GlutenFree :: !(Bool) -- ^ /Required/ "glutenFree"
  , inlineResponse2003Instructions :: !(Text) -- ^ /Required/ "instructions"
  , inlineResponse2003Ketogenic :: !(Bool) -- ^ /Required/ "ketogenic"
  , inlineResponse2003LowFodmap :: !(Bool) -- ^ /Required/ "lowFodmap"
  , inlineResponse2003Occasions :: !([Text]) -- ^ /Required/ "occasions"
  , inlineResponse2003Sustainable :: !(Bool) -- ^ /Required/ "sustainable"
  , inlineResponse2003Vegan :: !(Bool) -- ^ /Required/ "vegan"
  , inlineResponse2003Vegetarian :: !(Bool) -- ^ /Required/ "vegetarian"
  , inlineResponse2003VeryHealthy :: !(Bool) -- ^ /Required/ "veryHealthy"
  , inlineResponse2003VeryPopular :: !(Bool) -- ^ /Required/ "veryPopular"
  , inlineResponse2003Whole30 :: !(Bool) -- ^ /Required/ "whole30"
  , inlineResponse2003WeightWatcherSmartPoints :: !(Double) -- ^ /Required/ "weightWatcherSmartPoints"
  , inlineResponse2003DishTypes :: !([Text]) -- ^ /Required/ "dishTypes"
  , inlineResponse2003ExtendedIngredients :: !([InlineResponse2003ExtendedIngredients]) -- ^ /Required/ "extendedIngredients"
  , inlineResponse2003Summary :: !(Text) -- ^ /Required/ "summary"
  , inlineResponse2003WinePairing :: !(InlineResponse2003WinePairing) -- ^ /Required/ "winePairing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003
instance A.FromJSON InlineResponse2003 where
  parseJSON = A.withObject "InlineResponse2003" $ \o ->
    InlineResponse2003
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "servings")
      <*> (o .:  "readyInMinutes")
      <*> (o .:  "license")
      <*> (o .:  "sourceName")
      <*> (o .:  "sourceUrl")
      <*> (o .:  "spoonacularSourceUrl")
      <*> (o .:  "aggregateLikes")
      <*> (o .:  "healthScore")
      <*> (o .:  "spoonacularScore")
      <*> (o .:  "pricePerServing")
      <*> (o .:  "analyzedInstructions")
      <*> (o .:  "cheap")
      <*> (o .:  "creditsText")
      <*> (o .:  "cuisines")
      <*> (o .:  "dairyFree")
      <*> (o .:  "diets")
      <*> (o .:  "gaps")
      <*> (o .:  "glutenFree")
      <*> (o .:  "instructions")
      <*> (o .:  "ketogenic")
      <*> (o .:  "lowFodmap")
      <*> (o .:  "occasions")
      <*> (o .:  "sustainable")
      <*> (o .:  "vegan")
      <*> (o .:  "vegetarian")
      <*> (o .:  "veryHealthy")
      <*> (o .:  "veryPopular")
      <*> (o .:  "whole30")
      <*> (o .:  "weightWatcherSmartPoints")
      <*> (o .:  "dishTypes")
      <*> (o .:  "extendedIngredients")
      <*> (o .:  "summary")
      <*> (o .:  "winePairing")

-- | ToJSON InlineResponse2003
instance A.ToJSON InlineResponse2003 where
  toJSON InlineResponse2003 {..} =
   _omitNulls
      [ "id" .= inlineResponse2003Id
      , "title" .= inlineResponse2003Title
      , "image" .= inlineResponse2003Image
      , "imageType" .= inlineResponse2003ImageType
      , "servings" .= inlineResponse2003Servings
      , "readyInMinutes" .= inlineResponse2003ReadyInMinutes
      , "license" .= inlineResponse2003License
      , "sourceName" .= inlineResponse2003SourceName
      , "sourceUrl" .= inlineResponse2003SourceUrl
      , "spoonacularSourceUrl" .= inlineResponse2003SpoonacularSourceUrl
      , "aggregateLikes" .= inlineResponse2003AggregateLikes
      , "healthScore" .= inlineResponse2003HealthScore
      , "spoonacularScore" .= inlineResponse2003SpoonacularScore
      , "pricePerServing" .= inlineResponse2003PricePerServing
      , "analyzedInstructions" .= inlineResponse2003AnalyzedInstructions
      , "cheap" .= inlineResponse2003Cheap
      , "creditsText" .= inlineResponse2003CreditsText
      , "cuisines" .= inlineResponse2003Cuisines
      , "dairyFree" .= inlineResponse2003DairyFree
      , "diets" .= inlineResponse2003Diets
      , "gaps" .= inlineResponse2003Gaps
      , "glutenFree" .= inlineResponse2003GlutenFree
      , "instructions" .= inlineResponse2003Instructions
      , "ketogenic" .= inlineResponse2003Ketogenic
      , "lowFodmap" .= inlineResponse2003LowFodmap
      , "occasions" .= inlineResponse2003Occasions
      , "sustainable" .= inlineResponse2003Sustainable
      , "vegan" .= inlineResponse2003Vegan
      , "vegetarian" .= inlineResponse2003Vegetarian
      , "veryHealthy" .= inlineResponse2003VeryHealthy
      , "veryPopular" .= inlineResponse2003VeryPopular
      , "whole30" .= inlineResponse2003Whole30
      , "weightWatcherSmartPoints" .= inlineResponse2003WeightWatcherSmartPoints
      , "dishTypes" .= inlineResponse2003DishTypes
      , "extendedIngredients" .= inlineResponse2003ExtendedIngredients
      , "summary" .= inlineResponse2003Summary
      , "winePairing" .= inlineResponse2003WinePairing
      ]


-- | Construct a value of type 'InlineResponse2003' (by applying it's required fields, if any)
mkInlineResponse2003
  :: Int -- ^ 'inlineResponse2003Id' 
  -> Text -- ^ 'inlineResponse2003Title' 
  -> Text -- ^ 'inlineResponse2003Image' 
  -> Text -- ^ 'inlineResponse2003ImageType' 
  -> Double -- ^ 'inlineResponse2003Servings' 
  -> Int -- ^ 'inlineResponse2003ReadyInMinutes' 
  -> Text -- ^ 'inlineResponse2003License' 
  -> Text -- ^ 'inlineResponse2003SourceName' 
  -> Text -- ^ 'inlineResponse2003SourceUrl' 
  -> Text -- ^ 'inlineResponse2003SpoonacularSourceUrl' 
  -> Int -- ^ 'inlineResponse2003AggregateLikes' 
  -> Double -- ^ 'inlineResponse2003HealthScore' 
  -> Double -- ^ 'inlineResponse2003SpoonacularScore' 
  -> Double -- ^ 'inlineResponse2003PricePerServing' 
  -> [A.Value] -- ^ 'inlineResponse2003AnalyzedInstructions' 
  -> Bool -- ^ 'inlineResponse2003Cheap' 
  -> Text -- ^ 'inlineResponse2003CreditsText' 
  -> [Text] -- ^ 'inlineResponse2003Cuisines' 
  -> Bool -- ^ 'inlineResponse2003DairyFree' 
  -> [Text] -- ^ 'inlineResponse2003Diets' 
  -> Text -- ^ 'inlineResponse2003Gaps' 
  -> Bool -- ^ 'inlineResponse2003GlutenFree' 
  -> Text -- ^ 'inlineResponse2003Instructions' 
  -> Bool -- ^ 'inlineResponse2003Ketogenic' 
  -> Bool -- ^ 'inlineResponse2003LowFodmap' 
  -> [Text] -- ^ 'inlineResponse2003Occasions' 
  -> Bool -- ^ 'inlineResponse2003Sustainable' 
  -> Bool -- ^ 'inlineResponse2003Vegan' 
  -> Bool -- ^ 'inlineResponse2003Vegetarian' 
  -> Bool -- ^ 'inlineResponse2003VeryHealthy' 
  -> Bool -- ^ 'inlineResponse2003VeryPopular' 
  -> Bool -- ^ 'inlineResponse2003Whole30' 
  -> Double -- ^ 'inlineResponse2003WeightWatcherSmartPoints' 
  -> [Text] -- ^ 'inlineResponse2003DishTypes' 
  -> [InlineResponse2003ExtendedIngredients] -- ^ 'inlineResponse2003ExtendedIngredients' 
  -> Text -- ^ 'inlineResponse2003Summary' 
  -> InlineResponse2003WinePairing -- ^ 'inlineResponse2003WinePairing' 
  -> InlineResponse2003
mkInlineResponse2003 inlineResponse2003Id inlineResponse2003Title inlineResponse2003Image inlineResponse2003ImageType inlineResponse2003Servings inlineResponse2003ReadyInMinutes inlineResponse2003License inlineResponse2003SourceName inlineResponse2003SourceUrl inlineResponse2003SpoonacularSourceUrl inlineResponse2003AggregateLikes inlineResponse2003HealthScore inlineResponse2003SpoonacularScore inlineResponse2003PricePerServing inlineResponse2003AnalyzedInstructions inlineResponse2003Cheap inlineResponse2003CreditsText inlineResponse2003Cuisines inlineResponse2003DairyFree inlineResponse2003Diets inlineResponse2003Gaps inlineResponse2003GlutenFree inlineResponse2003Instructions inlineResponse2003Ketogenic inlineResponse2003LowFodmap inlineResponse2003Occasions inlineResponse2003Sustainable inlineResponse2003Vegan inlineResponse2003Vegetarian inlineResponse2003VeryHealthy inlineResponse2003VeryPopular inlineResponse2003Whole30 inlineResponse2003WeightWatcherSmartPoints inlineResponse2003DishTypes inlineResponse2003ExtendedIngredients inlineResponse2003Summary inlineResponse2003WinePairing =
  InlineResponse2003
  { inlineResponse2003Id
  , inlineResponse2003Title
  , inlineResponse2003Image
  , inlineResponse2003ImageType
  , inlineResponse2003Servings
  , inlineResponse2003ReadyInMinutes
  , inlineResponse2003License
  , inlineResponse2003SourceName
  , inlineResponse2003SourceUrl
  , inlineResponse2003SpoonacularSourceUrl
  , inlineResponse2003AggregateLikes
  , inlineResponse2003HealthScore
  , inlineResponse2003SpoonacularScore
  , inlineResponse2003PricePerServing
  , inlineResponse2003AnalyzedInstructions
  , inlineResponse2003Cheap
  , inlineResponse2003CreditsText
  , inlineResponse2003Cuisines
  , inlineResponse2003DairyFree
  , inlineResponse2003Diets
  , inlineResponse2003Gaps
  , inlineResponse2003GlutenFree
  , inlineResponse2003Instructions
  , inlineResponse2003Ketogenic
  , inlineResponse2003LowFodmap
  , inlineResponse2003Occasions
  , inlineResponse2003Sustainable
  , inlineResponse2003Vegan
  , inlineResponse2003Vegetarian
  , inlineResponse2003VeryHealthy
  , inlineResponse2003VeryPopular
  , inlineResponse2003Whole30
  , inlineResponse2003WeightWatcherSmartPoints
  , inlineResponse2003DishTypes
  , inlineResponse2003ExtendedIngredients
  , inlineResponse2003Summary
  , inlineResponse2003WinePairing
  }

-- ** InlineResponse20030
-- | InlineResponse20030
data InlineResponse20030 = InlineResponse20030
  { inlineResponse20030Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20030Title :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20030Breadcrumbs :: !([Text]) -- ^ /Required/ "breadcrumbs"
  , inlineResponse20030ImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse20030Badges :: !([Text]) -- ^ /Required/ "badges"
  , inlineResponse20030ImportantBadges :: !([Text]) -- ^ /Required/ "importantBadges"
  , inlineResponse20030IngredientCount :: !(Int) -- ^ /Required/ "ingredientCount"
  , inlineResponse20030GeneratedText :: !(Maybe A.Value) -- ^ "generatedText"
  , inlineResponse20030IngredientList :: !(Text) -- ^ /Required/ "ingredientList"
  , inlineResponse20030Ingredients :: !([InlineResponse20030Ingredients]) -- ^ /Required/ "ingredients"
  , inlineResponse20030Likes :: !(Double) -- ^ /Required/ "likes"
  , inlineResponse20030Aisle :: !(Text) -- ^ /Required/ "aisle"
  , inlineResponse20030Nutrition :: !(InlineResponse20028Nutrition) -- ^ /Required/ "nutrition"
  , inlineResponse20030Price :: !(Double) -- ^ /Required/ "price"
  , inlineResponse20030Servings :: !(InlineResponse20028Servings) -- ^ /Required/ "servings"
  , inlineResponse20030SpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20030
instance A.FromJSON InlineResponse20030 where
  parseJSON = A.withObject "InlineResponse20030" $ \o ->
    InlineResponse20030
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "breadcrumbs")
      <*> (o .:  "imageType")
      <*> (o .:  "badges")
      <*> (o .:  "importantBadges")
      <*> (o .:  "ingredientCount")
      <*> (o .:? "generatedText")
      <*> (o .:  "ingredientList")
      <*> (o .:  "ingredients")
      <*> (o .:  "likes")
      <*> (o .:  "aisle")
      <*> (o .:  "nutrition")
      <*> (o .:  "price")
      <*> (o .:  "servings")
      <*> (o .:  "spoonacularScore")

-- | ToJSON InlineResponse20030
instance A.ToJSON InlineResponse20030 where
  toJSON InlineResponse20030 {..} =
   _omitNulls
      [ "id" .= inlineResponse20030Id
      , "title" .= inlineResponse20030Title
      , "breadcrumbs" .= inlineResponse20030Breadcrumbs
      , "imageType" .= inlineResponse20030ImageType
      , "badges" .= inlineResponse20030Badges
      , "importantBadges" .= inlineResponse20030ImportantBadges
      , "ingredientCount" .= inlineResponse20030IngredientCount
      , "generatedText" .= inlineResponse20030GeneratedText
      , "ingredientList" .= inlineResponse20030IngredientList
      , "ingredients" .= inlineResponse20030Ingredients
      , "likes" .= inlineResponse20030Likes
      , "aisle" .= inlineResponse20030Aisle
      , "nutrition" .= inlineResponse20030Nutrition
      , "price" .= inlineResponse20030Price
      , "servings" .= inlineResponse20030Servings
      , "spoonacularScore" .= inlineResponse20030SpoonacularScore
      ]


-- | Construct a value of type 'InlineResponse20030' (by applying it's required fields, if any)
mkInlineResponse20030
  :: Int -- ^ 'inlineResponse20030Id' 
  -> Text -- ^ 'inlineResponse20030Title' 
  -> [Text] -- ^ 'inlineResponse20030Breadcrumbs' 
  -> Text -- ^ 'inlineResponse20030ImageType' 
  -> [Text] -- ^ 'inlineResponse20030Badges' 
  -> [Text] -- ^ 'inlineResponse20030ImportantBadges' 
  -> Int -- ^ 'inlineResponse20030IngredientCount' 
  -> Text -- ^ 'inlineResponse20030IngredientList' 
  -> [InlineResponse20030Ingredients] -- ^ 'inlineResponse20030Ingredients' 
  -> Double -- ^ 'inlineResponse20030Likes' 
  -> Text -- ^ 'inlineResponse20030Aisle' 
  -> InlineResponse20028Nutrition -- ^ 'inlineResponse20030Nutrition' 
  -> Double -- ^ 'inlineResponse20030Price' 
  -> InlineResponse20028Servings -- ^ 'inlineResponse20030Servings' 
  -> Double -- ^ 'inlineResponse20030SpoonacularScore' 
  -> InlineResponse20030
mkInlineResponse20030 inlineResponse20030Id inlineResponse20030Title inlineResponse20030Breadcrumbs inlineResponse20030ImageType inlineResponse20030Badges inlineResponse20030ImportantBadges inlineResponse20030IngredientCount inlineResponse20030IngredientList inlineResponse20030Ingredients inlineResponse20030Likes inlineResponse20030Aisle inlineResponse20030Nutrition inlineResponse20030Price inlineResponse20030Servings inlineResponse20030SpoonacularScore =
  InlineResponse20030
  { inlineResponse20030Id
  , inlineResponse20030Title
  , inlineResponse20030Breadcrumbs
  , inlineResponse20030ImageType
  , inlineResponse20030Badges
  , inlineResponse20030ImportantBadges
  , inlineResponse20030IngredientCount
  , inlineResponse20030GeneratedText = Nothing
  , inlineResponse20030IngredientList
  , inlineResponse20030Ingredients
  , inlineResponse20030Likes
  , inlineResponse20030Aisle
  , inlineResponse20030Nutrition
  , inlineResponse20030Price
  , inlineResponse20030Servings
  , inlineResponse20030SpoonacularScore
  }

-- ** InlineResponse20030Ingredients
-- | InlineResponse20030Ingredients
data InlineResponse20030Ingredients = InlineResponse20030Ingredients
  { inlineResponse20030IngredientsDescription :: !(Maybe A.Value) -- ^ "description"
  , inlineResponse20030IngredientsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20030IngredientsSafetyLevel :: !(Maybe A.Value) -- ^ "safety_level"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20030Ingredients
instance A.FromJSON InlineResponse20030Ingredients where
  parseJSON = A.withObject "InlineResponse20030Ingredients" $ \o ->
    InlineResponse20030Ingredients
      <$> (o .:? "description")
      <*> (o .:  "name")
      <*> (o .:? "safety_level")

-- | ToJSON InlineResponse20030Ingredients
instance A.ToJSON InlineResponse20030Ingredients where
  toJSON InlineResponse20030Ingredients {..} =
   _omitNulls
      [ "description" .= inlineResponse20030IngredientsDescription
      , "name" .= inlineResponse20030IngredientsName
      , "safety_level" .= inlineResponse20030IngredientsSafetyLevel
      ]


-- | Construct a value of type 'InlineResponse20030Ingredients' (by applying it's required fields, if any)
mkInlineResponse20030Ingredients
  :: Text -- ^ 'inlineResponse20030IngredientsName' 
  -> InlineResponse20030Ingredients
mkInlineResponse20030Ingredients inlineResponse20030IngredientsName =
  InlineResponse20030Ingredients
  { inlineResponse20030IngredientsDescription = Nothing
  , inlineResponse20030IngredientsName
  , inlineResponse20030IngredientsSafetyLevel = Nothing
  }

-- ** InlineResponse20031
-- | InlineResponse20031
data InlineResponse20031 = InlineResponse20031
  { inlineResponse20031ComparableProducts :: !(InlineResponse20031ComparableProducts) -- ^ /Required/ "comparableProducts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20031
instance A.FromJSON InlineResponse20031 where
  parseJSON = A.withObject "InlineResponse20031" $ \o ->
    InlineResponse20031
      <$> (o .:  "comparableProducts")

-- | ToJSON InlineResponse20031
instance A.ToJSON InlineResponse20031 where
  toJSON InlineResponse20031 {..} =
   _omitNulls
      [ "comparableProducts" .= inlineResponse20031ComparableProducts
      ]


-- | Construct a value of type 'InlineResponse20031' (by applying it's required fields, if any)
mkInlineResponse20031
  :: InlineResponse20031ComparableProducts -- ^ 'inlineResponse20031ComparableProducts' 
  -> InlineResponse20031
mkInlineResponse20031 inlineResponse20031ComparableProducts =
  InlineResponse20031
  { inlineResponse20031ComparableProducts
  }

-- ** InlineResponse20031ComparableProducts
-- | InlineResponse20031ComparableProducts
data InlineResponse20031ComparableProducts = InlineResponse20031ComparableProducts
  { inlineResponse20031ComparableProductsCalories :: !([A.Value]) -- ^ /Required/ "calories"
  , inlineResponse20031ComparableProductsLikes :: !([A.Value]) -- ^ /Required/ "likes"
  , inlineResponse20031ComparableProductsPrice :: !([A.Value]) -- ^ /Required/ "price"
  , inlineResponse20031ComparableProductsProtein :: !([InlineResponse20031ComparableProductsProtein]) -- ^ /Required/ "protein"
  , inlineResponse20031ComparableProductsSpoonacularScore :: !([InlineResponse20031ComparableProductsProtein]) -- ^ /Required/ "spoonacularScore"
  , inlineResponse20031ComparableProductsSugar :: !([A.Value]) -- ^ /Required/ "sugar"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20031ComparableProducts
instance A.FromJSON InlineResponse20031ComparableProducts where
  parseJSON = A.withObject "InlineResponse20031ComparableProducts" $ \o ->
    InlineResponse20031ComparableProducts
      <$> (o .:  "calories")
      <*> (o .:  "likes")
      <*> (o .:  "price")
      <*> (o .:  "protein")
      <*> (o .:  "spoonacularScore")
      <*> (o .:  "sugar")

-- | ToJSON InlineResponse20031ComparableProducts
instance A.ToJSON InlineResponse20031ComparableProducts where
  toJSON InlineResponse20031ComparableProducts {..} =
   _omitNulls
      [ "calories" .= inlineResponse20031ComparableProductsCalories
      , "likes" .= inlineResponse20031ComparableProductsLikes
      , "price" .= inlineResponse20031ComparableProductsPrice
      , "protein" .= inlineResponse20031ComparableProductsProtein
      , "spoonacularScore" .= inlineResponse20031ComparableProductsSpoonacularScore
      , "sugar" .= inlineResponse20031ComparableProductsSugar
      ]


-- | Construct a value of type 'InlineResponse20031ComparableProducts' (by applying it's required fields, if any)
mkInlineResponse20031ComparableProducts
  :: [A.Value] -- ^ 'inlineResponse20031ComparableProductsCalories' 
  -> [A.Value] -- ^ 'inlineResponse20031ComparableProductsLikes' 
  -> [A.Value] -- ^ 'inlineResponse20031ComparableProductsPrice' 
  -> [InlineResponse20031ComparableProductsProtein] -- ^ 'inlineResponse20031ComparableProductsProtein' 
  -> [InlineResponse20031ComparableProductsProtein] -- ^ 'inlineResponse20031ComparableProductsSpoonacularScore' 
  -> [A.Value] -- ^ 'inlineResponse20031ComparableProductsSugar' 
  -> InlineResponse20031ComparableProducts
mkInlineResponse20031ComparableProducts inlineResponse20031ComparableProductsCalories inlineResponse20031ComparableProductsLikes inlineResponse20031ComparableProductsPrice inlineResponse20031ComparableProductsProtein inlineResponse20031ComparableProductsSpoonacularScore inlineResponse20031ComparableProductsSugar =
  InlineResponse20031ComparableProducts
  { inlineResponse20031ComparableProductsCalories
  , inlineResponse20031ComparableProductsLikes
  , inlineResponse20031ComparableProductsPrice
  , inlineResponse20031ComparableProductsProtein
  , inlineResponse20031ComparableProductsSpoonacularScore
  , inlineResponse20031ComparableProductsSugar
  }

-- ** InlineResponse20031ComparableProductsProtein
-- | InlineResponse20031ComparableProductsProtein
data InlineResponse20031ComparableProductsProtein = InlineResponse20031ComparableProductsProtein
  { inlineResponse20031ComparableProductsProteinDifference :: !(Double) -- ^ /Required/ "difference"
  , inlineResponse20031ComparableProductsProteinId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20031ComparableProductsProteinImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20031ComparableProductsProteinTitle :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20031ComparableProductsProtein
instance A.FromJSON InlineResponse20031ComparableProductsProtein where
  parseJSON = A.withObject "InlineResponse20031ComparableProductsProtein" $ \o ->
    InlineResponse20031ComparableProductsProtein
      <$> (o .:  "difference")
      <*> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:  "title")

-- | ToJSON InlineResponse20031ComparableProductsProtein
instance A.ToJSON InlineResponse20031ComparableProductsProtein where
  toJSON InlineResponse20031ComparableProductsProtein {..} =
   _omitNulls
      [ "difference" .= inlineResponse20031ComparableProductsProteinDifference
      , "id" .= inlineResponse20031ComparableProductsProteinId
      , "image" .= inlineResponse20031ComparableProductsProteinImage
      , "title" .= inlineResponse20031ComparableProductsProteinTitle
      ]


-- | Construct a value of type 'InlineResponse20031ComparableProductsProtein' (by applying it's required fields, if any)
mkInlineResponse20031ComparableProductsProtein
  :: Double -- ^ 'inlineResponse20031ComparableProductsProteinDifference' 
  -> Int -- ^ 'inlineResponse20031ComparableProductsProteinId' 
  -> Text -- ^ 'inlineResponse20031ComparableProductsProteinImage' 
  -> Text -- ^ 'inlineResponse20031ComparableProductsProteinTitle' 
  -> InlineResponse20031ComparableProductsProtein
mkInlineResponse20031ComparableProductsProtein inlineResponse20031ComparableProductsProteinDifference inlineResponse20031ComparableProductsProteinId inlineResponse20031ComparableProductsProteinImage inlineResponse20031ComparableProductsProteinTitle =
  InlineResponse20031ComparableProductsProtein
  { inlineResponse20031ComparableProductsProteinDifference
  , inlineResponse20031ComparableProductsProteinId
  , inlineResponse20031ComparableProductsProteinImage
  , inlineResponse20031ComparableProductsProteinTitle
  }

-- ** InlineResponse20032
-- | InlineResponse20032
data InlineResponse20032 = InlineResponse20032
  { inlineResponse20032Results :: !([InlineResponse20032Results]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20032
instance A.FromJSON InlineResponse20032 where
  parseJSON = A.withObject "InlineResponse20032" $ \o ->
    InlineResponse20032
      <$> (o .:  "results")

-- | ToJSON InlineResponse20032
instance A.ToJSON InlineResponse20032 where
  toJSON InlineResponse20032 {..} =
   _omitNulls
      [ "results" .= inlineResponse20032Results
      ]


-- | Construct a value of type 'InlineResponse20032' (by applying it's required fields, if any)
mkInlineResponse20032
  :: [InlineResponse20032Results] -- ^ 'inlineResponse20032Results' 
  -> InlineResponse20032
mkInlineResponse20032 inlineResponse20032Results =
  InlineResponse20032
  { inlineResponse20032Results
  }

-- ** InlineResponse20032Results
-- | InlineResponse20032Results
data InlineResponse20032Results = InlineResponse20032Results
  { inlineResponse20032ResultsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20032ResultsTitle :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20032Results
instance A.FromJSON InlineResponse20032Results where
  parseJSON = A.withObject "InlineResponse20032Results" $ \o ->
    InlineResponse20032Results
      <$> (o .:  "id")
      <*> (o .:  "title")

-- | ToJSON InlineResponse20032Results
instance A.ToJSON InlineResponse20032Results where
  toJSON InlineResponse20032Results {..} =
   _omitNulls
      [ "id" .= inlineResponse20032ResultsId
      , "title" .= inlineResponse20032ResultsTitle
      ]


-- | Construct a value of type 'InlineResponse20032Results' (by applying it's required fields, if any)
mkInlineResponse20032Results
  :: Int -- ^ 'inlineResponse20032ResultsId' 
  -> Text -- ^ 'inlineResponse20032ResultsTitle' 
  -> InlineResponse20032Results
mkInlineResponse20032Results inlineResponse20032ResultsId inlineResponse20032ResultsTitle =
  InlineResponse20032Results
  { inlineResponse20032ResultsId
  , inlineResponse20032ResultsTitle
  }

-- ** InlineResponse20033
-- | InlineResponse20033
data InlineResponse20033 = InlineResponse20033
  { inlineResponse20033CleanTitle :: !(Text) -- ^ /Required/ "cleanTitle"
  , inlineResponse20033Image :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20033Category :: !(Text) -- ^ /Required/ "category"
  , inlineResponse20033Breadcrumbs :: !([Text]) -- ^ /Required/ "breadcrumbs"
  , inlineResponse20033UsdaCode :: !(Int) -- ^ /Required/ "usdaCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20033
instance A.FromJSON InlineResponse20033 where
  parseJSON = A.withObject "InlineResponse20033" $ \o ->
    InlineResponse20033
      <$> (o .:  "cleanTitle")
      <*> (o .:  "image")
      <*> (o .:  "category")
      <*> (o .:  "breadcrumbs")
      <*> (o .:  "usdaCode")

-- | ToJSON InlineResponse20033
instance A.ToJSON InlineResponse20033 where
  toJSON InlineResponse20033 {..} =
   _omitNulls
      [ "cleanTitle" .= inlineResponse20033CleanTitle
      , "image" .= inlineResponse20033Image
      , "category" .= inlineResponse20033Category
      , "breadcrumbs" .= inlineResponse20033Breadcrumbs
      , "usdaCode" .= inlineResponse20033UsdaCode
      ]


-- | Construct a value of type 'InlineResponse20033' (by applying it's required fields, if any)
mkInlineResponse20033
  :: Text -- ^ 'inlineResponse20033CleanTitle' 
  -> Text -- ^ 'inlineResponse20033Image' 
  -> Text -- ^ 'inlineResponse20033Category' 
  -> [Text] -- ^ 'inlineResponse20033Breadcrumbs' 
  -> Int -- ^ 'inlineResponse20033UsdaCode' 
  -> InlineResponse20033
mkInlineResponse20033 inlineResponse20033CleanTitle inlineResponse20033Image inlineResponse20033Category inlineResponse20033Breadcrumbs inlineResponse20033UsdaCode =
  InlineResponse20033
  { inlineResponse20033CleanTitle
  , inlineResponse20033Image
  , inlineResponse20033Category
  , inlineResponse20033Breadcrumbs
  , inlineResponse20033UsdaCode
  }

-- ** InlineResponse20034
-- | InlineResponse20034
data InlineResponse20034 = InlineResponse20034
  { inlineResponse20034Original :: !(Text) -- ^ /Required/ "original"
  , inlineResponse20034OriginalName :: !(Text) -- ^ /Required/ "originalName"
  , inlineResponse20034IngredientImage :: !(Text) -- ^ /Required/ "ingredientImage"
  , inlineResponse20034Meta :: !([Text]) -- ^ /Required/ "meta"
  , inlineResponse20034Products :: !([FoodIngredientsMapProducts]) -- ^ /Required/ "products"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20034
instance A.FromJSON InlineResponse20034 where
  parseJSON = A.withObject "InlineResponse20034" $ \o ->
    InlineResponse20034
      <$> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "ingredientImage")
      <*> (o .:  "meta")
      <*> (o .:  "products")

-- | ToJSON InlineResponse20034
instance A.ToJSON InlineResponse20034 where
  toJSON InlineResponse20034 {..} =
   _omitNulls
      [ "original" .= inlineResponse20034Original
      , "originalName" .= inlineResponse20034OriginalName
      , "ingredientImage" .= inlineResponse20034IngredientImage
      , "meta" .= inlineResponse20034Meta
      , "products" .= inlineResponse20034Products
      ]


-- | Construct a value of type 'InlineResponse20034' (by applying it's required fields, if any)
mkInlineResponse20034
  :: Text -- ^ 'inlineResponse20034Original' 
  -> Text -- ^ 'inlineResponse20034OriginalName' 
  -> Text -- ^ 'inlineResponse20034IngredientImage' 
  -> [Text] -- ^ 'inlineResponse20034Meta' 
  -> [FoodIngredientsMapProducts] -- ^ 'inlineResponse20034Products' 
  -> InlineResponse20034
mkInlineResponse20034 inlineResponse20034Original inlineResponse20034OriginalName inlineResponse20034IngredientImage inlineResponse20034Meta inlineResponse20034Products =
  InlineResponse20034
  { inlineResponse20034Original
  , inlineResponse20034OriginalName
  , inlineResponse20034IngredientImage
  , inlineResponse20034Meta
  , inlineResponse20034Products
  }

-- ** InlineResponse20035
-- | InlineResponse20035
data InlineResponse20035 = InlineResponse20035
  { inlineResponse20035MenuItems :: !([InlineResponse20035MenuItems]) -- ^ /Required/ "menuItems"
  , inlineResponse20035TotalMenuItems :: !(Int) -- ^ /Required/ "totalMenuItems"
  , inlineResponse20035Type :: !(Text) -- ^ /Required/ "type"
  , inlineResponse20035Offset :: !(Int) -- ^ /Required/ "offset"
  , inlineResponse20035Number :: !(Int) -- ^ /Required/ "number"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20035
instance A.FromJSON InlineResponse20035 where
  parseJSON = A.withObject "InlineResponse20035" $ \o ->
    InlineResponse20035
      <$> (o .:  "menuItems")
      <*> (o .:  "totalMenuItems")
      <*> (o .:  "type")
      <*> (o .:  "offset")
      <*> (o .:  "number")

-- | ToJSON InlineResponse20035
instance A.ToJSON InlineResponse20035 where
  toJSON InlineResponse20035 {..} =
   _omitNulls
      [ "menuItems" .= inlineResponse20035MenuItems
      , "totalMenuItems" .= inlineResponse20035TotalMenuItems
      , "type" .= inlineResponse20035Type
      , "offset" .= inlineResponse20035Offset
      , "number" .= inlineResponse20035Number
      ]


-- | Construct a value of type 'InlineResponse20035' (by applying it's required fields, if any)
mkInlineResponse20035
  :: [InlineResponse20035MenuItems] -- ^ 'inlineResponse20035MenuItems' 
  -> Int -- ^ 'inlineResponse20035TotalMenuItems' 
  -> Text -- ^ 'inlineResponse20035Type' 
  -> Int -- ^ 'inlineResponse20035Offset' 
  -> Int -- ^ 'inlineResponse20035Number' 
  -> InlineResponse20035
mkInlineResponse20035 inlineResponse20035MenuItems inlineResponse20035TotalMenuItems inlineResponse20035Type inlineResponse20035Offset inlineResponse20035Number =
  InlineResponse20035
  { inlineResponse20035MenuItems
  , inlineResponse20035TotalMenuItems
  , inlineResponse20035Type
  , inlineResponse20035Offset
  , inlineResponse20035Number
  }

-- ** InlineResponse20035MenuItems
-- | InlineResponse20035MenuItems
data InlineResponse20035MenuItems = InlineResponse20035MenuItems
  { inlineResponse20035MenuItemsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20035MenuItemsTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20035MenuItemsRestaurantChain :: !(Text) -- ^ /Required/ "restaurantChain"
  , inlineResponse20035MenuItemsImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20035MenuItemsImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse20035MenuItemsServings :: !(Maybe InlineResponse20028Servings) -- ^ "servings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20035MenuItems
instance A.FromJSON InlineResponse20035MenuItems where
  parseJSON = A.withObject "InlineResponse20035MenuItems" $ \o ->
    InlineResponse20035MenuItems
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "restaurantChain")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:? "servings")

-- | ToJSON InlineResponse20035MenuItems
instance A.ToJSON InlineResponse20035MenuItems where
  toJSON InlineResponse20035MenuItems {..} =
   _omitNulls
      [ "id" .= inlineResponse20035MenuItemsId
      , "title" .= inlineResponse20035MenuItemsTitle
      , "restaurantChain" .= inlineResponse20035MenuItemsRestaurantChain
      , "image" .= inlineResponse20035MenuItemsImage
      , "imageType" .= inlineResponse20035MenuItemsImageType
      , "servings" .= inlineResponse20035MenuItemsServings
      ]


-- | Construct a value of type 'InlineResponse20035MenuItems' (by applying it's required fields, if any)
mkInlineResponse20035MenuItems
  :: Int -- ^ 'inlineResponse20035MenuItemsId' 
  -> Text -- ^ 'inlineResponse20035MenuItemsTitle' 
  -> Text -- ^ 'inlineResponse20035MenuItemsRestaurantChain' 
  -> Text -- ^ 'inlineResponse20035MenuItemsImage' 
  -> Text -- ^ 'inlineResponse20035MenuItemsImageType' 
  -> InlineResponse20035MenuItems
mkInlineResponse20035MenuItems inlineResponse20035MenuItemsId inlineResponse20035MenuItemsTitle inlineResponse20035MenuItemsRestaurantChain inlineResponse20035MenuItemsImage inlineResponse20035MenuItemsImageType =
  InlineResponse20035MenuItems
  { inlineResponse20035MenuItemsId
  , inlineResponse20035MenuItemsTitle
  , inlineResponse20035MenuItemsRestaurantChain
  , inlineResponse20035MenuItemsImage
  , inlineResponse20035MenuItemsImageType
  , inlineResponse20035MenuItemsServings = Nothing
  }

-- ** InlineResponse20036
-- | InlineResponse20036
data InlineResponse20036 = InlineResponse20036
  { inlineResponse20036Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20036Title :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20036RestaurantChain :: !(Text) -- ^ /Required/ "restaurantChain"
  , inlineResponse20036Nutrition :: !(InlineResponse20028Nutrition) -- ^ /Required/ "nutrition"
  , inlineResponse20036Badges :: !([Text]) -- ^ /Required/ "badges"
  , inlineResponse20036Breadcrumbs :: !([Text]) -- ^ /Required/ "breadcrumbs"
  , inlineResponse20036GeneratedText :: !(Maybe Text) -- ^ "generatedText"
  , inlineResponse20036ImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse20036Likes :: !(Double) -- ^ /Required/ "likes"
  , inlineResponse20036Servings :: !(InlineResponse20028Servings) -- ^ /Required/ "servings"
  , inlineResponse20036Price :: !(Maybe Double) -- ^ "price"
  , inlineResponse20036SpoonacularScore :: !(Maybe Double) -- ^ "spoonacularScore"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20036
instance A.FromJSON InlineResponse20036 where
  parseJSON = A.withObject "InlineResponse20036" $ \o ->
    InlineResponse20036
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "restaurantChain")
      <*> (o .:  "nutrition")
      <*> (o .:  "badges")
      <*> (o .:  "breadcrumbs")
      <*> (o .:? "generatedText")
      <*> (o .:  "imageType")
      <*> (o .:  "likes")
      <*> (o .:  "servings")
      <*> (o .:? "price")
      <*> (o .:? "spoonacularScore")

-- | ToJSON InlineResponse20036
instance A.ToJSON InlineResponse20036 where
  toJSON InlineResponse20036 {..} =
   _omitNulls
      [ "id" .= inlineResponse20036Id
      , "title" .= inlineResponse20036Title
      , "restaurantChain" .= inlineResponse20036RestaurantChain
      , "nutrition" .= inlineResponse20036Nutrition
      , "badges" .= inlineResponse20036Badges
      , "breadcrumbs" .= inlineResponse20036Breadcrumbs
      , "generatedText" .= inlineResponse20036GeneratedText
      , "imageType" .= inlineResponse20036ImageType
      , "likes" .= inlineResponse20036Likes
      , "servings" .= inlineResponse20036Servings
      , "price" .= inlineResponse20036Price
      , "spoonacularScore" .= inlineResponse20036SpoonacularScore
      ]


-- | Construct a value of type 'InlineResponse20036' (by applying it's required fields, if any)
mkInlineResponse20036
  :: Int -- ^ 'inlineResponse20036Id' 
  -> Text -- ^ 'inlineResponse20036Title' 
  -> Text -- ^ 'inlineResponse20036RestaurantChain' 
  -> InlineResponse20028Nutrition -- ^ 'inlineResponse20036Nutrition' 
  -> [Text] -- ^ 'inlineResponse20036Badges' 
  -> [Text] -- ^ 'inlineResponse20036Breadcrumbs' 
  -> Text -- ^ 'inlineResponse20036ImageType' 
  -> Double -- ^ 'inlineResponse20036Likes' 
  -> InlineResponse20028Servings -- ^ 'inlineResponse20036Servings' 
  -> InlineResponse20036
mkInlineResponse20036 inlineResponse20036Id inlineResponse20036Title inlineResponse20036RestaurantChain inlineResponse20036Nutrition inlineResponse20036Badges inlineResponse20036Breadcrumbs inlineResponse20036ImageType inlineResponse20036Likes inlineResponse20036Servings =
  InlineResponse20036
  { inlineResponse20036Id
  , inlineResponse20036Title
  , inlineResponse20036RestaurantChain
  , inlineResponse20036Nutrition
  , inlineResponse20036Badges
  , inlineResponse20036Breadcrumbs
  , inlineResponse20036GeneratedText = Nothing
  , inlineResponse20036ImageType
  , inlineResponse20036Likes
  , inlineResponse20036Servings
  , inlineResponse20036Price = Nothing
  , inlineResponse20036SpoonacularScore = Nothing
  }

-- ** InlineResponse20037
-- | InlineResponse20037
data InlineResponse20037 = InlineResponse20037
  { inlineResponse20037Meals :: !([InlineResponse2005]) -- ^ /Required/ "meals"
  , inlineResponse20037Nutrients :: !(InlineResponse20037Nutrients) -- ^ /Required/ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20037
instance A.FromJSON InlineResponse20037 where
  parseJSON = A.withObject "InlineResponse20037" $ \o ->
    InlineResponse20037
      <$> (o .:  "meals")
      <*> (o .:  "nutrients")

-- | ToJSON InlineResponse20037
instance A.ToJSON InlineResponse20037 where
  toJSON InlineResponse20037 {..} =
   _omitNulls
      [ "meals" .= inlineResponse20037Meals
      , "nutrients" .= inlineResponse20037Nutrients
      ]


-- | Construct a value of type 'InlineResponse20037' (by applying it's required fields, if any)
mkInlineResponse20037
  :: [InlineResponse2005] -- ^ 'inlineResponse20037Meals' 
  -> InlineResponse20037Nutrients -- ^ 'inlineResponse20037Nutrients' 
  -> InlineResponse20037
mkInlineResponse20037 inlineResponse20037Meals inlineResponse20037Nutrients =
  InlineResponse20037
  { inlineResponse20037Meals
  , inlineResponse20037Nutrients
  }

-- ** InlineResponse20037Nutrients
-- | InlineResponse20037Nutrients
data InlineResponse20037Nutrients = InlineResponse20037Nutrients
  { inlineResponse20037NutrientsCalories :: !(Double) -- ^ /Required/ "calories"
  , inlineResponse20037NutrientsCarbohydrates :: !(Double) -- ^ /Required/ "carbohydrates"
  , inlineResponse20037NutrientsFat :: !(Double) -- ^ /Required/ "fat"
  , inlineResponse20037NutrientsProtein :: !(Double) -- ^ /Required/ "protein"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20037Nutrients
instance A.FromJSON InlineResponse20037Nutrients where
  parseJSON = A.withObject "InlineResponse20037Nutrients" $ \o ->
    InlineResponse20037Nutrients
      <$> (o .:  "calories")
      <*> (o .:  "carbohydrates")
      <*> (o .:  "fat")
      <*> (o .:  "protein")

-- | ToJSON InlineResponse20037Nutrients
instance A.ToJSON InlineResponse20037Nutrients where
  toJSON InlineResponse20037Nutrients {..} =
   _omitNulls
      [ "calories" .= inlineResponse20037NutrientsCalories
      , "carbohydrates" .= inlineResponse20037NutrientsCarbohydrates
      , "fat" .= inlineResponse20037NutrientsFat
      , "protein" .= inlineResponse20037NutrientsProtein
      ]


-- | Construct a value of type 'InlineResponse20037Nutrients' (by applying it's required fields, if any)
mkInlineResponse20037Nutrients
  :: Double -- ^ 'inlineResponse20037NutrientsCalories' 
  -> Double -- ^ 'inlineResponse20037NutrientsCarbohydrates' 
  -> Double -- ^ 'inlineResponse20037NutrientsFat' 
  -> Double -- ^ 'inlineResponse20037NutrientsProtein' 
  -> InlineResponse20037Nutrients
mkInlineResponse20037Nutrients inlineResponse20037NutrientsCalories inlineResponse20037NutrientsCarbohydrates inlineResponse20037NutrientsFat inlineResponse20037NutrientsProtein =
  InlineResponse20037Nutrients
  { inlineResponse20037NutrientsCalories
  , inlineResponse20037NutrientsCarbohydrates
  , inlineResponse20037NutrientsFat
  , inlineResponse20037NutrientsProtein
  }

-- ** InlineResponse20038
-- | InlineResponse20038
data InlineResponse20038 = InlineResponse20038
  { inlineResponse20038Days :: !([InlineResponse20038Days]) -- ^ /Required/ "days"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20038
instance A.FromJSON InlineResponse20038 where
  parseJSON = A.withObject "InlineResponse20038" $ \o ->
    InlineResponse20038
      <$> (o .:  "days")

-- | ToJSON InlineResponse20038
instance A.ToJSON InlineResponse20038 where
  toJSON InlineResponse20038 {..} =
   _omitNulls
      [ "days" .= inlineResponse20038Days
      ]


-- | Construct a value of type 'InlineResponse20038' (by applying it's required fields, if any)
mkInlineResponse20038
  :: [InlineResponse20038Days] -- ^ 'inlineResponse20038Days' 
  -> InlineResponse20038
mkInlineResponse20038 inlineResponse20038Days =
  InlineResponse20038
  { inlineResponse20038Days
  }

-- ** InlineResponse20038Days
-- | InlineResponse20038Days
data InlineResponse20038Days = InlineResponse20038Days
  { inlineResponse20038DaysNutritionSummary :: !(Maybe InlineResponse20038NutritionSummary) -- ^ "nutritionSummary"
  , inlineResponse20038DaysNutritionSummaryBreakfast :: !(Maybe InlineResponse20038NutritionSummary) -- ^ "nutritionSummaryBreakfast"
  , inlineResponse20038DaysNutritionSummaryLunch :: !(Maybe InlineResponse20038NutritionSummary) -- ^ "nutritionSummaryLunch"
  , inlineResponse20038DaysNutritionSummaryDinner :: !(Maybe InlineResponse20038NutritionSummary) -- ^ "nutritionSummaryDinner"
  , inlineResponse20038DaysDate :: !(Double) -- ^ /Required/ "date"
  , inlineResponse20038DaysDay :: !(Text) -- ^ /Required/ "day"
  , inlineResponse20038DaysItems :: !(Maybe [InlineResponse20038Items]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20038Days
instance A.FromJSON InlineResponse20038Days where
  parseJSON = A.withObject "InlineResponse20038Days" $ \o ->
    InlineResponse20038Days
      <$> (o .:? "nutritionSummary")
      <*> (o .:? "nutritionSummaryBreakfast")
      <*> (o .:? "nutritionSummaryLunch")
      <*> (o .:? "nutritionSummaryDinner")
      <*> (o .:  "date")
      <*> (o .:  "day")
      <*> (o .:? "items")

-- | ToJSON InlineResponse20038Days
instance A.ToJSON InlineResponse20038Days where
  toJSON InlineResponse20038Days {..} =
   _omitNulls
      [ "nutritionSummary" .= inlineResponse20038DaysNutritionSummary
      , "nutritionSummaryBreakfast" .= inlineResponse20038DaysNutritionSummaryBreakfast
      , "nutritionSummaryLunch" .= inlineResponse20038DaysNutritionSummaryLunch
      , "nutritionSummaryDinner" .= inlineResponse20038DaysNutritionSummaryDinner
      , "date" .= inlineResponse20038DaysDate
      , "day" .= inlineResponse20038DaysDay
      , "items" .= inlineResponse20038DaysItems
      ]


-- | Construct a value of type 'InlineResponse20038Days' (by applying it's required fields, if any)
mkInlineResponse20038Days
  :: Double -- ^ 'inlineResponse20038DaysDate' 
  -> Text -- ^ 'inlineResponse20038DaysDay' 
  -> InlineResponse20038Days
mkInlineResponse20038Days inlineResponse20038DaysDate inlineResponse20038DaysDay =
  InlineResponse20038Days
  { inlineResponse20038DaysNutritionSummary = Nothing
  , inlineResponse20038DaysNutritionSummaryBreakfast = Nothing
  , inlineResponse20038DaysNutritionSummaryLunch = Nothing
  , inlineResponse20038DaysNutritionSummaryDinner = Nothing
  , inlineResponse20038DaysDate
  , inlineResponse20038DaysDay
  , inlineResponse20038DaysItems = Nothing
  }

-- ** InlineResponse20038Items
-- | InlineResponse20038Items
data InlineResponse20038Items = InlineResponse20038Items
  { inlineResponse20038ItemsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20038ItemsSlot :: !(Int) -- ^ /Required/ "slot"
  , inlineResponse20038ItemsPosition :: !(Int) -- ^ /Required/ "position"
  , inlineResponse20038ItemsType :: !(Text) -- ^ /Required/ "type"
  , inlineResponse20038ItemsValue :: !(Maybe InlineResponse20038Value) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20038Items
instance A.FromJSON InlineResponse20038Items where
  parseJSON = A.withObject "InlineResponse20038Items" $ \o ->
    InlineResponse20038Items
      <$> (o .:  "id")
      <*> (o .:  "slot")
      <*> (o .:  "position")
      <*> (o .:  "type")
      <*> (o .:? "value")

-- | ToJSON InlineResponse20038Items
instance A.ToJSON InlineResponse20038Items where
  toJSON InlineResponse20038Items {..} =
   _omitNulls
      [ "id" .= inlineResponse20038ItemsId
      , "slot" .= inlineResponse20038ItemsSlot
      , "position" .= inlineResponse20038ItemsPosition
      , "type" .= inlineResponse20038ItemsType
      , "value" .= inlineResponse20038ItemsValue
      ]


-- | Construct a value of type 'InlineResponse20038Items' (by applying it's required fields, if any)
mkInlineResponse20038Items
  :: Int -- ^ 'inlineResponse20038ItemsId' 
  -> Int -- ^ 'inlineResponse20038ItemsSlot' 
  -> Int -- ^ 'inlineResponse20038ItemsPosition' 
  -> Text -- ^ 'inlineResponse20038ItemsType' 
  -> InlineResponse20038Items
mkInlineResponse20038Items inlineResponse20038ItemsId inlineResponse20038ItemsSlot inlineResponse20038ItemsPosition inlineResponse20038ItemsType =
  InlineResponse20038Items
  { inlineResponse20038ItemsId
  , inlineResponse20038ItemsSlot
  , inlineResponse20038ItemsPosition
  , inlineResponse20038ItemsType
  , inlineResponse20038ItemsValue = Nothing
  }

-- ** InlineResponse20038NutritionSummary
-- | InlineResponse20038NutritionSummary
data InlineResponse20038NutritionSummary = InlineResponse20038NutritionSummary
  { inlineResponse20038NutritionSummaryNutrients :: !([InlineResponse20038NutritionSummaryNutrients]) -- ^ /Required/ "nutrients"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20038NutritionSummary
instance A.FromJSON InlineResponse20038NutritionSummary where
  parseJSON = A.withObject "InlineResponse20038NutritionSummary" $ \o ->
    InlineResponse20038NutritionSummary
      <$> (o .:  "nutrients")

-- | ToJSON InlineResponse20038NutritionSummary
instance A.ToJSON InlineResponse20038NutritionSummary where
  toJSON InlineResponse20038NutritionSummary {..} =
   _omitNulls
      [ "nutrients" .= inlineResponse20038NutritionSummaryNutrients
      ]


-- | Construct a value of type 'InlineResponse20038NutritionSummary' (by applying it's required fields, if any)
mkInlineResponse20038NutritionSummary
  :: [InlineResponse20038NutritionSummaryNutrients] -- ^ 'inlineResponse20038NutritionSummaryNutrients' 
  -> InlineResponse20038NutritionSummary
mkInlineResponse20038NutritionSummary inlineResponse20038NutritionSummaryNutrients =
  InlineResponse20038NutritionSummary
  { inlineResponse20038NutritionSummaryNutrients
  }

-- ** InlineResponse20038NutritionSummaryNutrients
-- | InlineResponse20038NutritionSummaryNutrients
data InlineResponse20038NutritionSummaryNutrients = InlineResponse20038NutritionSummaryNutrients
  { inlineResponse20038NutritionSummaryNutrientsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20038NutritionSummaryNutrientsAmount :: !(Double) -- ^ /Required/ "amount"
  , inlineResponse20038NutritionSummaryNutrientsUnit :: !(Text) -- ^ /Required/ "unit"
  , inlineResponse20038NutritionSummaryNutrientsPercentDailyNeeds :: !(Double) -- ^ /Required/ "percentDailyNeeds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20038NutritionSummaryNutrients
instance A.FromJSON InlineResponse20038NutritionSummaryNutrients where
  parseJSON = A.withObject "InlineResponse20038NutritionSummaryNutrients" $ \o ->
    InlineResponse20038NutritionSummaryNutrients
      <$> (o .:  "name")
      <*> (o .:  "amount")
      <*> (o .:  "unit")
      <*> (o .:  "percentDailyNeeds")

-- | ToJSON InlineResponse20038NutritionSummaryNutrients
instance A.ToJSON InlineResponse20038NutritionSummaryNutrients where
  toJSON InlineResponse20038NutritionSummaryNutrients {..} =
   _omitNulls
      [ "name" .= inlineResponse20038NutritionSummaryNutrientsName
      , "amount" .= inlineResponse20038NutritionSummaryNutrientsAmount
      , "unit" .= inlineResponse20038NutritionSummaryNutrientsUnit
      , "percentDailyNeeds" .= inlineResponse20038NutritionSummaryNutrientsPercentDailyNeeds
      ]


-- | Construct a value of type 'InlineResponse20038NutritionSummaryNutrients' (by applying it's required fields, if any)
mkInlineResponse20038NutritionSummaryNutrients
  :: Text -- ^ 'inlineResponse20038NutritionSummaryNutrientsName' 
  -> Double -- ^ 'inlineResponse20038NutritionSummaryNutrientsAmount' 
  -> Text -- ^ 'inlineResponse20038NutritionSummaryNutrientsUnit' 
  -> Double -- ^ 'inlineResponse20038NutritionSummaryNutrientsPercentDailyNeeds' 
  -> InlineResponse20038NutritionSummaryNutrients
mkInlineResponse20038NutritionSummaryNutrients inlineResponse20038NutritionSummaryNutrientsName inlineResponse20038NutritionSummaryNutrientsAmount inlineResponse20038NutritionSummaryNutrientsUnit inlineResponse20038NutritionSummaryNutrientsPercentDailyNeeds =
  InlineResponse20038NutritionSummaryNutrients
  { inlineResponse20038NutritionSummaryNutrientsName
  , inlineResponse20038NutritionSummaryNutrientsAmount
  , inlineResponse20038NutritionSummaryNutrientsUnit
  , inlineResponse20038NutritionSummaryNutrientsPercentDailyNeeds
  }

-- ** InlineResponse20038Value
-- | InlineResponse20038Value
data InlineResponse20038Value = InlineResponse20038Value
  { inlineResponse20038ValueServings :: !(Double) -- ^ /Required/ "servings"
  , inlineResponse20038ValueId :: !(Double) -- ^ /Required/ "id"
  , inlineResponse20038ValueTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20038ValueImageType :: !(Text) -- ^ /Required/ "imageType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20038Value
instance A.FromJSON InlineResponse20038Value where
  parseJSON = A.withObject "InlineResponse20038Value" $ \o ->
    InlineResponse20038Value
      <$> (o .:  "servings")
      <*> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")

-- | ToJSON InlineResponse20038Value
instance A.ToJSON InlineResponse20038Value where
  toJSON InlineResponse20038Value {..} =
   _omitNulls
      [ "servings" .= inlineResponse20038ValueServings
      , "id" .= inlineResponse20038ValueId
      , "title" .= inlineResponse20038ValueTitle
      , "imageType" .= inlineResponse20038ValueImageType
      ]


-- | Construct a value of type 'InlineResponse20038Value' (by applying it's required fields, if any)
mkInlineResponse20038Value
  :: Double -- ^ 'inlineResponse20038ValueServings' 
  -> Double -- ^ 'inlineResponse20038ValueId' 
  -> Text -- ^ 'inlineResponse20038ValueTitle' 
  -> Text -- ^ 'inlineResponse20038ValueImageType' 
  -> InlineResponse20038Value
mkInlineResponse20038Value inlineResponse20038ValueServings inlineResponse20038ValueId inlineResponse20038ValueTitle inlineResponse20038ValueImageType =
  InlineResponse20038Value
  { inlineResponse20038ValueServings
  , inlineResponse20038ValueId
  , inlineResponse20038ValueTitle
  , inlineResponse20038ValueImageType
  }

-- ** InlineResponse20039
-- | InlineResponse20039
data InlineResponse20039 = InlineResponse20039
  { inlineResponse20039Templates :: !([InlineResponse20013Ingredients1]) -- ^ /Required/ "templates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20039
instance A.FromJSON InlineResponse20039 where
  parseJSON = A.withObject "InlineResponse20039" $ \o ->
    InlineResponse20039
      <$> (o .:  "templates")

-- | ToJSON InlineResponse20039
instance A.ToJSON InlineResponse20039 where
  toJSON InlineResponse20039 {..} =
   _omitNulls
      [ "templates" .= inlineResponse20039Templates
      ]


-- | Construct a value of type 'InlineResponse20039' (by applying it's required fields, if any)
mkInlineResponse20039
  :: [InlineResponse20013Ingredients1] -- ^ 'inlineResponse20039Templates' 
  -> InlineResponse20039
mkInlineResponse20039 inlineResponse20039Templates =
  InlineResponse20039
  { inlineResponse20039Templates
  }

-- ** InlineResponse2003ExtendedIngredients
-- | InlineResponse2003ExtendedIngredients
data InlineResponse2003ExtendedIngredients = InlineResponse2003ExtendedIngredients
  { inlineResponse2003ExtendedIngredientsAisle :: !(Text) -- ^ /Required/ "aisle"
  , inlineResponse2003ExtendedIngredientsAmount :: !(Double) -- ^ /Required/ "amount"
  , inlineResponse2003ExtendedIngredientsConsitency :: !(Text) -- ^ /Required/ "consitency"
  , inlineResponse2003ExtendedIngredientsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2003ExtendedIngredientsImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse2003ExtendedIngredientsMeasures :: !(Maybe InlineResponse2003Measures) -- ^ "measures"
  , inlineResponse2003ExtendedIngredientsMeta :: !(Maybe [Text]) -- ^ "meta"
  , inlineResponse2003ExtendedIngredientsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse2003ExtendedIngredientsOriginal :: !(Text) -- ^ /Required/ "original"
  , inlineResponse2003ExtendedIngredientsOriginalName :: !(Text) -- ^ /Required/ "originalName"
  , inlineResponse2003ExtendedIngredientsUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003ExtendedIngredients
instance A.FromJSON InlineResponse2003ExtendedIngredients where
  parseJSON = A.withObject "InlineResponse2003ExtendedIngredients" $ \o ->
    InlineResponse2003ExtendedIngredients
      <$> (o .:  "aisle")
      <*> (o .:  "amount")
      <*> (o .:  "consitency")
      <*> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:? "measures")
      <*> (o .:? "meta")
      <*> (o .:  "name")
      <*> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "unit")

-- | ToJSON InlineResponse2003ExtendedIngredients
instance A.ToJSON InlineResponse2003ExtendedIngredients where
  toJSON InlineResponse2003ExtendedIngredients {..} =
   _omitNulls
      [ "aisle" .= inlineResponse2003ExtendedIngredientsAisle
      , "amount" .= inlineResponse2003ExtendedIngredientsAmount
      , "consitency" .= inlineResponse2003ExtendedIngredientsConsitency
      , "id" .= inlineResponse2003ExtendedIngredientsId
      , "image" .= inlineResponse2003ExtendedIngredientsImage
      , "measures" .= inlineResponse2003ExtendedIngredientsMeasures
      , "meta" .= inlineResponse2003ExtendedIngredientsMeta
      , "name" .= inlineResponse2003ExtendedIngredientsName
      , "original" .= inlineResponse2003ExtendedIngredientsOriginal
      , "originalName" .= inlineResponse2003ExtendedIngredientsOriginalName
      , "unit" .= inlineResponse2003ExtendedIngredientsUnit
      ]


-- | Construct a value of type 'InlineResponse2003ExtendedIngredients' (by applying it's required fields, if any)
mkInlineResponse2003ExtendedIngredients
  :: Text -- ^ 'inlineResponse2003ExtendedIngredientsAisle' 
  -> Double -- ^ 'inlineResponse2003ExtendedIngredientsAmount' 
  -> Text -- ^ 'inlineResponse2003ExtendedIngredientsConsitency' 
  -> Int -- ^ 'inlineResponse2003ExtendedIngredientsId' 
  -> Text -- ^ 'inlineResponse2003ExtendedIngredientsImage' 
  -> Text -- ^ 'inlineResponse2003ExtendedIngredientsName' 
  -> Text -- ^ 'inlineResponse2003ExtendedIngredientsOriginal' 
  -> Text -- ^ 'inlineResponse2003ExtendedIngredientsOriginalName' 
  -> Text -- ^ 'inlineResponse2003ExtendedIngredientsUnit' 
  -> InlineResponse2003ExtendedIngredients
mkInlineResponse2003ExtendedIngredients inlineResponse2003ExtendedIngredientsAisle inlineResponse2003ExtendedIngredientsAmount inlineResponse2003ExtendedIngredientsConsitency inlineResponse2003ExtendedIngredientsId inlineResponse2003ExtendedIngredientsImage inlineResponse2003ExtendedIngredientsName inlineResponse2003ExtendedIngredientsOriginal inlineResponse2003ExtendedIngredientsOriginalName inlineResponse2003ExtendedIngredientsUnit =
  InlineResponse2003ExtendedIngredients
  { inlineResponse2003ExtendedIngredientsAisle
  , inlineResponse2003ExtendedIngredientsAmount
  , inlineResponse2003ExtendedIngredientsConsitency
  , inlineResponse2003ExtendedIngredientsId
  , inlineResponse2003ExtendedIngredientsImage
  , inlineResponse2003ExtendedIngredientsMeasures = Nothing
  , inlineResponse2003ExtendedIngredientsMeta = Nothing
  , inlineResponse2003ExtendedIngredientsName
  , inlineResponse2003ExtendedIngredientsOriginal
  , inlineResponse2003ExtendedIngredientsOriginalName
  , inlineResponse2003ExtendedIngredientsUnit
  }

-- ** InlineResponse2003Measures
-- | InlineResponse2003Measures
data InlineResponse2003Measures = InlineResponse2003Measures
  { inlineResponse2003MeasuresMetric :: !(InlineResponse2003MeasuresMetric) -- ^ /Required/ "metric"
  , inlineResponse2003MeasuresUs :: !(InlineResponse2003MeasuresMetric) -- ^ /Required/ "us"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003Measures
instance A.FromJSON InlineResponse2003Measures where
  parseJSON = A.withObject "InlineResponse2003Measures" $ \o ->
    InlineResponse2003Measures
      <$> (o .:  "metric")
      <*> (o .:  "us")

-- | ToJSON InlineResponse2003Measures
instance A.ToJSON InlineResponse2003Measures where
  toJSON InlineResponse2003Measures {..} =
   _omitNulls
      [ "metric" .= inlineResponse2003MeasuresMetric
      , "us" .= inlineResponse2003MeasuresUs
      ]


-- | Construct a value of type 'InlineResponse2003Measures' (by applying it's required fields, if any)
mkInlineResponse2003Measures
  :: InlineResponse2003MeasuresMetric -- ^ 'inlineResponse2003MeasuresMetric' 
  -> InlineResponse2003MeasuresMetric -- ^ 'inlineResponse2003MeasuresUs' 
  -> InlineResponse2003Measures
mkInlineResponse2003Measures inlineResponse2003MeasuresMetric inlineResponse2003MeasuresUs =
  InlineResponse2003Measures
  { inlineResponse2003MeasuresMetric
  , inlineResponse2003MeasuresUs
  }

-- ** InlineResponse2003MeasuresMetric
-- | InlineResponse2003MeasuresMetric
data InlineResponse2003MeasuresMetric = InlineResponse2003MeasuresMetric
  { inlineResponse2003MeasuresMetricAmount :: !(Double) -- ^ /Required/ "amount"
  , inlineResponse2003MeasuresMetricUnitLong :: !(Text) -- ^ /Required/ "unitLong"
  , inlineResponse2003MeasuresMetricUnitShort :: !(Text) -- ^ /Required/ "unitShort"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003MeasuresMetric
instance A.FromJSON InlineResponse2003MeasuresMetric where
  parseJSON = A.withObject "InlineResponse2003MeasuresMetric" $ \o ->
    InlineResponse2003MeasuresMetric
      <$> (o .:  "amount")
      <*> (o .:  "unitLong")
      <*> (o .:  "unitShort")

-- | ToJSON InlineResponse2003MeasuresMetric
instance A.ToJSON InlineResponse2003MeasuresMetric where
  toJSON InlineResponse2003MeasuresMetric {..} =
   _omitNulls
      [ "amount" .= inlineResponse2003MeasuresMetricAmount
      , "unitLong" .= inlineResponse2003MeasuresMetricUnitLong
      , "unitShort" .= inlineResponse2003MeasuresMetricUnitShort
      ]


-- | Construct a value of type 'InlineResponse2003MeasuresMetric' (by applying it's required fields, if any)
mkInlineResponse2003MeasuresMetric
  :: Double -- ^ 'inlineResponse2003MeasuresMetricAmount' 
  -> Text -- ^ 'inlineResponse2003MeasuresMetricUnitLong' 
  -> Text -- ^ 'inlineResponse2003MeasuresMetricUnitShort' 
  -> InlineResponse2003MeasuresMetric
mkInlineResponse2003MeasuresMetric inlineResponse2003MeasuresMetricAmount inlineResponse2003MeasuresMetricUnitLong inlineResponse2003MeasuresMetricUnitShort =
  InlineResponse2003MeasuresMetric
  { inlineResponse2003MeasuresMetricAmount
  , inlineResponse2003MeasuresMetricUnitLong
  , inlineResponse2003MeasuresMetricUnitShort
  }

-- ** InlineResponse2003WinePairing
-- | InlineResponse2003WinePairing
data InlineResponse2003WinePairing = InlineResponse2003WinePairing
  { inlineResponse2003WinePairingPairedWines :: !([Text]) -- ^ /Required/ "pairedWines"
  , inlineResponse2003WinePairingPairingText :: !(Text) -- ^ /Required/ "pairingText"
  , inlineResponse2003WinePairingProductMatches :: !([InlineResponse2003WinePairingProductMatches]) -- ^ /Required/ "productMatches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003WinePairing
instance A.FromJSON InlineResponse2003WinePairing where
  parseJSON = A.withObject "InlineResponse2003WinePairing" $ \o ->
    InlineResponse2003WinePairing
      <$> (o .:  "pairedWines")
      <*> (o .:  "pairingText")
      <*> (o .:  "productMatches")

-- | ToJSON InlineResponse2003WinePairing
instance A.ToJSON InlineResponse2003WinePairing where
  toJSON InlineResponse2003WinePairing {..} =
   _omitNulls
      [ "pairedWines" .= inlineResponse2003WinePairingPairedWines
      , "pairingText" .= inlineResponse2003WinePairingPairingText
      , "productMatches" .= inlineResponse2003WinePairingProductMatches
      ]


-- | Construct a value of type 'InlineResponse2003WinePairing' (by applying it's required fields, if any)
mkInlineResponse2003WinePairing
  :: [Text] -- ^ 'inlineResponse2003WinePairingPairedWines' 
  -> Text -- ^ 'inlineResponse2003WinePairingPairingText' 
  -> [InlineResponse2003WinePairingProductMatches] -- ^ 'inlineResponse2003WinePairingProductMatches' 
  -> InlineResponse2003WinePairing
mkInlineResponse2003WinePairing inlineResponse2003WinePairingPairedWines inlineResponse2003WinePairingPairingText inlineResponse2003WinePairingProductMatches =
  InlineResponse2003WinePairing
  { inlineResponse2003WinePairingPairedWines
  , inlineResponse2003WinePairingPairingText
  , inlineResponse2003WinePairingProductMatches
  }

-- ** InlineResponse2003WinePairingProductMatches
-- | InlineResponse2003WinePairingProductMatches
data InlineResponse2003WinePairingProductMatches = InlineResponse2003WinePairingProductMatches
  { inlineResponse2003WinePairingProductMatchesId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2003WinePairingProductMatchesTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse2003WinePairingProductMatchesDescription :: !(Text) -- ^ /Required/ "description"
  , inlineResponse2003WinePairingProductMatchesPrice :: !(Text) -- ^ /Required/ "price"
  , inlineResponse2003WinePairingProductMatchesImageUrl :: !(Text) -- ^ /Required/ "imageUrl"
  , inlineResponse2003WinePairingProductMatchesAverageRating :: !(Double) -- ^ /Required/ "averageRating"
  , inlineResponse2003WinePairingProductMatchesRatingCount :: !(Int) -- ^ /Required/ "ratingCount"
  , inlineResponse2003WinePairingProductMatchesScore :: !(Double) -- ^ /Required/ "score"
  , inlineResponse2003WinePairingProductMatchesLink :: !(Text) -- ^ /Required/ "link"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003WinePairingProductMatches
instance A.FromJSON InlineResponse2003WinePairingProductMatches where
  parseJSON = A.withObject "InlineResponse2003WinePairingProductMatches" $ \o ->
    InlineResponse2003WinePairingProductMatches
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "description")
      <*> (o .:  "price")
      <*> (o .:  "imageUrl")
      <*> (o .:  "averageRating")
      <*> (o .:  "ratingCount")
      <*> (o .:  "score")
      <*> (o .:  "link")

-- | ToJSON InlineResponse2003WinePairingProductMatches
instance A.ToJSON InlineResponse2003WinePairingProductMatches where
  toJSON InlineResponse2003WinePairingProductMatches {..} =
   _omitNulls
      [ "id" .= inlineResponse2003WinePairingProductMatchesId
      , "title" .= inlineResponse2003WinePairingProductMatchesTitle
      , "description" .= inlineResponse2003WinePairingProductMatchesDescription
      , "price" .= inlineResponse2003WinePairingProductMatchesPrice
      , "imageUrl" .= inlineResponse2003WinePairingProductMatchesImageUrl
      , "averageRating" .= inlineResponse2003WinePairingProductMatchesAverageRating
      , "ratingCount" .= inlineResponse2003WinePairingProductMatchesRatingCount
      , "score" .= inlineResponse2003WinePairingProductMatchesScore
      , "link" .= inlineResponse2003WinePairingProductMatchesLink
      ]


-- | Construct a value of type 'InlineResponse2003WinePairingProductMatches' (by applying it's required fields, if any)
mkInlineResponse2003WinePairingProductMatches
  :: Int -- ^ 'inlineResponse2003WinePairingProductMatchesId' 
  -> Text -- ^ 'inlineResponse2003WinePairingProductMatchesTitle' 
  -> Text -- ^ 'inlineResponse2003WinePairingProductMatchesDescription' 
  -> Text -- ^ 'inlineResponse2003WinePairingProductMatchesPrice' 
  -> Text -- ^ 'inlineResponse2003WinePairingProductMatchesImageUrl' 
  -> Double -- ^ 'inlineResponse2003WinePairingProductMatchesAverageRating' 
  -> Int -- ^ 'inlineResponse2003WinePairingProductMatchesRatingCount' 
  -> Double -- ^ 'inlineResponse2003WinePairingProductMatchesScore' 
  -> Text -- ^ 'inlineResponse2003WinePairingProductMatchesLink' 
  -> InlineResponse2003WinePairingProductMatches
mkInlineResponse2003WinePairingProductMatches inlineResponse2003WinePairingProductMatchesId inlineResponse2003WinePairingProductMatchesTitle inlineResponse2003WinePairingProductMatchesDescription inlineResponse2003WinePairingProductMatchesPrice inlineResponse2003WinePairingProductMatchesImageUrl inlineResponse2003WinePairingProductMatchesAverageRating inlineResponse2003WinePairingProductMatchesRatingCount inlineResponse2003WinePairingProductMatchesScore inlineResponse2003WinePairingProductMatchesLink =
  InlineResponse2003WinePairingProductMatches
  { inlineResponse2003WinePairingProductMatchesId
  , inlineResponse2003WinePairingProductMatchesTitle
  , inlineResponse2003WinePairingProductMatchesDescription
  , inlineResponse2003WinePairingProductMatchesPrice
  , inlineResponse2003WinePairingProductMatchesImageUrl
  , inlineResponse2003WinePairingProductMatchesAverageRating
  , inlineResponse2003WinePairingProductMatchesRatingCount
  , inlineResponse2003WinePairingProductMatchesScore
  , inlineResponse2003WinePairingProductMatchesLink
  }

-- ** InlineResponse2004
-- | InlineResponse2004
data InlineResponse2004 = InlineResponse2004
  { inlineResponse2004Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2004Title :: !(Text) -- ^ /Required/ "title"
  , inlineResponse2004Image :: !(Text) -- ^ /Required/ "image"
  , inlineResponse2004ImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse2004Servings :: !(Double) -- ^ /Required/ "servings"
  , inlineResponse2004ReadyInMinutes :: !(Int) -- ^ /Required/ "readyInMinutes"
  , inlineResponse2004License :: !(Text) -- ^ /Required/ "license"
  , inlineResponse2004SourceName :: !(Text) -- ^ /Required/ "sourceName"
  , inlineResponse2004SourceUrl :: !(Text) -- ^ /Required/ "sourceUrl"
  , inlineResponse2004SpoonacularSourceUrl :: !(Text) -- ^ /Required/ "spoonacularSourceUrl"
  , inlineResponse2004AggregateLikes :: !(Int) -- ^ /Required/ "aggregateLikes"
  , inlineResponse2004HealthScore :: !(Double) -- ^ /Required/ "healthScore"
  , inlineResponse2004SpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  , inlineResponse2004PricePerServing :: !(Double) -- ^ /Required/ "pricePerServing"
  , inlineResponse2004AnalyzedInstructions :: !([Text]) -- ^ /Required/ "analyzedInstructions"
  , inlineResponse2004Cheap :: !(Bool) -- ^ /Required/ "cheap"
  , inlineResponse2004CreditsText :: !(Text) -- ^ /Required/ "creditsText"
  , inlineResponse2004Cuisines :: !([Text]) -- ^ /Required/ "cuisines"
  , inlineResponse2004DairyFree :: !(Bool) -- ^ /Required/ "dairyFree"
  , inlineResponse2004Diets :: !([Text]) -- ^ /Required/ "diets"
  , inlineResponse2004Gaps :: !(Text) -- ^ /Required/ "gaps"
  , inlineResponse2004GlutenFree :: !(Bool) -- ^ /Required/ "glutenFree"
  , inlineResponse2004Instructions :: !(Text) -- ^ /Required/ "instructions"
  , inlineResponse2004Ketogenic :: !(Bool) -- ^ /Required/ "ketogenic"
  , inlineResponse2004LowFodmap :: !(Bool) -- ^ /Required/ "lowFodmap"
  , inlineResponse2004Occasions :: !([Text]) -- ^ /Required/ "occasions"
  , inlineResponse2004Sustainable :: !(Bool) -- ^ /Required/ "sustainable"
  , inlineResponse2004Vegan :: !(Bool) -- ^ /Required/ "vegan"
  , inlineResponse2004Vegetarian :: !(Bool) -- ^ /Required/ "vegetarian"
  , inlineResponse2004VeryHealthy :: !(Bool) -- ^ /Required/ "veryHealthy"
  , inlineResponse2004VeryPopular :: !(Bool) -- ^ /Required/ "veryPopular"
  , inlineResponse2004Whole30 :: !(Bool) -- ^ /Required/ "whole30"
  , inlineResponse2004WeightWatcherSmartPoints :: !(Double) -- ^ /Required/ "weightWatcherSmartPoints"
  , inlineResponse2004DishTypes :: !([Text]) -- ^ /Required/ "dishTypes"
  , inlineResponse2004ExtendedIngredients :: !([InlineResponse2003ExtendedIngredients]) -- ^ /Required/ "extendedIngredients"
  , inlineResponse2004Summary :: !(Text) -- ^ /Required/ "summary"
  , inlineResponse2004WinePairing :: !(InlineResponse2003WinePairing) -- ^ /Required/ "winePairing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2004
instance A.FromJSON InlineResponse2004 where
  parseJSON = A.withObject "InlineResponse2004" $ \o ->
    InlineResponse2004
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "servings")
      <*> (o .:  "readyInMinutes")
      <*> (o .:  "license")
      <*> (o .:  "sourceName")
      <*> (o .:  "sourceUrl")
      <*> (o .:  "spoonacularSourceUrl")
      <*> (o .:  "aggregateLikes")
      <*> (o .:  "healthScore")
      <*> (o .:  "spoonacularScore")
      <*> (o .:  "pricePerServing")
      <*> (o .:  "analyzedInstructions")
      <*> (o .:  "cheap")
      <*> (o .:  "creditsText")
      <*> (o .:  "cuisines")
      <*> (o .:  "dairyFree")
      <*> (o .:  "diets")
      <*> (o .:  "gaps")
      <*> (o .:  "glutenFree")
      <*> (o .:  "instructions")
      <*> (o .:  "ketogenic")
      <*> (o .:  "lowFodmap")
      <*> (o .:  "occasions")
      <*> (o .:  "sustainable")
      <*> (o .:  "vegan")
      <*> (o .:  "vegetarian")
      <*> (o .:  "veryHealthy")
      <*> (o .:  "veryPopular")
      <*> (o .:  "whole30")
      <*> (o .:  "weightWatcherSmartPoints")
      <*> (o .:  "dishTypes")
      <*> (o .:  "extendedIngredients")
      <*> (o .:  "summary")
      <*> (o .:  "winePairing")

-- | ToJSON InlineResponse2004
instance A.ToJSON InlineResponse2004 where
  toJSON InlineResponse2004 {..} =
   _omitNulls
      [ "id" .= inlineResponse2004Id
      , "title" .= inlineResponse2004Title
      , "image" .= inlineResponse2004Image
      , "imageType" .= inlineResponse2004ImageType
      , "servings" .= inlineResponse2004Servings
      , "readyInMinutes" .= inlineResponse2004ReadyInMinutes
      , "license" .= inlineResponse2004License
      , "sourceName" .= inlineResponse2004SourceName
      , "sourceUrl" .= inlineResponse2004SourceUrl
      , "spoonacularSourceUrl" .= inlineResponse2004SpoonacularSourceUrl
      , "aggregateLikes" .= inlineResponse2004AggregateLikes
      , "healthScore" .= inlineResponse2004HealthScore
      , "spoonacularScore" .= inlineResponse2004SpoonacularScore
      , "pricePerServing" .= inlineResponse2004PricePerServing
      , "analyzedInstructions" .= inlineResponse2004AnalyzedInstructions
      , "cheap" .= inlineResponse2004Cheap
      , "creditsText" .= inlineResponse2004CreditsText
      , "cuisines" .= inlineResponse2004Cuisines
      , "dairyFree" .= inlineResponse2004DairyFree
      , "diets" .= inlineResponse2004Diets
      , "gaps" .= inlineResponse2004Gaps
      , "glutenFree" .= inlineResponse2004GlutenFree
      , "instructions" .= inlineResponse2004Instructions
      , "ketogenic" .= inlineResponse2004Ketogenic
      , "lowFodmap" .= inlineResponse2004LowFodmap
      , "occasions" .= inlineResponse2004Occasions
      , "sustainable" .= inlineResponse2004Sustainable
      , "vegan" .= inlineResponse2004Vegan
      , "vegetarian" .= inlineResponse2004Vegetarian
      , "veryHealthy" .= inlineResponse2004VeryHealthy
      , "veryPopular" .= inlineResponse2004VeryPopular
      , "whole30" .= inlineResponse2004Whole30
      , "weightWatcherSmartPoints" .= inlineResponse2004WeightWatcherSmartPoints
      , "dishTypes" .= inlineResponse2004DishTypes
      , "extendedIngredients" .= inlineResponse2004ExtendedIngredients
      , "summary" .= inlineResponse2004Summary
      , "winePairing" .= inlineResponse2004WinePairing
      ]


-- | Construct a value of type 'InlineResponse2004' (by applying it's required fields, if any)
mkInlineResponse2004
  :: Int -- ^ 'inlineResponse2004Id' 
  -> Text -- ^ 'inlineResponse2004Title' 
  -> Text -- ^ 'inlineResponse2004Image' 
  -> Text -- ^ 'inlineResponse2004ImageType' 
  -> Double -- ^ 'inlineResponse2004Servings' 
  -> Int -- ^ 'inlineResponse2004ReadyInMinutes' 
  -> Text -- ^ 'inlineResponse2004License' 
  -> Text -- ^ 'inlineResponse2004SourceName' 
  -> Text -- ^ 'inlineResponse2004SourceUrl' 
  -> Text -- ^ 'inlineResponse2004SpoonacularSourceUrl' 
  -> Int -- ^ 'inlineResponse2004AggregateLikes' 
  -> Double -- ^ 'inlineResponse2004HealthScore' 
  -> Double -- ^ 'inlineResponse2004SpoonacularScore' 
  -> Double -- ^ 'inlineResponse2004PricePerServing' 
  -> [Text] -- ^ 'inlineResponse2004AnalyzedInstructions' 
  -> Bool -- ^ 'inlineResponse2004Cheap' 
  -> Text -- ^ 'inlineResponse2004CreditsText' 
  -> [Text] -- ^ 'inlineResponse2004Cuisines' 
  -> Bool -- ^ 'inlineResponse2004DairyFree' 
  -> [Text] -- ^ 'inlineResponse2004Diets' 
  -> Text -- ^ 'inlineResponse2004Gaps' 
  -> Bool -- ^ 'inlineResponse2004GlutenFree' 
  -> Text -- ^ 'inlineResponse2004Instructions' 
  -> Bool -- ^ 'inlineResponse2004Ketogenic' 
  -> Bool -- ^ 'inlineResponse2004LowFodmap' 
  -> [Text] -- ^ 'inlineResponse2004Occasions' 
  -> Bool -- ^ 'inlineResponse2004Sustainable' 
  -> Bool -- ^ 'inlineResponse2004Vegan' 
  -> Bool -- ^ 'inlineResponse2004Vegetarian' 
  -> Bool -- ^ 'inlineResponse2004VeryHealthy' 
  -> Bool -- ^ 'inlineResponse2004VeryPopular' 
  -> Bool -- ^ 'inlineResponse2004Whole30' 
  -> Double -- ^ 'inlineResponse2004WeightWatcherSmartPoints' 
  -> [Text] -- ^ 'inlineResponse2004DishTypes' 
  -> [InlineResponse2003ExtendedIngredients] -- ^ 'inlineResponse2004ExtendedIngredients' 
  -> Text -- ^ 'inlineResponse2004Summary' 
  -> InlineResponse2003WinePairing -- ^ 'inlineResponse2004WinePairing' 
  -> InlineResponse2004
mkInlineResponse2004 inlineResponse2004Id inlineResponse2004Title inlineResponse2004Image inlineResponse2004ImageType inlineResponse2004Servings inlineResponse2004ReadyInMinutes inlineResponse2004License inlineResponse2004SourceName inlineResponse2004SourceUrl inlineResponse2004SpoonacularSourceUrl inlineResponse2004AggregateLikes inlineResponse2004HealthScore inlineResponse2004SpoonacularScore inlineResponse2004PricePerServing inlineResponse2004AnalyzedInstructions inlineResponse2004Cheap inlineResponse2004CreditsText inlineResponse2004Cuisines inlineResponse2004DairyFree inlineResponse2004Diets inlineResponse2004Gaps inlineResponse2004GlutenFree inlineResponse2004Instructions inlineResponse2004Ketogenic inlineResponse2004LowFodmap inlineResponse2004Occasions inlineResponse2004Sustainable inlineResponse2004Vegan inlineResponse2004Vegetarian inlineResponse2004VeryHealthy inlineResponse2004VeryPopular inlineResponse2004Whole30 inlineResponse2004WeightWatcherSmartPoints inlineResponse2004DishTypes inlineResponse2004ExtendedIngredients inlineResponse2004Summary inlineResponse2004WinePairing =
  InlineResponse2004
  { inlineResponse2004Id
  , inlineResponse2004Title
  , inlineResponse2004Image
  , inlineResponse2004ImageType
  , inlineResponse2004Servings
  , inlineResponse2004ReadyInMinutes
  , inlineResponse2004License
  , inlineResponse2004SourceName
  , inlineResponse2004SourceUrl
  , inlineResponse2004SpoonacularSourceUrl
  , inlineResponse2004AggregateLikes
  , inlineResponse2004HealthScore
  , inlineResponse2004SpoonacularScore
  , inlineResponse2004PricePerServing
  , inlineResponse2004AnalyzedInstructions
  , inlineResponse2004Cheap
  , inlineResponse2004CreditsText
  , inlineResponse2004Cuisines
  , inlineResponse2004DairyFree
  , inlineResponse2004Diets
  , inlineResponse2004Gaps
  , inlineResponse2004GlutenFree
  , inlineResponse2004Instructions
  , inlineResponse2004Ketogenic
  , inlineResponse2004LowFodmap
  , inlineResponse2004Occasions
  , inlineResponse2004Sustainable
  , inlineResponse2004Vegan
  , inlineResponse2004Vegetarian
  , inlineResponse2004VeryHealthy
  , inlineResponse2004VeryPopular
  , inlineResponse2004Whole30
  , inlineResponse2004WeightWatcherSmartPoints
  , inlineResponse2004DishTypes
  , inlineResponse2004ExtendedIngredients
  , inlineResponse2004Summary
  , inlineResponse2004WinePairing
  }

-- ** InlineResponse20040
-- | InlineResponse20040
data InlineResponse20040 = InlineResponse20040
  { inlineResponse20040Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20040Name :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20040Days :: !([InlineResponse20040Days]) -- ^ /Required/ "days"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20040
instance A.FromJSON InlineResponse20040 where
  parseJSON = A.withObject "InlineResponse20040" $ \o ->
    InlineResponse20040
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "days")

-- | ToJSON InlineResponse20040
instance A.ToJSON InlineResponse20040 where
  toJSON InlineResponse20040 {..} =
   _omitNulls
      [ "id" .= inlineResponse20040Id
      , "name" .= inlineResponse20040Name
      , "days" .= inlineResponse20040Days
      ]


-- | Construct a value of type 'InlineResponse20040' (by applying it's required fields, if any)
mkInlineResponse20040
  :: Int -- ^ 'inlineResponse20040Id' 
  -> Text -- ^ 'inlineResponse20040Name' 
  -> [InlineResponse20040Days] -- ^ 'inlineResponse20040Days' 
  -> InlineResponse20040
mkInlineResponse20040 inlineResponse20040Id inlineResponse20040Name inlineResponse20040Days =
  InlineResponse20040
  { inlineResponse20040Id
  , inlineResponse20040Name
  , inlineResponse20040Days
  }

-- ** InlineResponse20040Days
-- | InlineResponse20040Days
data InlineResponse20040Days = InlineResponse20040Days
  { inlineResponse20040DaysNutritionSummary :: !(Maybe InlineResponse20038NutritionSummary) -- ^ "nutritionSummary"
  , inlineResponse20040DaysNutritionSummaryBreakfast :: !(Maybe InlineResponse20038NutritionSummary) -- ^ "nutritionSummaryBreakfast"
  , inlineResponse20040DaysNutritionSummaryLunch :: !(Maybe InlineResponse20038NutritionSummary) -- ^ "nutritionSummaryLunch"
  , inlineResponse20040DaysNutritionSummaryDinner :: !(Maybe InlineResponse20038NutritionSummary) -- ^ "nutritionSummaryDinner"
  , inlineResponse20040DaysDay :: !(Text) -- ^ /Required/ "day"
  , inlineResponse20040DaysItems :: !(Maybe [InlineResponse20040Items]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20040Days
instance A.FromJSON InlineResponse20040Days where
  parseJSON = A.withObject "InlineResponse20040Days" $ \o ->
    InlineResponse20040Days
      <$> (o .:? "nutritionSummary")
      <*> (o .:? "nutritionSummaryBreakfast")
      <*> (o .:? "nutritionSummaryLunch")
      <*> (o .:? "nutritionSummaryDinner")
      <*> (o .:  "day")
      <*> (o .:? "items")

-- | ToJSON InlineResponse20040Days
instance A.ToJSON InlineResponse20040Days where
  toJSON InlineResponse20040Days {..} =
   _omitNulls
      [ "nutritionSummary" .= inlineResponse20040DaysNutritionSummary
      , "nutritionSummaryBreakfast" .= inlineResponse20040DaysNutritionSummaryBreakfast
      , "nutritionSummaryLunch" .= inlineResponse20040DaysNutritionSummaryLunch
      , "nutritionSummaryDinner" .= inlineResponse20040DaysNutritionSummaryDinner
      , "day" .= inlineResponse20040DaysDay
      , "items" .= inlineResponse20040DaysItems
      ]


-- | Construct a value of type 'InlineResponse20040Days' (by applying it's required fields, if any)
mkInlineResponse20040Days
  :: Text -- ^ 'inlineResponse20040DaysDay' 
  -> InlineResponse20040Days
mkInlineResponse20040Days inlineResponse20040DaysDay =
  InlineResponse20040Days
  { inlineResponse20040DaysNutritionSummary = Nothing
  , inlineResponse20040DaysNutritionSummaryBreakfast = Nothing
  , inlineResponse20040DaysNutritionSummaryLunch = Nothing
  , inlineResponse20040DaysNutritionSummaryDinner = Nothing
  , inlineResponse20040DaysDay
  , inlineResponse20040DaysItems = Nothing
  }

-- ** InlineResponse20040Items
-- | InlineResponse20040Items
data InlineResponse20040Items = InlineResponse20040Items
  { inlineResponse20040ItemsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20040ItemsSlot :: !(Int) -- ^ /Required/ "slot"
  , inlineResponse20040ItemsPosition :: !(Int) -- ^ /Required/ "position"
  , inlineResponse20040ItemsType :: !(Text) -- ^ /Required/ "type"
  , inlineResponse20040ItemsValue :: !(Maybe InlineResponse20040Value) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20040Items
instance A.FromJSON InlineResponse20040Items where
  parseJSON = A.withObject "InlineResponse20040Items" $ \o ->
    InlineResponse20040Items
      <$> (o .:  "id")
      <*> (o .:  "slot")
      <*> (o .:  "position")
      <*> (o .:  "type")
      <*> (o .:? "value")

-- | ToJSON InlineResponse20040Items
instance A.ToJSON InlineResponse20040Items where
  toJSON InlineResponse20040Items {..} =
   _omitNulls
      [ "id" .= inlineResponse20040ItemsId
      , "slot" .= inlineResponse20040ItemsSlot
      , "position" .= inlineResponse20040ItemsPosition
      , "type" .= inlineResponse20040ItemsType
      , "value" .= inlineResponse20040ItemsValue
      ]


-- | Construct a value of type 'InlineResponse20040Items' (by applying it's required fields, if any)
mkInlineResponse20040Items
  :: Int -- ^ 'inlineResponse20040ItemsId' 
  -> Int -- ^ 'inlineResponse20040ItemsSlot' 
  -> Int -- ^ 'inlineResponse20040ItemsPosition' 
  -> Text -- ^ 'inlineResponse20040ItemsType' 
  -> InlineResponse20040Items
mkInlineResponse20040Items inlineResponse20040ItemsId inlineResponse20040ItemsSlot inlineResponse20040ItemsPosition inlineResponse20040ItemsType =
  InlineResponse20040Items
  { inlineResponse20040ItemsId
  , inlineResponse20040ItemsSlot
  , inlineResponse20040ItemsPosition
  , inlineResponse20040ItemsType
  , inlineResponse20040ItemsValue = Nothing
  }

-- ** InlineResponse20040Value
-- | InlineResponse20040Value
data InlineResponse20040Value = InlineResponse20040Value
  { inlineResponse20040ValueId :: !(Double) -- ^ /Required/ "id"
  , inlineResponse20040ValueTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20040ValueImageType :: !(Text) -- ^ /Required/ "imageType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20040Value
instance A.FromJSON InlineResponse20040Value where
  parseJSON = A.withObject "InlineResponse20040Value" $ \o ->
    InlineResponse20040Value
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")

-- | ToJSON InlineResponse20040Value
instance A.ToJSON InlineResponse20040Value where
  toJSON InlineResponse20040Value {..} =
   _omitNulls
      [ "id" .= inlineResponse20040ValueId
      , "title" .= inlineResponse20040ValueTitle
      , "imageType" .= inlineResponse20040ValueImageType
      ]


-- | Construct a value of type 'InlineResponse20040Value' (by applying it's required fields, if any)
mkInlineResponse20040Value
  :: Double -- ^ 'inlineResponse20040ValueId' 
  -> Text -- ^ 'inlineResponse20040ValueTitle' 
  -> Text -- ^ 'inlineResponse20040ValueImageType' 
  -> InlineResponse20040Value
mkInlineResponse20040Value inlineResponse20040ValueId inlineResponse20040ValueTitle inlineResponse20040ValueImageType =
  InlineResponse20040Value
  { inlineResponse20040ValueId
  , inlineResponse20040ValueTitle
  , inlineResponse20040ValueImageType
  }

-- ** InlineResponse20041
-- | InlineResponse20041
data InlineResponse20041 = InlineResponse20041
  { inlineResponse20041Aisles :: !([InlineResponse20041Aisles]) -- ^ /Required/ "aisles"
  , inlineResponse20041Cost :: !(Double) -- ^ /Required/ "cost"
  , inlineResponse20041StartDate :: !(Double) -- ^ /Required/ "startDate"
  , inlineResponse20041EndDate :: !(Double) -- ^ /Required/ "endDate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20041
instance A.FromJSON InlineResponse20041 where
  parseJSON = A.withObject "InlineResponse20041" $ \o ->
    InlineResponse20041
      <$> (o .:  "aisles")
      <*> (o .:  "cost")
      <*> (o .:  "startDate")
      <*> (o .:  "endDate")

-- | ToJSON InlineResponse20041
instance A.ToJSON InlineResponse20041 where
  toJSON InlineResponse20041 {..} =
   _omitNulls
      [ "aisles" .= inlineResponse20041Aisles
      , "cost" .= inlineResponse20041Cost
      , "startDate" .= inlineResponse20041StartDate
      , "endDate" .= inlineResponse20041EndDate
      ]


-- | Construct a value of type 'InlineResponse20041' (by applying it's required fields, if any)
mkInlineResponse20041
  :: [InlineResponse20041Aisles] -- ^ 'inlineResponse20041Aisles' 
  -> Double -- ^ 'inlineResponse20041Cost' 
  -> Double -- ^ 'inlineResponse20041StartDate' 
  -> Double -- ^ 'inlineResponse20041EndDate' 
  -> InlineResponse20041
mkInlineResponse20041 inlineResponse20041Aisles inlineResponse20041Cost inlineResponse20041StartDate inlineResponse20041EndDate =
  InlineResponse20041
  { inlineResponse20041Aisles
  , inlineResponse20041Cost
  , inlineResponse20041StartDate
  , inlineResponse20041EndDate
  }

-- ** InlineResponse20041Aisles
-- | InlineResponse20041Aisles
data InlineResponse20041Aisles = InlineResponse20041Aisles
  { inlineResponse20041AislesAisle :: !(Text) -- ^ /Required/ "aisle"
  , inlineResponse20041AislesItems :: !(Maybe [InlineResponse20041Items]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20041Aisles
instance A.FromJSON InlineResponse20041Aisles where
  parseJSON = A.withObject "InlineResponse20041Aisles" $ \o ->
    InlineResponse20041Aisles
      <$> (o .:  "aisle")
      <*> (o .:? "items")

-- | ToJSON InlineResponse20041Aisles
instance A.ToJSON InlineResponse20041Aisles where
  toJSON InlineResponse20041Aisles {..} =
   _omitNulls
      [ "aisle" .= inlineResponse20041AislesAisle
      , "items" .= inlineResponse20041AislesItems
      ]


-- | Construct a value of type 'InlineResponse20041Aisles' (by applying it's required fields, if any)
mkInlineResponse20041Aisles
  :: Text -- ^ 'inlineResponse20041AislesAisle' 
  -> InlineResponse20041Aisles
mkInlineResponse20041Aisles inlineResponse20041AislesAisle =
  InlineResponse20041Aisles
  { inlineResponse20041AislesAisle
  , inlineResponse20041AislesItems = Nothing
  }

-- ** InlineResponse20041Items
-- | InlineResponse20041Items
data InlineResponse20041Items = InlineResponse20041Items
  { inlineResponse20041ItemsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20041ItemsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20041ItemsMeasures :: !(Maybe InlineResponse20041Measures) -- ^ "measures"
  , inlineResponse20041ItemsPantryItem :: !(Bool) -- ^ /Required/ "pantryItem"
  , inlineResponse20041ItemsAisle :: !(Text) -- ^ /Required/ "aisle"
  , inlineResponse20041ItemsCost :: !(Double) -- ^ /Required/ "cost"
  , inlineResponse20041ItemsIngredientId :: !(Int) -- ^ /Required/ "ingredientId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20041Items
instance A.FromJSON InlineResponse20041Items where
  parseJSON = A.withObject "InlineResponse20041Items" $ \o ->
    InlineResponse20041Items
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:? "measures")
      <*> (o .:  "pantryItem")
      <*> (o .:  "aisle")
      <*> (o .:  "cost")
      <*> (o .:  "ingredientId")

-- | ToJSON InlineResponse20041Items
instance A.ToJSON InlineResponse20041Items where
  toJSON InlineResponse20041Items {..} =
   _omitNulls
      [ "id" .= inlineResponse20041ItemsId
      , "name" .= inlineResponse20041ItemsName
      , "measures" .= inlineResponse20041ItemsMeasures
      , "pantryItem" .= inlineResponse20041ItemsPantryItem
      , "aisle" .= inlineResponse20041ItemsAisle
      , "cost" .= inlineResponse20041ItemsCost
      , "ingredientId" .= inlineResponse20041ItemsIngredientId
      ]


-- | Construct a value of type 'InlineResponse20041Items' (by applying it's required fields, if any)
mkInlineResponse20041Items
  :: Int -- ^ 'inlineResponse20041ItemsId' 
  -> Text -- ^ 'inlineResponse20041ItemsName' 
  -> Bool -- ^ 'inlineResponse20041ItemsPantryItem' 
  -> Text -- ^ 'inlineResponse20041ItemsAisle' 
  -> Double -- ^ 'inlineResponse20041ItemsCost' 
  -> Int -- ^ 'inlineResponse20041ItemsIngredientId' 
  -> InlineResponse20041Items
mkInlineResponse20041Items inlineResponse20041ItemsId inlineResponse20041ItemsName inlineResponse20041ItemsPantryItem inlineResponse20041ItemsAisle inlineResponse20041ItemsCost inlineResponse20041ItemsIngredientId =
  InlineResponse20041Items
  { inlineResponse20041ItemsId
  , inlineResponse20041ItemsName
  , inlineResponse20041ItemsMeasures = Nothing
  , inlineResponse20041ItemsPantryItem
  , inlineResponse20041ItemsAisle
  , inlineResponse20041ItemsCost
  , inlineResponse20041ItemsIngredientId
  }

-- ** InlineResponse20041Measures
-- | InlineResponse20041Measures
data InlineResponse20041Measures = InlineResponse20041Measures
  { inlineResponse20041MeasuresOriginal :: !(RecipesParseIngredientsNutritionWeightPerServing) -- ^ /Required/ "original"
  , inlineResponse20041MeasuresMetric :: !(RecipesParseIngredientsNutritionWeightPerServing) -- ^ /Required/ "metric"
  , inlineResponse20041MeasuresUs :: !(RecipesParseIngredientsNutritionWeightPerServing) -- ^ /Required/ "us"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20041Measures
instance A.FromJSON InlineResponse20041Measures where
  parseJSON = A.withObject "InlineResponse20041Measures" $ \o ->
    InlineResponse20041Measures
      <$> (o .:  "original")
      <*> (o .:  "metric")
      <*> (o .:  "us")

-- | ToJSON InlineResponse20041Measures
instance A.ToJSON InlineResponse20041Measures where
  toJSON InlineResponse20041Measures {..} =
   _omitNulls
      [ "original" .= inlineResponse20041MeasuresOriginal
      , "metric" .= inlineResponse20041MeasuresMetric
      , "us" .= inlineResponse20041MeasuresUs
      ]


-- | Construct a value of type 'InlineResponse20041Measures' (by applying it's required fields, if any)
mkInlineResponse20041Measures
  :: RecipesParseIngredientsNutritionWeightPerServing -- ^ 'inlineResponse20041MeasuresOriginal' 
  -> RecipesParseIngredientsNutritionWeightPerServing -- ^ 'inlineResponse20041MeasuresMetric' 
  -> RecipesParseIngredientsNutritionWeightPerServing -- ^ 'inlineResponse20041MeasuresUs' 
  -> InlineResponse20041Measures
mkInlineResponse20041Measures inlineResponse20041MeasuresOriginal inlineResponse20041MeasuresMetric inlineResponse20041MeasuresUs =
  InlineResponse20041Measures
  { inlineResponse20041MeasuresOriginal
  , inlineResponse20041MeasuresMetric
  , inlineResponse20041MeasuresUs
  }

-- ** InlineResponse20042
-- | InlineResponse20042
data InlineResponse20042 = InlineResponse20042
  { inlineResponse20042Username :: !(Text) -- ^ /Required/ "username"
  , inlineResponse20042Hash :: !(Text) -- ^ /Required/ "hash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20042
instance A.FromJSON InlineResponse20042 where
  parseJSON = A.withObject "InlineResponse20042" $ \o ->
    InlineResponse20042
      <$> (o .:  "username")
      <*> (o .:  "hash")

-- | ToJSON InlineResponse20042
instance A.ToJSON InlineResponse20042 where
  toJSON InlineResponse20042 {..} =
   _omitNulls
      [ "username" .= inlineResponse20042Username
      , "hash" .= inlineResponse20042Hash
      ]


-- | Construct a value of type 'InlineResponse20042' (by applying it's required fields, if any)
mkInlineResponse20042
  :: Text -- ^ 'inlineResponse20042Username' 
  -> Text -- ^ 'inlineResponse20042Hash' 
  -> InlineResponse20042
mkInlineResponse20042 inlineResponse20042Username inlineResponse20042Hash =
  InlineResponse20042
  { inlineResponse20042Username
  , inlineResponse20042Hash
  }

-- ** InlineResponse20043
-- | InlineResponse20043
data InlineResponse20043 = InlineResponse20043
  { inlineResponse20043Pairings :: !([Text]) -- ^ /Required/ "pairings"
  , inlineResponse20043Text :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20043
instance A.FromJSON InlineResponse20043 where
  parseJSON = A.withObject "InlineResponse20043" $ \o ->
    InlineResponse20043
      <$> (o .:  "pairings")
      <*> (o .:  "text")

-- | ToJSON InlineResponse20043
instance A.ToJSON InlineResponse20043 where
  toJSON InlineResponse20043 {..} =
   _omitNulls
      [ "pairings" .= inlineResponse20043Pairings
      , "text" .= inlineResponse20043Text
      ]


-- | Construct a value of type 'InlineResponse20043' (by applying it's required fields, if any)
mkInlineResponse20043
  :: [Text] -- ^ 'inlineResponse20043Pairings' 
  -> Text -- ^ 'inlineResponse20043Text' 
  -> InlineResponse20043
mkInlineResponse20043 inlineResponse20043Pairings inlineResponse20043Text =
  InlineResponse20043
  { inlineResponse20043Pairings
  , inlineResponse20043Text
  }

-- ** InlineResponse20044
-- | InlineResponse20044
data InlineResponse20044 = InlineResponse20044
  { inlineResponse20044PairedWines :: !([Text]) -- ^ /Required/ "pairedWines"
  , inlineResponse20044PairingText :: !(Text) -- ^ /Required/ "pairingText"
  , inlineResponse20044ProductMatches :: !([InlineResponse20044ProductMatches]) -- ^ /Required/ "productMatches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20044
instance A.FromJSON InlineResponse20044 where
  parseJSON = A.withObject "InlineResponse20044" $ \o ->
    InlineResponse20044
      <$> (o .:  "pairedWines")
      <*> (o .:  "pairingText")
      <*> (o .:  "productMatches")

-- | ToJSON InlineResponse20044
instance A.ToJSON InlineResponse20044 where
  toJSON InlineResponse20044 {..} =
   _omitNulls
      [ "pairedWines" .= inlineResponse20044PairedWines
      , "pairingText" .= inlineResponse20044PairingText
      , "productMatches" .= inlineResponse20044ProductMatches
      ]


-- | Construct a value of type 'InlineResponse20044' (by applying it's required fields, if any)
mkInlineResponse20044
  :: [Text] -- ^ 'inlineResponse20044PairedWines' 
  -> Text -- ^ 'inlineResponse20044PairingText' 
  -> [InlineResponse20044ProductMatches] -- ^ 'inlineResponse20044ProductMatches' 
  -> InlineResponse20044
mkInlineResponse20044 inlineResponse20044PairedWines inlineResponse20044PairingText inlineResponse20044ProductMatches =
  InlineResponse20044
  { inlineResponse20044PairedWines
  , inlineResponse20044PairingText
  , inlineResponse20044ProductMatches
  }

-- ** InlineResponse20044ProductMatches
-- | InlineResponse20044ProductMatches
data InlineResponse20044ProductMatches = InlineResponse20044ProductMatches
  { inlineResponse20044ProductMatchesId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20044ProductMatchesTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20044ProductMatchesAverageRating :: !(Double) -- ^ /Required/ "averageRating"
  , inlineResponse20044ProductMatchesDescription :: !(Maybe A.Value) -- ^ "description"
  , inlineResponse20044ProductMatchesImageUrl :: !(Text) -- ^ /Required/ "imageUrl"
  , inlineResponse20044ProductMatchesLink :: !(Text) -- ^ /Required/ "link"
  , inlineResponse20044ProductMatchesPrice :: !(Text) -- ^ /Required/ "price"
  , inlineResponse20044ProductMatchesRatingCount :: !(Int) -- ^ /Required/ "ratingCount"
  , inlineResponse20044ProductMatchesScore :: !(Double) -- ^ /Required/ "score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20044ProductMatches
instance A.FromJSON InlineResponse20044ProductMatches where
  parseJSON = A.withObject "InlineResponse20044ProductMatches" $ \o ->
    InlineResponse20044ProductMatches
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "averageRating")
      <*> (o .:? "description")
      <*> (o .:  "imageUrl")
      <*> (o .:  "link")
      <*> (o .:  "price")
      <*> (o .:  "ratingCount")
      <*> (o .:  "score")

-- | ToJSON InlineResponse20044ProductMatches
instance A.ToJSON InlineResponse20044ProductMatches where
  toJSON InlineResponse20044ProductMatches {..} =
   _omitNulls
      [ "id" .= inlineResponse20044ProductMatchesId
      , "title" .= inlineResponse20044ProductMatchesTitle
      , "averageRating" .= inlineResponse20044ProductMatchesAverageRating
      , "description" .= inlineResponse20044ProductMatchesDescription
      , "imageUrl" .= inlineResponse20044ProductMatchesImageUrl
      , "link" .= inlineResponse20044ProductMatchesLink
      , "price" .= inlineResponse20044ProductMatchesPrice
      , "ratingCount" .= inlineResponse20044ProductMatchesRatingCount
      , "score" .= inlineResponse20044ProductMatchesScore
      ]


-- | Construct a value of type 'InlineResponse20044ProductMatches' (by applying it's required fields, if any)
mkInlineResponse20044ProductMatches
  :: Int -- ^ 'inlineResponse20044ProductMatchesId' 
  -> Text -- ^ 'inlineResponse20044ProductMatchesTitle' 
  -> Double -- ^ 'inlineResponse20044ProductMatchesAverageRating' 
  -> Text -- ^ 'inlineResponse20044ProductMatchesImageUrl' 
  -> Text -- ^ 'inlineResponse20044ProductMatchesLink' 
  -> Text -- ^ 'inlineResponse20044ProductMatchesPrice' 
  -> Int -- ^ 'inlineResponse20044ProductMatchesRatingCount' 
  -> Double -- ^ 'inlineResponse20044ProductMatchesScore' 
  -> InlineResponse20044ProductMatches
mkInlineResponse20044ProductMatches inlineResponse20044ProductMatchesId inlineResponse20044ProductMatchesTitle inlineResponse20044ProductMatchesAverageRating inlineResponse20044ProductMatchesImageUrl inlineResponse20044ProductMatchesLink inlineResponse20044ProductMatchesPrice inlineResponse20044ProductMatchesRatingCount inlineResponse20044ProductMatchesScore =
  InlineResponse20044ProductMatches
  { inlineResponse20044ProductMatchesId
  , inlineResponse20044ProductMatchesTitle
  , inlineResponse20044ProductMatchesAverageRating
  , inlineResponse20044ProductMatchesDescription = Nothing
  , inlineResponse20044ProductMatchesImageUrl
  , inlineResponse20044ProductMatchesLink
  , inlineResponse20044ProductMatchesPrice
  , inlineResponse20044ProductMatchesRatingCount
  , inlineResponse20044ProductMatchesScore
  }

-- ** InlineResponse20045
-- | InlineResponse20045
data InlineResponse20045 = InlineResponse20045
  { inlineResponse20045WineDescription :: !(Text) -- ^ /Required/ "wineDescription"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20045
instance A.FromJSON InlineResponse20045 where
  parseJSON = A.withObject "InlineResponse20045" $ \o ->
    InlineResponse20045
      <$> (o .:  "wineDescription")

-- | ToJSON InlineResponse20045
instance A.ToJSON InlineResponse20045 where
  toJSON InlineResponse20045 {..} =
   _omitNulls
      [ "wineDescription" .= inlineResponse20045WineDescription
      ]


-- | Construct a value of type 'InlineResponse20045' (by applying it's required fields, if any)
mkInlineResponse20045
  :: Text -- ^ 'inlineResponse20045WineDescription' 
  -> InlineResponse20045
mkInlineResponse20045 inlineResponse20045WineDescription =
  InlineResponse20045
  { inlineResponse20045WineDescription
  }

-- ** InlineResponse20046
-- | InlineResponse20046
data InlineResponse20046 = InlineResponse20046
  { inlineResponse20046RecommendedWines :: !([InlineResponse20046RecommendedWines]) -- ^ /Required/ "recommendedWines"
  , inlineResponse20046TotalFound :: !(Int) -- ^ /Required/ "totalFound"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20046
instance A.FromJSON InlineResponse20046 where
  parseJSON = A.withObject "InlineResponse20046" $ \o ->
    InlineResponse20046
      <$> (o .:  "recommendedWines")
      <*> (o .:  "totalFound")

-- | ToJSON InlineResponse20046
instance A.ToJSON InlineResponse20046 where
  toJSON InlineResponse20046 {..} =
   _omitNulls
      [ "recommendedWines" .= inlineResponse20046RecommendedWines
      , "totalFound" .= inlineResponse20046TotalFound
      ]


-- | Construct a value of type 'InlineResponse20046' (by applying it's required fields, if any)
mkInlineResponse20046
  :: [InlineResponse20046RecommendedWines] -- ^ 'inlineResponse20046RecommendedWines' 
  -> Int -- ^ 'inlineResponse20046TotalFound' 
  -> InlineResponse20046
mkInlineResponse20046 inlineResponse20046RecommendedWines inlineResponse20046TotalFound =
  InlineResponse20046
  { inlineResponse20046RecommendedWines
  , inlineResponse20046TotalFound
  }

-- ** InlineResponse20046RecommendedWines
-- | InlineResponse20046RecommendedWines
data InlineResponse20046RecommendedWines = InlineResponse20046RecommendedWines
  { inlineResponse20046RecommendedWinesId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20046RecommendedWinesTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20046RecommendedWinesAverageRating :: !(Double) -- ^ /Required/ "averageRating"
  , inlineResponse20046RecommendedWinesDescription :: !(Text) -- ^ /Required/ "description"
  , inlineResponse20046RecommendedWinesImageUrl :: !(Text) -- ^ /Required/ "imageUrl"
  , inlineResponse20046RecommendedWinesLink :: !(Text) -- ^ /Required/ "link"
  , inlineResponse20046RecommendedWinesPrice :: !(Text) -- ^ /Required/ "price"
  , inlineResponse20046RecommendedWinesRatingCount :: !(Int) -- ^ /Required/ "ratingCount"
  , inlineResponse20046RecommendedWinesScore :: !(Double) -- ^ /Required/ "score"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20046RecommendedWines
instance A.FromJSON InlineResponse20046RecommendedWines where
  parseJSON = A.withObject "InlineResponse20046RecommendedWines" $ \o ->
    InlineResponse20046RecommendedWines
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "averageRating")
      <*> (o .:  "description")
      <*> (o .:  "imageUrl")
      <*> (o .:  "link")
      <*> (o .:  "price")
      <*> (o .:  "ratingCount")
      <*> (o .:  "score")

-- | ToJSON InlineResponse20046RecommendedWines
instance A.ToJSON InlineResponse20046RecommendedWines where
  toJSON InlineResponse20046RecommendedWines {..} =
   _omitNulls
      [ "id" .= inlineResponse20046RecommendedWinesId
      , "title" .= inlineResponse20046RecommendedWinesTitle
      , "averageRating" .= inlineResponse20046RecommendedWinesAverageRating
      , "description" .= inlineResponse20046RecommendedWinesDescription
      , "imageUrl" .= inlineResponse20046RecommendedWinesImageUrl
      , "link" .= inlineResponse20046RecommendedWinesLink
      , "price" .= inlineResponse20046RecommendedWinesPrice
      , "ratingCount" .= inlineResponse20046RecommendedWinesRatingCount
      , "score" .= inlineResponse20046RecommendedWinesScore
      ]


-- | Construct a value of type 'InlineResponse20046RecommendedWines' (by applying it's required fields, if any)
mkInlineResponse20046RecommendedWines
  :: Int -- ^ 'inlineResponse20046RecommendedWinesId' 
  -> Text -- ^ 'inlineResponse20046RecommendedWinesTitle' 
  -> Double -- ^ 'inlineResponse20046RecommendedWinesAverageRating' 
  -> Text -- ^ 'inlineResponse20046RecommendedWinesDescription' 
  -> Text -- ^ 'inlineResponse20046RecommendedWinesImageUrl' 
  -> Text -- ^ 'inlineResponse20046RecommendedWinesLink' 
  -> Text -- ^ 'inlineResponse20046RecommendedWinesPrice' 
  -> Int -- ^ 'inlineResponse20046RecommendedWinesRatingCount' 
  -> Double -- ^ 'inlineResponse20046RecommendedWinesScore' 
  -> InlineResponse20046RecommendedWines
mkInlineResponse20046RecommendedWines inlineResponse20046RecommendedWinesId inlineResponse20046RecommendedWinesTitle inlineResponse20046RecommendedWinesAverageRating inlineResponse20046RecommendedWinesDescription inlineResponse20046RecommendedWinesImageUrl inlineResponse20046RecommendedWinesLink inlineResponse20046RecommendedWinesPrice inlineResponse20046RecommendedWinesRatingCount inlineResponse20046RecommendedWinesScore =
  InlineResponse20046RecommendedWines
  { inlineResponse20046RecommendedWinesId
  , inlineResponse20046RecommendedWinesTitle
  , inlineResponse20046RecommendedWinesAverageRating
  , inlineResponse20046RecommendedWinesDescription
  , inlineResponse20046RecommendedWinesImageUrl
  , inlineResponse20046RecommendedWinesLink
  , inlineResponse20046RecommendedWinesPrice
  , inlineResponse20046RecommendedWinesRatingCount
  , inlineResponse20046RecommendedWinesScore
  }

-- ** InlineResponse20047
-- | InlineResponse20047
data InlineResponse20047 = InlineResponse20047
  { inlineResponse20047Category :: !(Text) -- ^ /Required/ "category"
  , inlineResponse20047Probability :: !(Double) -- ^ /Required/ "probability"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20047
instance A.FromJSON InlineResponse20047 where
  parseJSON = A.withObject "InlineResponse20047" $ \o ->
    InlineResponse20047
      <$> (o .:  "category")
      <*> (o .:  "probability")

-- | ToJSON InlineResponse20047
instance A.ToJSON InlineResponse20047 where
  toJSON InlineResponse20047 {..} =
   _omitNulls
      [ "category" .= inlineResponse20047Category
      , "probability" .= inlineResponse20047Probability
      ]


-- | Construct a value of type 'InlineResponse20047' (by applying it's required fields, if any)
mkInlineResponse20047
  :: Text -- ^ 'inlineResponse20047Category' 
  -> Double -- ^ 'inlineResponse20047Probability' 
  -> InlineResponse20047
mkInlineResponse20047 inlineResponse20047Category inlineResponse20047Probability =
  InlineResponse20047
  { inlineResponse20047Category
  , inlineResponse20047Probability
  }

-- ** InlineResponse20048
-- | InlineResponse20048
data InlineResponse20048 = InlineResponse20048
  { inlineResponse20048Nutrition :: !(InlineResponse20048Nutrition) -- ^ /Required/ "nutrition"
  , inlineResponse20048Category :: !(InlineResponse20048Category) -- ^ /Required/ "category"
  , inlineResponse20048Recipes :: !([InlineResponse20048Recipes]) -- ^ /Required/ "recipes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20048
instance A.FromJSON InlineResponse20048 where
  parseJSON = A.withObject "InlineResponse20048" $ \o ->
    InlineResponse20048
      <$> (o .:  "nutrition")
      <*> (o .:  "category")
      <*> (o .:  "recipes")

-- | ToJSON InlineResponse20048
instance A.ToJSON InlineResponse20048 where
  toJSON InlineResponse20048 {..} =
   _omitNulls
      [ "nutrition" .= inlineResponse20048Nutrition
      , "category" .= inlineResponse20048Category
      , "recipes" .= inlineResponse20048Recipes
      ]


-- | Construct a value of type 'InlineResponse20048' (by applying it's required fields, if any)
mkInlineResponse20048
  :: InlineResponse20048Nutrition -- ^ 'inlineResponse20048Nutrition' 
  -> InlineResponse20048Category -- ^ 'inlineResponse20048Category' 
  -> [InlineResponse20048Recipes] -- ^ 'inlineResponse20048Recipes' 
  -> InlineResponse20048
mkInlineResponse20048 inlineResponse20048Nutrition inlineResponse20048Category inlineResponse20048Recipes =
  InlineResponse20048
  { inlineResponse20048Nutrition
  , inlineResponse20048Category
  , inlineResponse20048Recipes
  }

-- ** InlineResponse20048Category
-- | InlineResponse20048Category
data InlineResponse20048Category = InlineResponse20048Category
  { inlineResponse20048CategoryName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20048CategoryProbability :: !(Double) -- ^ /Required/ "probability"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20048Category
instance A.FromJSON InlineResponse20048Category where
  parseJSON = A.withObject "InlineResponse20048Category" $ \o ->
    InlineResponse20048Category
      <$> (o .:  "name")
      <*> (o .:  "probability")

-- | ToJSON InlineResponse20048Category
instance A.ToJSON InlineResponse20048Category where
  toJSON InlineResponse20048Category {..} =
   _omitNulls
      [ "name" .= inlineResponse20048CategoryName
      , "probability" .= inlineResponse20048CategoryProbability
      ]


-- | Construct a value of type 'InlineResponse20048Category' (by applying it's required fields, if any)
mkInlineResponse20048Category
  :: Text -- ^ 'inlineResponse20048CategoryName' 
  -> Double -- ^ 'inlineResponse20048CategoryProbability' 
  -> InlineResponse20048Category
mkInlineResponse20048Category inlineResponse20048CategoryName inlineResponse20048CategoryProbability =
  InlineResponse20048Category
  { inlineResponse20048CategoryName
  , inlineResponse20048CategoryProbability
  }

-- ** InlineResponse20048Nutrition
-- | InlineResponse20048Nutrition
data InlineResponse20048Nutrition = InlineResponse20048Nutrition
  { inlineResponse20048NutritionRecipesUsed :: !(Int) -- ^ /Required/ "recipesUsed"
  , inlineResponse20048NutritionCalories :: !(InlineResponse20048NutritionCalories) -- ^ /Required/ "calories"
  , inlineResponse20048NutritionFat :: !(InlineResponse20048NutritionCalories) -- ^ /Required/ "fat"
  , inlineResponse20048NutritionProtein :: !(InlineResponse20048NutritionCalories) -- ^ /Required/ "protein"
  , inlineResponse20048NutritionCarbs :: !(InlineResponse20048NutritionCalories) -- ^ /Required/ "carbs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20048Nutrition
instance A.FromJSON InlineResponse20048Nutrition where
  parseJSON = A.withObject "InlineResponse20048Nutrition" $ \o ->
    InlineResponse20048Nutrition
      <$> (o .:  "recipesUsed")
      <*> (o .:  "calories")
      <*> (o .:  "fat")
      <*> (o .:  "protein")
      <*> (o .:  "carbs")

-- | ToJSON InlineResponse20048Nutrition
instance A.ToJSON InlineResponse20048Nutrition where
  toJSON InlineResponse20048Nutrition {..} =
   _omitNulls
      [ "recipesUsed" .= inlineResponse20048NutritionRecipesUsed
      , "calories" .= inlineResponse20048NutritionCalories
      , "fat" .= inlineResponse20048NutritionFat
      , "protein" .= inlineResponse20048NutritionProtein
      , "carbs" .= inlineResponse20048NutritionCarbs
      ]


-- | Construct a value of type 'InlineResponse20048Nutrition' (by applying it's required fields, if any)
mkInlineResponse20048Nutrition
  :: Int -- ^ 'inlineResponse20048NutritionRecipesUsed' 
  -> InlineResponse20048NutritionCalories -- ^ 'inlineResponse20048NutritionCalories' 
  -> InlineResponse20048NutritionCalories -- ^ 'inlineResponse20048NutritionFat' 
  -> InlineResponse20048NutritionCalories -- ^ 'inlineResponse20048NutritionProtein' 
  -> InlineResponse20048NutritionCalories -- ^ 'inlineResponse20048NutritionCarbs' 
  -> InlineResponse20048Nutrition
mkInlineResponse20048Nutrition inlineResponse20048NutritionRecipesUsed inlineResponse20048NutritionCalories inlineResponse20048NutritionFat inlineResponse20048NutritionProtein inlineResponse20048NutritionCarbs =
  InlineResponse20048Nutrition
  { inlineResponse20048NutritionRecipesUsed
  , inlineResponse20048NutritionCalories
  , inlineResponse20048NutritionFat
  , inlineResponse20048NutritionProtein
  , inlineResponse20048NutritionCarbs
  }

-- ** InlineResponse20048NutritionCalories
-- | InlineResponse20048NutritionCalories
data InlineResponse20048NutritionCalories = InlineResponse20048NutritionCalories
  { inlineResponse20048NutritionCaloriesValue :: !(Double) -- ^ /Required/ "value"
  , inlineResponse20048NutritionCaloriesUnit :: !(Text) -- ^ /Required/ "unit"
  , inlineResponse20048NutritionCaloriesConfidenceRange95Percent :: !(InlineResponse20048NutritionCaloriesConfidenceRange95Percent) -- ^ /Required/ "confidenceRange95Percent"
  , inlineResponse20048NutritionCaloriesStandardDeviation :: !(Double) -- ^ /Required/ "standardDeviation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20048NutritionCalories
instance A.FromJSON InlineResponse20048NutritionCalories where
  parseJSON = A.withObject "InlineResponse20048NutritionCalories" $ \o ->
    InlineResponse20048NutritionCalories
      <$> (o .:  "value")
      <*> (o .:  "unit")
      <*> (o .:  "confidenceRange95Percent")
      <*> (o .:  "standardDeviation")

-- | ToJSON InlineResponse20048NutritionCalories
instance A.ToJSON InlineResponse20048NutritionCalories where
  toJSON InlineResponse20048NutritionCalories {..} =
   _omitNulls
      [ "value" .= inlineResponse20048NutritionCaloriesValue
      , "unit" .= inlineResponse20048NutritionCaloriesUnit
      , "confidenceRange95Percent" .= inlineResponse20048NutritionCaloriesConfidenceRange95Percent
      , "standardDeviation" .= inlineResponse20048NutritionCaloriesStandardDeviation
      ]


-- | Construct a value of type 'InlineResponse20048NutritionCalories' (by applying it's required fields, if any)
mkInlineResponse20048NutritionCalories
  :: Double -- ^ 'inlineResponse20048NutritionCaloriesValue' 
  -> Text -- ^ 'inlineResponse20048NutritionCaloriesUnit' 
  -> InlineResponse20048NutritionCaloriesConfidenceRange95Percent -- ^ 'inlineResponse20048NutritionCaloriesConfidenceRange95Percent' 
  -> Double -- ^ 'inlineResponse20048NutritionCaloriesStandardDeviation' 
  -> InlineResponse20048NutritionCalories
mkInlineResponse20048NutritionCalories inlineResponse20048NutritionCaloriesValue inlineResponse20048NutritionCaloriesUnit inlineResponse20048NutritionCaloriesConfidenceRange95Percent inlineResponse20048NutritionCaloriesStandardDeviation =
  InlineResponse20048NutritionCalories
  { inlineResponse20048NutritionCaloriesValue
  , inlineResponse20048NutritionCaloriesUnit
  , inlineResponse20048NutritionCaloriesConfidenceRange95Percent
  , inlineResponse20048NutritionCaloriesStandardDeviation
  }

-- ** InlineResponse20048NutritionCaloriesConfidenceRange95Percent
-- | InlineResponse20048NutritionCaloriesConfidenceRange95Percent
data InlineResponse20048NutritionCaloriesConfidenceRange95Percent = InlineResponse20048NutritionCaloriesConfidenceRange95Percent
  { inlineResponse20048NutritionCaloriesConfidenceRange95PercentMin :: !(Double) -- ^ /Required/ "min"
  , inlineResponse20048NutritionCaloriesConfidenceRange95PercentMax :: !(Double) -- ^ /Required/ "max"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20048NutritionCaloriesConfidenceRange95Percent
instance A.FromJSON InlineResponse20048NutritionCaloriesConfidenceRange95Percent where
  parseJSON = A.withObject "InlineResponse20048NutritionCaloriesConfidenceRange95Percent" $ \o ->
    InlineResponse20048NutritionCaloriesConfidenceRange95Percent
      <$> (o .:  "min")
      <*> (o .:  "max")

-- | ToJSON InlineResponse20048NutritionCaloriesConfidenceRange95Percent
instance A.ToJSON InlineResponse20048NutritionCaloriesConfidenceRange95Percent where
  toJSON InlineResponse20048NutritionCaloriesConfidenceRange95Percent {..} =
   _omitNulls
      [ "min" .= inlineResponse20048NutritionCaloriesConfidenceRange95PercentMin
      , "max" .= inlineResponse20048NutritionCaloriesConfidenceRange95PercentMax
      ]


-- | Construct a value of type 'InlineResponse20048NutritionCaloriesConfidenceRange95Percent' (by applying it's required fields, if any)
mkInlineResponse20048NutritionCaloriesConfidenceRange95Percent
  :: Double -- ^ 'inlineResponse20048NutritionCaloriesConfidenceRange95PercentMin' 
  -> Double -- ^ 'inlineResponse20048NutritionCaloriesConfidenceRange95PercentMax' 
  -> InlineResponse20048NutritionCaloriesConfidenceRange95Percent
mkInlineResponse20048NutritionCaloriesConfidenceRange95Percent inlineResponse20048NutritionCaloriesConfidenceRange95PercentMin inlineResponse20048NutritionCaloriesConfidenceRange95PercentMax =
  InlineResponse20048NutritionCaloriesConfidenceRange95Percent
  { inlineResponse20048NutritionCaloriesConfidenceRange95PercentMin
  , inlineResponse20048NutritionCaloriesConfidenceRange95PercentMax
  }

-- ** InlineResponse20048Recipes
-- | InlineResponse20048Recipes
data InlineResponse20048Recipes = InlineResponse20048Recipes
  { inlineResponse20048RecipesId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse20048RecipesTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20048RecipesImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse20048RecipesUrl :: !(Text) -- ^ /Required/ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20048Recipes
instance A.FromJSON InlineResponse20048Recipes where
  parseJSON = A.withObject "InlineResponse20048Recipes" $ \o ->
    InlineResponse20048Recipes
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")
      <*> (o .:  "url")

-- | ToJSON InlineResponse20048Recipes
instance A.ToJSON InlineResponse20048Recipes where
  toJSON InlineResponse20048Recipes {..} =
   _omitNulls
      [ "id" .= inlineResponse20048RecipesId
      , "title" .= inlineResponse20048RecipesTitle
      , "imageType" .= inlineResponse20048RecipesImageType
      , "url" .= inlineResponse20048RecipesUrl
      ]


-- | Construct a value of type 'InlineResponse20048Recipes' (by applying it's required fields, if any)
mkInlineResponse20048Recipes
  :: Int -- ^ 'inlineResponse20048RecipesId' 
  -> Text -- ^ 'inlineResponse20048RecipesTitle' 
  -> Text -- ^ 'inlineResponse20048RecipesImageType' 
  -> Text -- ^ 'inlineResponse20048RecipesUrl' 
  -> InlineResponse20048Recipes
mkInlineResponse20048Recipes inlineResponse20048RecipesId inlineResponse20048RecipesTitle inlineResponse20048RecipesImageType inlineResponse20048RecipesUrl =
  InlineResponse20048Recipes
  { inlineResponse20048RecipesId
  , inlineResponse20048RecipesTitle
  , inlineResponse20048RecipesImageType
  , inlineResponse20048RecipesUrl
  }

-- ** InlineResponse20049
-- | InlineResponse20049
data InlineResponse20049 = InlineResponse20049
  { inlineResponse20049Answer :: !(Text) -- ^ /Required/ "answer"
  , inlineResponse20049Image :: !(Text) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20049
instance A.FromJSON InlineResponse20049 where
  parseJSON = A.withObject "InlineResponse20049" $ \o ->
    InlineResponse20049
      <$> (o .:  "answer")
      <*> (o .:  "image")

-- | ToJSON InlineResponse20049
instance A.ToJSON InlineResponse20049 where
  toJSON InlineResponse20049 {..} =
   _omitNulls
      [ "answer" .= inlineResponse20049Answer
      , "image" .= inlineResponse20049Image
      ]


-- | Construct a value of type 'InlineResponse20049' (by applying it's required fields, if any)
mkInlineResponse20049
  :: Text -- ^ 'inlineResponse20049Answer' 
  -> Text -- ^ 'inlineResponse20049Image' 
  -> InlineResponse20049
mkInlineResponse20049 inlineResponse20049Answer inlineResponse20049Image =
  InlineResponse20049
  { inlineResponse20049Answer
  , inlineResponse20049Image
  }

-- ** InlineResponse2005
-- | InlineResponse2005
data InlineResponse2005 = InlineResponse2005
  { inlineResponse2005Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2005Title :: !(Text) -- ^ /Required/ "title"
  , inlineResponse2005ImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse2005ReadyInMinutes :: !(Int) -- ^ /Required/ "readyInMinutes"
  , inlineResponse2005Servings :: !(Double) -- ^ /Required/ "servings"
  , inlineResponse2005SourceUrl :: !(Text) -- ^ /Required/ "sourceUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2005
instance A.FromJSON InlineResponse2005 where
  parseJSON = A.withObject "InlineResponse2005" $ \o ->
    InlineResponse2005
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")
      <*> (o .:  "readyInMinutes")
      <*> (o .:  "servings")
      <*> (o .:  "sourceUrl")

-- | ToJSON InlineResponse2005
instance A.ToJSON InlineResponse2005 where
  toJSON InlineResponse2005 {..} =
   _omitNulls
      [ "id" .= inlineResponse2005Id
      , "title" .= inlineResponse2005Title
      , "imageType" .= inlineResponse2005ImageType
      , "readyInMinutes" .= inlineResponse2005ReadyInMinutes
      , "servings" .= inlineResponse2005Servings
      , "sourceUrl" .= inlineResponse2005SourceUrl
      ]


-- | Construct a value of type 'InlineResponse2005' (by applying it's required fields, if any)
mkInlineResponse2005
  :: Int -- ^ 'inlineResponse2005Id' 
  -> Text -- ^ 'inlineResponse2005Title' 
  -> Text -- ^ 'inlineResponse2005ImageType' 
  -> Int -- ^ 'inlineResponse2005ReadyInMinutes' 
  -> Double -- ^ 'inlineResponse2005Servings' 
  -> Text -- ^ 'inlineResponse2005SourceUrl' 
  -> InlineResponse2005
mkInlineResponse2005 inlineResponse2005Id inlineResponse2005Title inlineResponse2005ImageType inlineResponse2005ReadyInMinutes inlineResponse2005Servings inlineResponse2005SourceUrl =
  InlineResponse2005
  { inlineResponse2005Id
  , inlineResponse2005Title
  , inlineResponse2005ImageType
  , inlineResponse2005ReadyInMinutes
  , inlineResponse2005Servings
  , inlineResponse2005SourceUrl
  }

-- ** InlineResponse20050
-- | InlineResponse20050
data InlineResponse20050 = InlineResponse20050
  { inlineResponse20050Annotations :: !([A.Value]) -- ^ /Required/ "annotations"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20050
instance A.FromJSON InlineResponse20050 where
  parseJSON = A.withObject "InlineResponse20050" $ \o ->
    InlineResponse20050
      <$> (o .:  "annotations")

-- | ToJSON InlineResponse20050
instance A.ToJSON InlineResponse20050 where
  toJSON InlineResponse20050 {..} =
   _omitNulls
      [ "annotations" .= inlineResponse20050Annotations
      ]


-- | Construct a value of type 'InlineResponse20050' (by applying it's required fields, if any)
mkInlineResponse20050
  :: [A.Value] -- ^ 'inlineResponse20050Annotations' 
  -> InlineResponse20050
mkInlineResponse20050 inlineResponse20050Annotations =
  InlineResponse20050
  { inlineResponse20050Annotations
  }

-- ** InlineResponse20051
-- | InlineResponse20051
data InlineResponse20051 = InlineResponse20051
  { inlineResponse20051Articles :: !([A.Value]) -- ^ /Required/ "Articles"
  , inlineResponse20051GroceryProducts :: !([A.Value]) -- ^ /Required/ "Grocery Products"
  , inlineResponse20051MenuItems :: !([A.Value]) -- ^ /Required/ "Menu Items"
  , inlineResponse20051Recipes :: !([A.Value]) -- ^ /Required/ "Recipes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20051
instance A.FromJSON InlineResponse20051 where
  parseJSON = A.withObject "InlineResponse20051" $ \o ->
    InlineResponse20051
      <$> (o .:  "Articles")
      <*> (o .:  "Grocery Products")
      <*> (o .:  "Menu Items")
      <*> (o .:  "Recipes")

-- | ToJSON InlineResponse20051
instance A.ToJSON InlineResponse20051 where
  toJSON InlineResponse20051 {..} =
   _omitNulls
      [ "Articles" .= inlineResponse20051Articles
      , "Grocery Products" .= inlineResponse20051GroceryProducts
      , "Menu Items" .= inlineResponse20051MenuItems
      , "Recipes" .= inlineResponse20051Recipes
      ]


-- | Construct a value of type 'InlineResponse20051' (by applying it's required fields, if any)
mkInlineResponse20051
  :: [A.Value] -- ^ 'inlineResponse20051Articles' 
  -> [A.Value] -- ^ 'inlineResponse20051GroceryProducts' 
  -> [A.Value] -- ^ 'inlineResponse20051MenuItems' 
  -> [A.Value] -- ^ 'inlineResponse20051Recipes' 
  -> InlineResponse20051
mkInlineResponse20051 inlineResponse20051Articles inlineResponse20051GroceryProducts inlineResponse20051MenuItems inlineResponse20051Recipes =
  InlineResponse20051
  { inlineResponse20051Articles
  , inlineResponse20051GroceryProducts
  , inlineResponse20051MenuItems
  , inlineResponse20051Recipes
  }

-- ** InlineResponse20052
-- | InlineResponse20052
data InlineResponse20052 = InlineResponse20052
  { inlineResponse20052Query :: !(Text) -- ^ /Required/ "query"
  , inlineResponse20052TotalResults :: !(Int) -- ^ /Required/ "totalResults"
  , inlineResponse20052Limit :: !(Int) -- ^ /Required/ "limit"
  , inlineResponse20052Offset :: !(Int) -- ^ /Required/ "offset"
  , inlineResponse20052SearchResults :: !([InlineResponse20052SearchResults]) -- ^ /Required/ "searchResults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20052
instance A.FromJSON InlineResponse20052 where
  parseJSON = A.withObject "InlineResponse20052" $ \o ->
    InlineResponse20052
      <$> (o .:  "query")
      <*> (o .:  "totalResults")
      <*> (o .:  "limit")
      <*> (o .:  "offset")
      <*> (o .:  "searchResults")

-- | ToJSON InlineResponse20052
instance A.ToJSON InlineResponse20052 where
  toJSON InlineResponse20052 {..} =
   _omitNulls
      [ "query" .= inlineResponse20052Query
      , "totalResults" .= inlineResponse20052TotalResults
      , "limit" .= inlineResponse20052Limit
      , "offset" .= inlineResponse20052Offset
      , "searchResults" .= inlineResponse20052SearchResults
      ]


-- | Construct a value of type 'InlineResponse20052' (by applying it's required fields, if any)
mkInlineResponse20052
  :: Text -- ^ 'inlineResponse20052Query' 
  -> Int -- ^ 'inlineResponse20052TotalResults' 
  -> Int -- ^ 'inlineResponse20052Limit' 
  -> Int -- ^ 'inlineResponse20052Offset' 
  -> [InlineResponse20052SearchResults] -- ^ 'inlineResponse20052SearchResults' 
  -> InlineResponse20052
mkInlineResponse20052 inlineResponse20052Query inlineResponse20052TotalResults inlineResponse20052Limit inlineResponse20052Offset inlineResponse20052SearchResults =
  InlineResponse20052
  { inlineResponse20052Query
  , inlineResponse20052TotalResults
  , inlineResponse20052Limit
  , inlineResponse20052Offset
  , inlineResponse20052SearchResults
  }

-- ** InlineResponse20052Results
-- | InlineResponse20052Results
data InlineResponse20052Results = InlineResponse20052Results
  { inlineResponse20052ResultsId :: !(Text) -- ^ /Required/ "id"
  , inlineResponse20052ResultsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20052ResultsImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse20052ResultsLink :: !(Text) -- ^ /Required/ "link"
  , inlineResponse20052ResultsType :: !(Text) -- ^ /Required/ "type"
  , inlineResponse20052ResultsRelevance :: !(Double) -- ^ /Required/ "relevance"
  , inlineResponse20052ResultsContent :: !(Text) -- ^ /Required/ "content"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20052Results
instance A.FromJSON InlineResponse20052Results where
  parseJSON = A.withObject "InlineResponse20052Results" $ \o ->
    InlineResponse20052Results
      <$> (o .:  "id")
      <*> (o .:  "name")
      <*> (o .:  "image")
      <*> (o .:  "link")
      <*> (o .:  "type")
      <*> (o .:  "relevance")
      <*> (o .:  "content")

-- | ToJSON InlineResponse20052Results
instance A.ToJSON InlineResponse20052Results where
  toJSON InlineResponse20052Results {..} =
   _omitNulls
      [ "id" .= inlineResponse20052ResultsId
      , "name" .= inlineResponse20052ResultsName
      , "image" .= inlineResponse20052ResultsImage
      , "link" .= inlineResponse20052ResultsLink
      , "type" .= inlineResponse20052ResultsType
      , "relevance" .= inlineResponse20052ResultsRelevance
      , "content" .= inlineResponse20052ResultsContent
      ]


-- | Construct a value of type 'InlineResponse20052Results' (by applying it's required fields, if any)
mkInlineResponse20052Results
  :: Text -- ^ 'inlineResponse20052ResultsId' 
  -> Text -- ^ 'inlineResponse20052ResultsName' 
  -> Text -- ^ 'inlineResponse20052ResultsImage' 
  -> Text -- ^ 'inlineResponse20052ResultsLink' 
  -> Text -- ^ 'inlineResponse20052ResultsType' 
  -> Double -- ^ 'inlineResponse20052ResultsRelevance' 
  -> Text -- ^ 'inlineResponse20052ResultsContent' 
  -> InlineResponse20052Results
mkInlineResponse20052Results inlineResponse20052ResultsId inlineResponse20052ResultsName inlineResponse20052ResultsImage inlineResponse20052ResultsLink inlineResponse20052ResultsType inlineResponse20052ResultsRelevance inlineResponse20052ResultsContent =
  InlineResponse20052Results
  { inlineResponse20052ResultsId
  , inlineResponse20052ResultsName
  , inlineResponse20052ResultsImage
  , inlineResponse20052ResultsLink
  , inlineResponse20052ResultsType
  , inlineResponse20052ResultsRelevance
  , inlineResponse20052ResultsContent
  }

-- ** InlineResponse20052SearchResults
-- | InlineResponse20052SearchResults
data InlineResponse20052SearchResults = InlineResponse20052SearchResults
  { inlineResponse20052SearchResultsName :: !(Text) -- ^ /Required/ "name"
  , inlineResponse20052SearchResultsTotalResults :: !(Int) -- ^ /Required/ "totalResults"
  , inlineResponse20052SearchResultsResults :: !(Maybe [InlineResponse20052Results]) -- ^ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20052SearchResults
instance A.FromJSON InlineResponse20052SearchResults where
  parseJSON = A.withObject "InlineResponse20052SearchResults" $ \o ->
    InlineResponse20052SearchResults
      <$> (o .:  "name")
      <*> (o .:  "totalResults")
      <*> (o .:? "results")

-- | ToJSON InlineResponse20052SearchResults
instance A.ToJSON InlineResponse20052SearchResults where
  toJSON InlineResponse20052SearchResults {..} =
   _omitNulls
      [ "name" .= inlineResponse20052SearchResultsName
      , "totalResults" .= inlineResponse20052SearchResultsTotalResults
      , "results" .= inlineResponse20052SearchResultsResults
      ]


-- | Construct a value of type 'InlineResponse20052SearchResults' (by applying it's required fields, if any)
mkInlineResponse20052SearchResults
  :: Text -- ^ 'inlineResponse20052SearchResultsName' 
  -> Int -- ^ 'inlineResponse20052SearchResultsTotalResults' 
  -> InlineResponse20052SearchResults
mkInlineResponse20052SearchResults inlineResponse20052SearchResultsName inlineResponse20052SearchResultsTotalResults =
  InlineResponse20052SearchResults
  { inlineResponse20052SearchResultsName
  , inlineResponse20052SearchResultsTotalResults
  , inlineResponse20052SearchResultsResults = Nothing
  }

-- ** InlineResponse20053
-- | InlineResponse20053
data InlineResponse20053 = InlineResponse20053
  { inlineResponse20053Videos :: !([InlineResponse20053Videos]) -- ^ /Required/ "videos"
  , inlineResponse20053TotalResults :: !(Int) -- ^ /Required/ "totalResults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20053
instance A.FromJSON InlineResponse20053 where
  parseJSON = A.withObject "InlineResponse20053" $ \o ->
    InlineResponse20053
      <$> (o .:  "videos")
      <*> (o .:  "totalResults")

-- | ToJSON InlineResponse20053
instance A.ToJSON InlineResponse20053 where
  toJSON InlineResponse20053 {..} =
   _omitNulls
      [ "videos" .= inlineResponse20053Videos
      , "totalResults" .= inlineResponse20053TotalResults
      ]


-- | Construct a value of type 'InlineResponse20053' (by applying it's required fields, if any)
mkInlineResponse20053
  :: [InlineResponse20053Videos] -- ^ 'inlineResponse20053Videos' 
  -> Int -- ^ 'inlineResponse20053TotalResults' 
  -> InlineResponse20053
mkInlineResponse20053 inlineResponse20053Videos inlineResponse20053TotalResults =
  InlineResponse20053
  { inlineResponse20053Videos
  , inlineResponse20053TotalResults
  }

-- ** InlineResponse20053Videos
-- | InlineResponse20053Videos
data InlineResponse20053Videos = InlineResponse20053Videos
  { inlineResponse20053VideosTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse20053VideosLength :: !(Int) -- ^ /Required/ "length"
  , inlineResponse20053VideosRating :: !(Double) -- ^ /Required/ "rating"
  , inlineResponse20053VideosShortTitle :: !(Text) -- ^ /Required/ "shortTitle"
  , inlineResponse20053VideosThumbnail :: !(Text) -- ^ /Required/ "thumbnail"
  , inlineResponse20053VideosViews :: !(Int) -- ^ /Required/ "views"
  , inlineResponse20053VideosYouTubeId :: !(Text) -- ^ /Required/ "youTubeId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20053Videos
instance A.FromJSON InlineResponse20053Videos where
  parseJSON = A.withObject "InlineResponse20053Videos" $ \o ->
    InlineResponse20053Videos
      <$> (o .:  "title")
      <*> (o .:  "length")
      <*> (o .:  "rating")
      <*> (o .:  "shortTitle")
      <*> (o .:  "thumbnail")
      <*> (o .:  "views")
      <*> (o .:  "youTubeId")

-- | ToJSON InlineResponse20053Videos
instance A.ToJSON InlineResponse20053Videos where
  toJSON InlineResponse20053Videos {..} =
   _omitNulls
      [ "title" .= inlineResponse20053VideosTitle
      , "length" .= inlineResponse20053VideosLength
      , "rating" .= inlineResponse20053VideosRating
      , "shortTitle" .= inlineResponse20053VideosShortTitle
      , "thumbnail" .= inlineResponse20053VideosThumbnail
      , "views" .= inlineResponse20053VideosViews
      , "youTubeId" .= inlineResponse20053VideosYouTubeId
      ]


-- | Construct a value of type 'InlineResponse20053Videos' (by applying it's required fields, if any)
mkInlineResponse20053Videos
  :: Text -- ^ 'inlineResponse20053VideosTitle' 
  -> Int -- ^ 'inlineResponse20053VideosLength' 
  -> Double -- ^ 'inlineResponse20053VideosRating' 
  -> Text -- ^ 'inlineResponse20053VideosShortTitle' 
  -> Text -- ^ 'inlineResponse20053VideosThumbnail' 
  -> Int -- ^ 'inlineResponse20053VideosViews' 
  -> Text -- ^ 'inlineResponse20053VideosYouTubeId' 
  -> InlineResponse20053Videos
mkInlineResponse20053Videos inlineResponse20053VideosTitle inlineResponse20053VideosLength inlineResponse20053VideosRating inlineResponse20053VideosShortTitle inlineResponse20053VideosThumbnail inlineResponse20053VideosViews inlineResponse20053VideosYouTubeId =
  InlineResponse20053Videos
  { inlineResponse20053VideosTitle
  , inlineResponse20053VideosLength
  , inlineResponse20053VideosRating
  , inlineResponse20053VideosShortTitle
  , inlineResponse20053VideosThumbnail
  , inlineResponse20053VideosViews
  , inlineResponse20053VideosYouTubeId
  }

-- ** InlineResponse20054
-- | InlineResponse20054
data InlineResponse20054 = InlineResponse20054
  { inlineResponse20054Text :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20054
instance A.FromJSON InlineResponse20054 where
  parseJSON = A.withObject "InlineResponse20054" $ \o ->
    InlineResponse20054
      <$> (o .:  "text")

-- | ToJSON InlineResponse20054
instance A.ToJSON InlineResponse20054 where
  toJSON InlineResponse20054 {..} =
   _omitNulls
      [ "text" .= inlineResponse20054Text
      ]


-- | Construct a value of type 'InlineResponse20054' (by applying it's required fields, if any)
mkInlineResponse20054
  :: Text -- ^ 'inlineResponse20054Text' 
  -> InlineResponse20054
mkInlineResponse20054 inlineResponse20054Text =
  InlineResponse20054
  { inlineResponse20054Text
  }

-- ** InlineResponse20055
-- | InlineResponse20055
data InlineResponse20055 = InlineResponse20055
  { inlineResponse20055AnswerText :: !(Text) -- ^ /Required/ "answerText"
  , inlineResponse20055Media :: !([A.Value]) -- ^ /Required/ "media"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20055
instance A.FromJSON InlineResponse20055 where
  parseJSON = A.withObject "InlineResponse20055" $ \o ->
    InlineResponse20055
      <$> (o .:  "answerText")
      <*> (o .:  "media")

-- | ToJSON InlineResponse20055
instance A.ToJSON InlineResponse20055 where
  toJSON InlineResponse20055 {..} =
   _omitNulls
      [ "answerText" .= inlineResponse20055AnswerText
      , "media" .= inlineResponse20055Media
      ]


-- | Construct a value of type 'InlineResponse20055' (by applying it's required fields, if any)
mkInlineResponse20055
  :: Text -- ^ 'inlineResponse20055AnswerText' 
  -> [A.Value] -- ^ 'inlineResponse20055Media' 
  -> InlineResponse20055
mkInlineResponse20055 inlineResponse20055AnswerText inlineResponse20055Media =
  InlineResponse20055
  { inlineResponse20055AnswerText
  , inlineResponse20055Media
  }

-- ** InlineResponse20056
-- | InlineResponse20056
data InlineResponse20056 = InlineResponse20056
  { inlineResponse20056Suggests :: !(InlineResponse20056Suggests) -- ^ /Required/ "suggests"
  , inlineResponse20056Words :: !([A.Value]) -- ^ /Required/ "words"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20056
instance A.FromJSON InlineResponse20056 where
  parseJSON = A.withObject "InlineResponse20056" $ \o ->
    InlineResponse20056
      <$> (o .:  "suggests")
      <*> (o .:  "words")

-- | ToJSON InlineResponse20056
instance A.ToJSON InlineResponse20056 where
  toJSON InlineResponse20056 {..} =
   _omitNulls
      [ "suggests" .= inlineResponse20056Suggests
      , "words" .= inlineResponse20056Words
      ]


-- | Construct a value of type 'InlineResponse20056' (by applying it's required fields, if any)
mkInlineResponse20056
  :: InlineResponse20056Suggests -- ^ 'inlineResponse20056Suggests' 
  -> [A.Value] -- ^ 'inlineResponse20056Words' 
  -> InlineResponse20056
mkInlineResponse20056 inlineResponse20056Suggests inlineResponse20056Words =
  InlineResponse20056
  { inlineResponse20056Suggests
  , inlineResponse20056Words
  }

-- ** InlineResponse20056Suggests
-- | InlineResponse20056Suggests
data InlineResponse20056Suggests = InlineResponse20056Suggests
  { inlineResponse20056Suggests :: !([A.Value]) -- ^ /Required/ "_"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse20056Suggests
instance A.FromJSON InlineResponse20056Suggests where
  parseJSON = A.withObject "InlineResponse20056Suggests" $ \o ->
    InlineResponse20056Suggests
      <$> (o .:  "_")

-- | ToJSON InlineResponse20056Suggests
instance A.ToJSON InlineResponse20056Suggests where
  toJSON InlineResponse20056Suggests {..} =
   _omitNulls
      [ "_" .= inlineResponse20056Suggests
      ]


-- | Construct a value of type 'InlineResponse20056Suggests' (by applying it's required fields, if any)
mkInlineResponse20056Suggests
  :: [A.Value] -- ^ 'inlineResponse20056Suggests' 
  -> InlineResponse20056Suggests
mkInlineResponse20056Suggests inlineResponse20056Suggests =
  InlineResponse20056Suggests
  { inlineResponse20056Suggests
  }

-- ** InlineResponse2006
-- | InlineResponse2006
data InlineResponse2006 = InlineResponse2006
  { inlineResponse2006Recipes :: !([InlineResponse2006Recipes]) -- ^ /Required/ "recipes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2006
instance A.FromJSON InlineResponse2006 where
  parseJSON = A.withObject "InlineResponse2006" $ \o ->
    InlineResponse2006
      <$> (o .:  "recipes")

-- | ToJSON InlineResponse2006
instance A.ToJSON InlineResponse2006 where
  toJSON InlineResponse2006 {..} =
   _omitNulls
      [ "recipes" .= inlineResponse2006Recipes
      ]


-- | Construct a value of type 'InlineResponse2006' (by applying it's required fields, if any)
mkInlineResponse2006
  :: [InlineResponse2006Recipes] -- ^ 'inlineResponse2006Recipes' 
  -> InlineResponse2006
mkInlineResponse2006 inlineResponse2006Recipes =
  InlineResponse2006
  { inlineResponse2006Recipes
  }

-- ** InlineResponse2006Recipes
-- | InlineResponse2006Recipes
data InlineResponse2006Recipes = InlineResponse2006Recipes
  { inlineResponse2006RecipesId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2006RecipesTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse2006RecipesImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse2006RecipesImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse2006RecipesServings :: !(Double) -- ^ /Required/ "servings"
  , inlineResponse2006RecipesReadyInMinutes :: !(Int) -- ^ /Required/ "readyInMinutes"
  , inlineResponse2006RecipesLicense :: !(Text) -- ^ /Required/ "license"
  , inlineResponse2006RecipesSourceName :: !(Text) -- ^ /Required/ "sourceName"
  , inlineResponse2006RecipesSourceUrl :: !(Text) -- ^ /Required/ "sourceUrl"
  , inlineResponse2006RecipesSpoonacularSourceUrl :: !(Text) -- ^ /Required/ "spoonacularSourceUrl"
  , inlineResponse2006RecipesAggregateLikes :: !(Double) -- ^ /Required/ "aggregateLikes"
  , inlineResponse2006RecipesHealthScore :: !(Double) -- ^ /Required/ "healthScore"
  , inlineResponse2006RecipesSpoonacularScore :: !(Double) -- ^ /Required/ "spoonacularScore"
  , inlineResponse2006RecipesPricePerServing :: !(Double) -- ^ /Required/ "pricePerServing"
  , inlineResponse2006RecipesAnalyzedInstructions :: !(Maybe [A.Value]) -- ^ "analyzedInstructions"
  , inlineResponse2006RecipesCheap :: !(Bool) -- ^ /Required/ "cheap"
  , inlineResponse2006RecipesCreditsText :: !(Text) -- ^ /Required/ "creditsText"
  , inlineResponse2006RecipesCuisines :: !(Maybe [Text]) -- ^ "cuisines"
  , inlineResponse2006RecipesDairyFree :: !(Bool) -- ^ /Required/ "dairyFree"
  , inlineResponse2006RecipesDiets :: !(Maybe [Text]) -- ^ "diets"
  , inlineResponse2006RecipesGaps :: !(Text) -- ^ /Required/ "gaps"
  , inlineResponse2006RecipesGlutenFree :: !(Bool) -- ^ /Required/ "glutenFree"
  , inlineResponse2006RecipesInstructions :: !(Text) -- ^ /Required/ "instructions"
  , inlineResponse2006RecipesKetogenic :: !(Bool) -- ^ /Required/ "ketogenic"
  , inlineResponse2006RecipesLowFodmap :: !(Bool) -- ^ /Required/ "lowFodmap"
  , inlineResponse2006RecipesOccasions :: !(Maybe [Text]) -- ^ "occasions"
  , inlineResponse2006RecipesSustainable :: !(Bool) -- ^ /Required/ "sustainable"
  , inlineResponse2006RecipesVegan :: !(Bool) -- ^ /Required/ "vegan"
  , inlineResponse2006RecipesVegetarian :: !(Bool) -- ^ /Required/ "vegetarian"
  , inlineResponse2006RecipesVeryHealthy :: !(Bool) -- ^ /Required/ "veryHealthy"
  , inlineResponse2006RecipesVeryPopular :: !(Bool) -- ^ /Required/ "veryPopular"
  , inlineResponse2006RecipesWhole30 :: !(Bool) -- ^ /Required/ "whole30"
  , inlineResponse2006RecipesWeightWatcherSmartPoints :: !(Double) -- ^ /Required/ "weightWatcherSmartPoints"
  , inlineResponse2006RecipesDishTypes :: !(Maybe [Text]) -- ^ "dishTypes"
  , inlineResponse2006RecipesExtendedIngredients :: !(Maybe [InlineResponse2003ExtendedIngredients]) -- ^ "extendedIngredients"
  , inlineResponse2006RecipesSummary :: !(Text) -- ^ /Required/ "summary"
  , inlineResponse2006RecipesWinePairing :: !(Maybe InlineResponse2003WinePairing) -- ^ "winePairing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2006Recipes
instance A.FromJSON InlineResponse2006Recipes where
  parseJSON = A.withObject "InlineResponse2006Recipes" $ \o ->
    InlineResponse2006Recipes
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "servings")
      <*> (o .:  "readyInMinutes")
      <*> (o .:  "license")
      <*> (o .:  "sourceName")
      <*> (o .:  "sourceUrl")
      <*> (o .:  "spoonacularSourceUrl")
      <*> (o .:  "aggregateLikes")
      <*> (o .:  "healthScore")
      <*> (o .:  "spoonacularScore")
      <*> (o .:  "pricePerServing")
      <*> (o .:? "analyzedInstructions")
      <*> (o .:  "cheap")
      <*> (o .:  "creditsText")
      <*> (o .:? "cuisines")
      <*> (o .:  "dairyFree")
      <*> (o .:? "diets")
      <*> (o .:  "gaps")
      <*> (o .:  "glutenFree")
      <*> (o .:  "instructions")
      <*> (o .:  "ketogenic")
      <*> (o .:  "lowFodmap")
      <*> (o .:? "occasions")
      <*> (o .:  "sustainable")
      <*> (o .:  "vegan")
      <*> (o .:  "vegetarian")
      <*> (o .:  "veryHealthy")
      <*> (o .:  "veryPopular")
      <*> (o .:  "whole30")
      <*> (o .:  "weightWatcherSmartPoints")
      <*> (o .:? "dishTypes")
      <*> (o .:? "extendedIngredients")
      <*> (o .:  "summary")
      <*> (o .:? "winePairing")

-- | ToJSON InlineResponse2006Recipes
instance A.ToJSON InlineResponse2006Recipes where
  toJSON InlineResponse2006Recipes {..} =
   _omitNulls
      [ "id" .= inlineResponse2006RecipesId
      , "title" .= inlineResponse2006RecipesTitle
      , "image" .= inlineResponse2006RecipesImage
      , "imageType" .= inlineResponse2006RecipesImageType
      , "servings" .= inlineResponse2006RecipesServings
      , "readyInMinutes" .= inlineResponse2006RecipesReadyInMinutes
      , "license" .= inlineResponse2006RecipesLicense
      , "sourceName" .= inlineResponse2006RecipesSourceName
      , "sourceUrl" .= inlineResponse2006RecipesSourceUrl
      , "spoonacularSourceUrl" .= inlineResponse2006RecipesSpoonacularSourceUrl
      , "aggregateLikes" .= inlineResponse2006RecipesAggregateLikes
      , "healthScore" .= inlineResponse2006RecipesHealthScore
      , "spoonacularScore" .= inlineResponse2006RecipesSpoonacularScore
      , "pricePerServing" .= inlineResponse2006RecipesPricePerServing
      , "analyzedInstructions" .= inlineResponse2006RecipesAnalyzedInstructions
      , "cheap" .= inlineResponse2006RecipesCheap
      , "creditsText" .= inlineResponse2006RecipesCreditsText
      , "cuisines" .= inlineResponse2006RecipesCuisines
      , "dairyFree" .= inlineResponse2006RecipesDairyFree
      , "diets" .= inlineResponse2006RecipesDiets
      , "gaps" .= inlineResponse2006RecipesGaps
      , "glutenFree" .= inlineResponse2006RecipesGlutenFree
      , "instructions" .= inlineResponse2006RecipesInstructions
      , "ketogenic" .= inlineResponse2006RecipesKetogenic
      , "lowFodmap" .= inlineResponse2006RecipesLowFodmap
      , "occasions" .= inlineResponse2006RecipesOccasions
      , "sustainable" .= inlineResponse2006RecipesSustainable
      , "vegan" .= inlineResponse2006RecipesVegan
      , "vegetarian" .= inlineResponse2006RecipesVegetarian
      , "veryHealthy" .= inlineResponse2006RecipesVeryHealthy
      , "veryPopular" .= inlineResponse2006RecipesVeryPopular
      , "whole30" .= inlineResponse2006RecipesWhole30
      , "weightWatcherSmartPoints" .= inlineResponse2006RecipesWeightWatcherSmartPoints
      , "dishTypes" .= inlineResponse2006RecipesDishTypes
      , "extendedIngredients" .= inlineResponse2006RecipesExtendedIngredients
      , "summary" .= inlineResponse2006RecipesSummary
      , "winePairing" .= inlineResponse2006RecipesWinePairing
      ]


-- | Construct a value of type 'InlineResponse2006Recipes' (by applying it's required fields, if any)
mkInlineResponse2006Recipes
  :: Int -- ^ 'inlineResponse2006RecipesId' 
  -> Text -- ^ 'inlineResponse2006RecipesTitle' 
  -> Text -- ^ 'inlineResponse2006RecipesImage' 
  -> Text -- ^ 'inlineResponse2006RecipesImageType' 
  -> Double -- ^ 'inlineResponse2006RecipesServings' 
  -> Int -- ^ 'inlineResponse2006RecipesReadyInMinutes' 
  -> Text -- ^ 'inlineResponse2006RecipesLicense' 
  -> Text -- ^ 'inlineResponse2006RecipesSourceName' 
  -> Text -- ^ 'inlineResponse2006RecipesSourceUrl' 
  -> Text -- ^ 'inlineResponse2006RecipesSpoonacularSourceUrl' 
  -> Double -- ^ 'inlineResponse2006RecipesAggregateLikes' 
  -> Double -- ^ 'inlineResponse2006RecipesHealthScore' 
  -> Double -- ^ 'inlineResponse2006RecipesSpoonacularScore' 
  -> Double -- ^ 'inlineResponse2006RecipesPricePerServing' 
  -> Bool -- ^ 'inlineResponse2006RecipesCheap' 
  -> Text -- ^ 'inlineResponse2006RecipesCreditsText' 
  -> Bool -- ^ 'inlineResponse2006RecipesDairyFree' 
  -> Text -- ^ 'inlineResponse2006RecipesGaps' 
  -> Bool -- ^ 'inlineResponse2006RecipesGlutenFree' 
  -> Text -- ^ 'inlineResponse2006RecipesInstructions' 
  -> Bool -- ^ 'inlineResponse2006RecipesKetogenic' 
  -> Bool -- ^ 'inlineResponse2006RecipesLowFodmap' 
  -> Bool -- ^ 'inlineResponse2006RecipesSustainable' 
  -> Bool -- ^ 'inlineResponse2006RecipesVegan' 
  -> Bool -- ^ 'inlineResponse2006RecipesVegetarian' 
  -> Bool -- ^ 'inlineResponse2006RecipesVeryHealthy' 
  -> Bool -- ^ 'inlineResponse2006RecipesVeryPopular' 
  -> Bool -- ^ 'inlineResponse2006RecipesWhole30' 
  -> Double -- ^ 'inlineResponse2006RecipesWeightWatcherSmartPoints' 
  -> Text -- ^ 'inlineResponse2006RecipesSummary' 
  -> InlineResponse2006Recipes
mkInlineResponse2006Recipes inlineResponse2006RecipesId inlineResponse2006RecipesTitle inlineResponse2006RecipesImage inlineResponse2006RecipesImageType inlineResponse2006RecipesServings inlineResponse2006RecipesReadyInMinutes inlineResponse2006RecipesLicense inlineResponse2006RecipesSourceName inlineResponse2006RecipesSourceUrl inlineResponse2006RecipesSpoonacularSourceUrl inlineResponse2006RecipesAggregateLikes inlineResponse2006RecipesHealthScore inlineResponse2006RecipesSpoonacularScore inlineResponse2006RecipesPricePerServing inlineResponse2006RecipesCheap inlineResponse2006RecipesCreditsText inlineResponse2006RecipesDairyFree inlineResponse2006RecipesGaps inlineResponse2006RecipesGlutenFree inlineResponse2006RecipesInstructions inlineResponse2006RecipesKetogenic inlineResponse2006RecipesLowFodmap inlineResponse2006RecipesSustainable inlineResponse2006RecipesVegan inlineResponse2006RecipesVegetarian inlineResponse2006RecipesVeryHealthy inlineResponse2006RecipesVeryPopular inlineResponse2006RecipesWhole30 inlineResponse2006RecipesWeightWatcherSmartPoints inlineResponse2006RecipesSummary =
  InlineResponse2006Recipes
  { inlineResponse2006RecipesId
  , inlineResponse2006RecipesTitle
  , inlineResponse2006RecipesImage
  , inlineResponse2006RecipesImageType
  , inlineResponse2006RecipesServings
  , inlineResponse2006RecipesReadyInMinutes
  , inlineResponse2006RecipesLicense
  , inlineResponse2006RecipesSourceName
  , inlineResponse2006RecipesSourceUrl
  , inlineResponse2006RecipesSpoonacularSourceUrl
  , inlineResponse2006RecipesAggregateLikes
  , inlineResponse2006RecipesHealthScore
  , inlineResponse2006RecipesSpoonacularScore
  , inlineResponse2006RecipesPricePerServing
  , inlineResponse2006RecipesAnalyzedInstructions = Nothing
  , inlineResponse2006RecipesCheap
  , inlineResponse2006RecipesCreditsText
  , inlineResponse2006RecipesCuisines = Nothing
  , inlineResponse2006RecipesDairyFree
  , inlineResponse2006RecipesDiets = Nothing
  , inlineResponse2006RecipesGaps
  , inlineResponse2006RecipesGlutenFree
  , inlineResponse2006RecipesInstructions
  , inlineResponse2006RecipesKetogenic
  , inlineResponse2006RecipesLowFodmap
  , inlineResponse2006RecipesOccasions = Nothing
  , inlineResponse2006RecipesSustainable
  , inlineResponse2006RecipesVegan
  , inlineResponse2006RecipesVegetarian
  , inlineResponse2006RecipesVeryHealthy
  , inlineResponse2006RecipesVeryPopular
  , inlineResponse2006RecipesWhole30
  , inlineResponse2006RecipesWeightWatcherSmartPoints
  , inlineResponse2006RecipesDishTypes = Nothing
  , inlineResponse2006RecipesExtendedIngredients = Nothing
  , inlineResponse2006RecipesSummary
  , inlineResponse2006RecipesWinePairing = Nothing
  }

-- ** InlineResponse2007
-- | InlineResponse2007
data InlineResponse2007 = InlineResponse2007
  { inlineResponse2007Id :: !(Int) -- ^ /Required/ "id"
  , inlineResponse2007Title :: !(Text) -- ^ /Required/ "title"
  , inlineResponse2007ImageType :: !(Text) -- ^ /Required/ "imageType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2007
instance A.FromJSON InlineResponse2007 where
  parseJSON = A.withObject "InlineResponse2007" $ \o ->
    InlineResponse2007
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "imageType")

-- | ToJSON InlineResponse2007
instance A.ToJSON InlineResponse2007 where
  toJSON InlineResponse2007 {..} =
   _omitNulls
      [ "id" .= inlineResponse2007Id
      , "title" .= inlineResponse2007Title
      , "imageType" .= inlineResponse2007ImageType
      ]


-- | Construct a value of type 'InlineResponse2007' (by applying it's required fields, if any)
mkInlineResponse2007
  :: Int -- ^ 'inlineResponse2007Id' 
  -> Text -- ^ 'inlineResponse2007Title' 
  -> Text -- ^ 'inlineResponse2007ImageType' 
  -> InlineResponse2007
mkInlineResponse2007 inlineResponse2007Id inlineResponse2007Title inlineResponse2007ImageType =
  InlineResponse2007
  { inlineResponse2007Id
  , inlineResponse2007Title
  , inlineResponse2007ImageType
  }

-- ** InlineResponse2008
-- | InlineResponse2008
data InlineResponse2008 = InlineResponse2008
  { inlineResponse2008Sweetness :: !(Double) -- ^ /Required/ "sweetness"
  , inlineResponse2008Saltiness :: !(Double) -- ^ /Required/ "saltiness"
  , inlineResponse2008Sourness :: !(Double) -- ^ /Required/ "sourness"
  , inlineResponse2008Bitterness :: !(Double) -- ^ /Required/ "bitterness"
  , inlineResponse2008Savoriness :: !(Double) -- ^ /Required/ "savoriness"
  , inlineResponse2008Fattiness :: !(Double) -- ^ /Required/ "fattiness"
  , inlineResponse2008Spiciness :: !(Double) -- ^ /Required/ "spiciness"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2008
instance A.FromJSON InlineResponse2008 where
  parseJSON = A.withObject "InlineResponse2008" $ \o ->
    InlineResponse2008
      <$> (o .:  "sweetness")
      <*> (o .:  "saltiness")
      <*> (o .:  "sourness")
      <*> (o .:  "bitterness")
      <*> (o .:  "savoriness")
      <*> (o .:  "fattiness")
      <*> (o .:  "spiciness")

-- | ToJSON InlineResponse2008
instance A.ToJSON InlineResponse2008 where
  toJSON InlineResponse2008 {..} =
   _omitNulls
      [ "sweetness" .= inlineResponse2008Sweetness
      , "saltiness" .= inlineResponse2008Saltiness
      , "sourness" .= inlineResponse2008Sourness
      , "bitterness" .= inlineResponse2008Bitterness
      , "savoriness" .= inlineResponse2008Savoriness
      , "fattiness" .= inlineResponse2008Fattiness
      , "spiciness" .= inlineResponse2008Spiciness
      ]


-- | Construct a value of type 'InlineResponse2008' (by applying it's required fields, if any)
mkInlineResponse2008
  :: Double -- ^ 'inlineResponse2008Sweetness' 
  -> Double -- ^ 'inlineResponse2008Saltiness' 
  -> Double -- ^ 'inlineResponse2008Sourness' 
  -> Double -- ^ 'inlineResponse2008Bitterness' 
  -> Double -- ^ 'inlineResponse2008Savoriness' 
  -> Double -- ^ 'inlineResponse2008Fattiness' 
  -> Double -- ^ 'inlineResponse2008Spiciness' 
  -> InlineResponse2008
mkInlineResponse2008 inlineResponse2008Sweetness inlineResponse2008Saltiness inlineResponse2008Sourness inlineResponse2008Bitterness inlineResponse2008Savoriness inlineResponse2008Fattiness inlineResponse2008Spiciness =
  InlineResponse2008
  { inlineResponse2008Sweetness
  , inlineResponse2008Saltiness
  , inlineResponse2008Sourness
  , inlineResponse2008Bitterness
  , inlineResponse2008Savoriness
  , inlineResponse2008Fattiness
  , inlineResponse2008Spiciness
  }

-- ** InlineResponse2009
-- | InlineResponse2009
data InlineResponse2009 = InlineResponse2009
  { inlineResponse2009Equipment :: !([A.Value]) -- ^ /Required/ "equipment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2009
instance A.FromJSON InlineResponse2009 where
  parseJSON = A.withObject "InlineResponse2009" $ \o ->
    InlineResponse2009
      <$> (o .:  "equipment")

-- | ToJSON InlineResponse2009
instance A.ToJSON InlineResponse2009 where
  toJSON InlineResponse2009 {..} =
   _omitNulls
      [ "equipment" .= inlineResponse2009Equipment
      ]


-- | Construct a value of type 'InlineResponse2009' (by applying it's required fields, if any)
mkInlineResponse2009
  :: [A.Value] -- ^ 'inlineResponse2009Equipment' 
  -> InlineResponse2009
mkInlineResponse2009 inlineResponse2009Equipment =
  InlineResponse2009
  { inlineResponse2009Equipment
  }

-- ** InlineResponse200Results
-- | InlineResponse200Results
data InlineResponse200Results = InlineResponse200Results
  { inlineResponse200ResultsId :: !(Int) -- ^ /Required/ "id"
  , inlineResponse200ResultsTitle :: !(Text) -- ^ /Required/ "title"
  , inlineResponse200ResultsCalories :: !(Double) -- ^ /Required/ "calories"
  , inlineResponse200ResultsCarbs :: !(Text) -- ^ /Required/ "carbs"
  , inlineResponse200ResultsFat :: !(Text) -- ^ /Required/ "fat"
  , inlineResponse200ResultsImage :: !(Text) -- ^ /Required/ "image"
  , inlineResponse200ResultsImageType :: !(Text) -- ^ /Required/ "imageType"
  , inlineResponse200ResultsProtein :: !(Text) -- ^ /Required/ "protein"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200Results
instance A.FromJSON InlineResponse200Results where
  parseJSON = A.withObject "InlineResponse200Results" $ \o ->
    InlineResponse200Results
      <$> (o .:  "id")
      <*> (o .:  "title")
      <*> (o .:  "calories")
      <*> (o .:  "carbs")
      <*> (o .:  "fat")
      <*> (o .:  "image")
      <*> (o .:  "imageType")
      <*> (o .:  "protein")

-- | ToJSON InlineResponse200Results
instance A.ToJSON InlineResponse200Results where
  toJSON InlineResponse200Results {..} =
   _omitNulls
      [ "id" .= inlineResponse200ResultsId
      , "title" .= inlineResponse200ResultsTitle
      , "calories" .= inlineResponse200ResultsCalories
      , "carbs" .= inlineResponse200ResultsCarbs
      , "fat" .= inlineResponse200ResultsFat
      , "image" .= inlineResponse200ResultsImage
      , "imageType" .= inlineResponse200ResultsImageType
      , "protein" .= inlineResponse200ResultsProtein
      ]


-- | Construct a value of type 'InlineResponse200Results' (by applying it's required fields, if any)
mkInlineResponse200Results
  :: Int -- ^ 'inlineResponse200ResultsId' 
  -> Text -- ^ 'inlineResponse200ResultsTitle' 
  -> Double -- ^ 'inlineResponse200ResultsCalories' 
  -> Text -- ^ 'inlineResponse200ResultsCarbs' 
  -> Text -- ^ 'inlineResponse200ResultsFat' 
  -> Text -- ^ 'inlineResponse200ResultsImage' 
  -> Text -- ^ 'inlineResponse200ResultsImageType' 
  -> Text -- ^ 'inlineResponse200ResultsProtein' 
  -> InlineResponse200Results
mkInlineResponse200Results inlineResponse200ResultsId inlineResponse200ResultsTitle inlineResponse200ResultsCalories inlineResponse200ResultsCarbs inlineResponse200ResultsFat inlineResponse200ResultsImage inlineResponse200ResultsImageType inlineResponse200ResultsProtein =
  InlineResponse200Results
  { inlineResponse200ResultsId
  , inlineResponse200ResultsTitle
  , inlineResponse200ResultsCalories
  , inlineResponse200ResultsCarbs
  , inlineResponse200ResultsFat
  , inlineResponse200ResultsImage
  , inlineResponse200ResultsImageType
  , inlineResponse200ResultsProtein
  }

-- ** RecipesFindByIngredientsMissedIngredients
-- | RecipesFindByIngredientsMissedIngredients
data RecipesFindByIngredientsMissedIngredients = RecipesFindByIngredientsMissedIngredients
  { recipesFindByIngredientsMissedIngredientsAisle :: !(Text) -- ^ /Required/ "aisle"
  , recipesFindByIngredientsMissedIngredientsAmount :: !(Double) -- ^ /Required/ "amount"
  , recipesFindByIngredientsMissedIngredientsId :: !(Int) -- ^ /Required/ "id"
  , recipesFindByIngredientsMissedIngredientsImage :: !(Text) -- ^ /Required/ "image"
  , recipesFindByIngredientsMissedIngredientsMeta :: !(Maybe [Text]) -- ^ "meta"
  , recipesFindByIngredientsMissedIngredientsName :: !(Text) -- ^ /Required/ "name"
  , recipesFindByIngredientsMissedIngredientsOriginal :: !(Text) -- ^ /Required/ "original"
  , recipesFindByIngredientsMissedIngredientsOriginalName :: !(Text) -- ^ /Required/ "originalName"
  , recipesFindByIngredientsMissedIngredientsUnit :: !(Text) -- ^ /Required/ "unit"
  , recipesFindByIngredientsMissedIngredientsUnitLong :: !(Text) -- ^ /Required/ "unitLong"
  , recipesFindByIngredientsMissedIngredientsUnitShort :: !(Text) -- ^ /Required/ "unitShort"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecipesFindByIngredientsMissedIngredients
instance A.FromJSON RecipesFindByIngredientsMissedIngredients where
  parseJSON = A.withObject "RecipesFindByIngredientsMissedIngredients" $ \o ->
    RecipesFindByIngredientsMissedIngredients
      <$> (o .:  "aisle")
      <*> (o .:  "amount")
      <*> (o .:  "id")
      <*> (o .:  "image")
      <*> (o .:? "meta")
      <*> (o .:  "name")
      <*> (o .:  "original")
      <*> (o .:  "originalName")
      <*> (o .:  "unit")
      <*> (o .:  "unitLong")
      <*> (o .:  "unitShort")

-- | ToJSON RecipesFindByIngredientsMissedIngredients
instance A.ToJSON RecipesFindByIngredientsMissedIngredients where
  toJSON RecipesFindByIngredientsMissedIngredients {..} =
   _omitNulls
      [ "aisle" .= recipesFindByIngredientsMissedIngredientsAisle
      , "amount" .= recipesFindByIngredientsMissedIngredientsAmount
      , "id" .= recipesFindByIngredientsMissedIngredientsId
      , "image" .= recipesFindByIngredientsMissedIngredientsImage
      , "meta" .= recipesFindByIngredientsMissedIngredientsMeta
      , "name" .= recipesFindByIngredientsMissedIngredientsName
      , "original" .= recipesFindByIngredientsMissedIngredientsOriginal
      , "originalName" .= recipesFindByIngredientsMissedIngredientsOriginalName
      , "unit" .= recipesFindByIngredientsMissedIngredientsUnit
      , "unitLong" .= recipesFindByIngredientsMissedIngredientsUnitLong
      , "unitShort" .= recipesFindByIngredientsMissedIngredientsUnitShort
      ]


-- | Construct a value of type 'RecipesFindByIngredientsMissedIngredients' (by applying it's required fields, if any)
mkRecipesFindByIngredientsMissedIngredients
  :: Text -- ^ 'recipesFindByIngredientsMissedIngredientsAisle' 
  -> Double -- ^ 'recipesFindByIngredientsMissedIngredientsAmount' 
  -> Int -- ^ 'recipesFindByIngredientsMissedIngredientsId' 
  -> Text -- ^ 'recipesFindByIngredientsMissedIngredientsImage' 
  -> Text -- ^ 'recipesFindByIngredientsMissedIngredientsName' 
  -> Text -- ^ 'recipesFindByIngredientsMissedIngredientsOriginal' 
  -> Text -- ^ 'recipesFindByIngredientsMissedIngredientsOriginalName' 
  -> Text -- ^ 'recipesFindByIngredientsMissedIngredientsUnit' 
  -> Text -- ^ 'recipesFindByIngredientsMissedIngredientsUnitLong' 
  -> Text -- ^ 'recipesFindByIngredientsMissedIngredientsUnitShort' 
  -> RecipesFindByIngredientsMissedIngredients
mkRecipesFindByIngredientsMissedIngredients recipesFindByIngredientsMissedIngredientsAisle recipesFindByIngredientsMissedIngredientsAmount recipesFindByIngredientsMissedIngredientsId recipesFindByIngredientsMissedIngredientsImage recipesFindByIngredientsMissedIngredientsName recipesFindByIngredientsMissedIngredientsOriginal recipesFindByIngredientsMissedIngredientsOriginalName recipesFindByIngredientsMissedIngredientsUnit recipesFindByIngredientsMissedIngredientsUnitLong recipesFindByIngredientsMissedIngredientsUnitShort =
  RecipesFindByIngredientsMissedIngredients
  { recipesFindByIngredientsMissedIngredientsAisle
  , recipesFindByIngredientsMissedIngredientsAmount
  , recipesFindByIngredientsMissedIngredientsId
  , recipesFindByIngredientsMissedIngredientsImage
  , recipesFindByIngredientsMissedIngredientsMeta = Nothing
  , recipesFindByIngredientsMissedIngredientsName
  , recipesFindByIngredientsMissedIngredientsOriginal
  , recipesFindByIngredientsMissedIngredientsOriginalName
  , recipesFindByIngredientsMissedIngredientsUnit
  , recipesFindByIngredientsMissedIngredientsUnitLong
  , recipesFindByIngredientsMissedIngredientsUnitShort
  }

-- ** RecipesParseIngredientsEstimatedCost
-- | RecipesParseIngredientsEstimatedCost
data RecipesParseIngredientsEstimatedCost = RecipesParseIngredientsEstimatedCost
  { recipesParseIngredientsEstimatedCostValue :: !(Double) -- ^ /Required/ "value"
  , recipesParseIngredientsEstimatedCostUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecipesParseIngredientsEstimatedCost
instance A.FromJSON RecipesParseIngredientsEstimatedCost where
  parseJSON = A.withObject "RecipesParseIngredientsEstimatedCost" $ \o ->
    RecipesParseIngredientsEstimatedCost
      <$> (o .:  "value")
      <*> (o .:  "unit")

-- | ToJSON RecipesParseIngredientsEstimatedCost
instance A.ToJSON RecipesParseIngredientsEstimatedCost where
  toJSON RecipesParseIngredientsEstimatedCost {..} =
   _omitNulls
      [ "value" .= recipesParseIngredientsEstimatedCostValue
      , "unit" .= recipesParseIngredientsEstimatedCostUnit
      ]


-- | Construct a value of type 'RecipesParseIngredientsEstimatedCost' (by applying it's required fields, if any)
mkRecipesParseIngredientsEstimatedCost
  :: Double -- ^ 'recipesParseIngredientsEstimatedCostValue' 
  -> Text -- ^ 'recipesParseIngredientsEstimatedCostUnit' 
  -> RecipesParseIngredientsEstimatedCost
mkRecipesParseIngredientsEstimatedCost recipesParseIngredientsEstimatedCostValue recipesParseIngredientsEstimatedCostUnit =
  RecipesParseIngredientsEstimatedCost
  { recipesParseIngredientsEstimatedCostValue
  , recipesParseIngredientsEstimatedCostUnit
  }

-- ** RecipesParseIngredientsNutrition
-- | RecipesParseIngredientsNutrition
data RecipesParseIngredientsNutrition = RecipesParseIngredientsNutrition
  { recipesParseIngredientsNutritionNutrients :: !([RecipesParseIngredientsNutritionNutrients]) -- ^ /Required/ "nutrients"
  , recipesParseIngredientsNutritionProperties :: !([RecipesParseIngredientsNutritionProperties]) -- ^ /Required/ "properties"
  , recipesParseIngredientsNutritionFlavonoids :: !([RecipesParseIngredientsNutritionProperties]) -- ^ /Required/ "flavonoids"
  , recipesParseIngredientsNutritionCaloricBreakdown :: !(RecipesParseIngredientsNutritionCaloricBreakdown) -- ^ /Required/ "caloricBreakdown"
  , recipesParseIngredientsNutritionWeightPerServing :: !(RecipesParseIngredientsNutritionWeightPerServing) -- ^ /Required/ "weightPerServing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecipesParseIngredientsNutrition
instance A.FromJSON RecipesParseIngredientsNutrition where
  parseJSON = A.withObject "RecipesParseIngredientsNutrition" $ \o ->
    RecipesParseIngredientsNutrition
      <$> (o .:  "nutrients")
      <*> (o .:  "properties")
      <*> (o .:  "flavonoids")
      <*> (o .:  "caloricBreakdown")
      <*> (o .:  "weightPerServing")

-- | ToJSON RecipesParseIngredientsNutrition
instance A.ToJSON RecipesParseIngredientsNutrition where
  toJSON RecipesParseIngredientsNutrition {..} =
   _omitNulls
      [ "nutrients" .= recipesParseIngredientsNutritionNutrients
      , "properties" .= recipesParseIngredientsNutritionProperties
      , "flavonoids" .= recipesParseIngredientsNutritionFlavonoids
      , "caloricBreakdown" .= recipesParseIngredientsNutritionCaloricBreakdown
      , "weightPerServing" .= recipesParseIngredientsNutritionWeightPerServing
      ]


-- | Construct a value of type 'RecipesParseIngredientsNutrition' (by applying it's required fields, if any)
mkRecipesParseIngredientsNutrition
  :: [RecipesParseIngredientsNutritionNutrients] -- ^ 'recipesParseIngredientsNutritionNutrients' 
  -> [RecipesParseIngredientsNutritionProperties] -- ^ 'recipesParseIngredientsNutritionProperties' 
  -> [RecipesParseIngredientsNutritionProperties] -- ^ 'recipesParseIngredientsNutritionFlavonoids' 
  -> RecipesParseIngredientsNutritionCaloricBreakdown -- ^ 'recipesParseIngredientsNutritionCaloricBreakdown' 
  -> RecipesParseIngredientsNutritionWeightPerServing -- ^ 'recipesParseIngredientsNutritionWeightPerServing' 
  -> RecipesParseIngredientsNutrition
mkRecipesParseIngredientsNutrition recipesParseIngredientsNutritionNutrients recipesParseIngredientsNutritionProperties recipesParseIngredientsNutritionFlavonoids recipesParseIngredientsNutritionCaloricBreakdown recipesParseIngredientsNutritionWeightPerServing =
  RecipesParseIngredientsNutrition
  { recipesParseIngredientsNutritionNutrients
  , recipesParseIngredientsNutritionProperties
  , recipesParseIngredientsNutritionFlavonoids
  , recipesParseIngredientsNutritionCaloricBreakdown
  , recipesParseIngredientsNutritionWeightPerServing
  }

-- ** RecipesParseIngredientsNutritionCaloricBreakdown
-- | RecipesParseIngredientsNutritionCaloricBreakdown
data RecipesParseIngredientsNutritionCaloricBreakdown = RecipesParseIngredientsNutritionCaloricBreakdown
  { recipesParseIngredientsNutritionCaloricBreakdownPercentProtein :: !(Double) -- ^ /Required/ "percentProtein"
  , recipesParseIngredientsNutritionCaloricBreakdownPercentFat :: !(Double) -- ^ /Required/ "percentFat"
  , recipesParseIngredientsNutritionCaloricBreakdownPercentCarbs :: !(Double) -- ^ /Required/ "percentCarbs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecipesParseIngredientsNutritionCaloricBreakdown
instance A.FromJSON RecipesParseIngredientsNutritionCaloricBreakdown where
  parseJSON = A.withObject "RecipesParseIngredientsNutritionCaloricBreakdown" $ \o ->
    RecipesParseIngredientsNutritionCaloricBreakdown
      <$> (o .:  "percentProtein")
      <*> (o .:  "percentFat")
      <*> (o .:  "percentCarbs")

-- | ToJSON RecipesParseIngredientsNutritionCaloricBreakdown
instance A.ToJSON RecipesParseIngredientsNutritionCaloricBreakdown where
  toJSON RecipesParseIngredientsNutritionCaloricBreakdown {..} =
   _omitNulls
      [ "percentProtein" .= recipesParseIngredientsNutritionCaloricBreakdownPercentProtein
      , "percentFat" .= recipesParseIngredientsNutritionCaloricBreakdownPercentFat
      , "percentCarbs" .= recipesParseIngredientsNutritionCaloricBreakdownPercentCarbs
      ]


-- | Construct a value of type 'RecipesParseIngredientsNutritionCaloricBreakdown' (by applying it's required fields, if any)
mkRecipesParseIngredientsNutritionCaloricBreakdown
  :: Double -- ^ 'recipesParseIngredientsNutritionCaloricBreakdownPercentProtein' 
  -> Double -- ^ 'recipesParseIngredientsNutritionCaloricBreakdownPercentFat' 
  -> Double -- ^ 'recipesParseIngredientsNutritionCaloricBreakdownPercentCarbs' 
  -> RecipesParseIngredientsNutritionCaloricBreakdown
mkRecipesParseIngredientsNutritionCaloricBreakdown recipesParseIngredientsNutritionCaloricBreakdownPercentProtein recipesParseIngredientsNutritionCaloricBreakdownPercentFat recipesParseIngredientsNutritionCaloricBreakdownPercentCarbs =
  RecipesParseIngredientsNutritionCaloricBreakdown
  { recipesParseIngredientsNutritionCaloricBreakdownPercentProtein
  , recipesParseIngredientsNutritionCaloricBreakdownPercentFat
  , recipesParseIngredientsNutritionCaloricBreakdownPercentCarbs
  }

-- ** RecipesParseIngredientsNutritionNutrients
-- | RecipesParseIngredientsNutritionNutrients
data RecipesParseIngredientsNutritionNutrients = RecipesParseIngredientsNutritionNutrients
  { recipesParseIngredientsNutritionNutrientsName :: !(Text) -- ^ /Required/ "name"
  , recipesParseIngredientsNutritionNutrientsAmount :: !(Double) -- ^ /Required/ "amount"
  , recipesParseIngredientsNutritionNutrientsUnit :: !(Text) -- ^ /Required/ "unit"
  , recipesParseIngredientsNutritionNutrientsPercentOfDailyNeeds :: !(Double) -- ^ /Required/ "percentOfDailyNeeds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecipesParseIngredientsNutritionNutrients
instance A.FromJSON RecipesParseIngredientsNutritionNutrients where
  parseJSON = A.withObject "RecipesParseIngredientsNutritionNutrients" $ \o ->
    RecipesParseIngredientsNutritionNutrients
      <$> (o .:  "name")
      <*> (o .:  "amount")
      <*> (o .:  "unit")
      <*> (o .:  "percentOfDailyNeeds")

-- | ToJSON RecipesParseIngredientsNutritionNutrients
instance A.ToJSON RecipesParseIngredientsNutritionNutrients where
  toJSON RecipesParseIngredientsNutritionNutrients {..} =
   _omitNulls
      [ "name" .= recipesParseIngredientsNutritionNutrientsName
      , "amount" .= recipesParseIngredientsNutritionNutrientsAmount
      , "unit" .= recipesParseIngredientsNutritionNutrientsUnit
      , "percentOfDailyNeeds" .= recipesParseIngredientsNutritionNutrientsPercentOfDailyNeeds
      ]


-- | Construct a value of type 'RecipesParseIngredientsNutritionNutrients' (by applying it's required fields, if any)
mkRecipesParseIngredientsNutritionNutrients
  :: Text -- ^ 'recipesParseIngredientsNutritionNutrientsName' 
  -> Double -- ^ 'recipesParseIngredientsNutritionNutrientsAmount' 
  -> Text -- ^ 'recipesParseIngredientsNutritionNutrientsUnit' 
  -> Double -- ^ 'recipesParseIngredientsNutritionNutrientsPercentOfDailyNeeds' 
  -> RecipesParseIngredientsNutritionNutrients
mkRecipesParseIngredientsNutritionNutrients recipesParseIngredientsNutritionNutrientsName recipesParseIngredientsNutritionNutrientsAmount recipesParseIngredientsNutritionNutrientsUnit recipesParseIngredientsNutritionNutrientsPercentOfDailyNeeds =
  RecipesParseIngredientsNutritionNutrients
  { recipesParseIngredientsNutritionNutrientsName
  , recipesParseIngredientsNutritionNutrientsAmount
  , recipesParseIngredientsNutritionNutrientsUnit
  , recipesParseIngredientsNutritionNutrientsPercentOfDailyNeeds
  }

-- ** RecipesParseIngredientsNutritionProperties
-- | RecipesParseIngredientsNutritionProperties
data RecipesParseIngredientsNutritionProperties = RecipesParseIngredientsNutritionProperties
  { recipesParseIngredientsNutritionPropertiesName :: !(Text) -- ^ /Required/ "name"
  , recipesParseIngredientsNutritionPropertiesAmount :: !(Double) -- ^ /Required/ "amount"
  , recipesParseIngredientsNutritionPropertiesUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecipesParseIngredientsNutritionProperties
instance A.FromJSON RecipesParseIngredientsNutritionProperties where
  parseJSON = A.withObject "RecipesParseIngredientsNutritionProperties" $ \o ->
    RecipesParseIngredientsNutritionProperties
      <$> (o .:  "name")
      <*> (o .:  "amount")
      <*> (o .:  "unit")

-- | ToJSON RecipesParseIngredientsNutritionProperties
instance A.ToJSON RecipesParseIngredientsNutritionProperties where
  toJSON RecipesParseIngredientsNutritionProperties {..} =
   _omitNulls
      [ "name" .= recipesParseIngredientsNutritionPropertiesName
      , "amount" .= recipesParseIngredientsNutritionPropertiesAmount
      , "unit" .= recipesParseIngredientsNutritionPropertiesUnit
      ]


-- | Construct a value of type 'RecipesParseIngredientsNutritionProperties' (by applying it's required fields, if any)
mkRecipesParseIngredientsNutritionProperties
  :: Text -- ^ 'recipesParseIngredientsNutritionPropertiesName' 
  -> Double -- ^ 'recipesParseIngredientsNutritionPropertiesAmount' 
  -> Text -- ^ 'recipesParseIngredientsNutritionPropertiesUnit' 
  -> RecipesParseIngredientsNutritionProperties
mkRecipesParseIngredientsNutritionProperties recipesParseIngredientsNutritionPropertiesName recipesParseIngredientsNutritionPropertiesAmount recipesParseIngredientsNutritionPropertiesUnit =
  RecipesParseIngredientsNutritionProperties
  { recipesParseIngredientsNutritionPropertiesName
  , recipesParseIngredientsNutritionPropertiesAmount
  , recipesParseIngredientsNutritionPropertiesUnit
  }

-- ** RecipesParseIngredientsNutritionWeightPerServing
-- | RecipesParseIngredientsNutritionWeightPerServing
data RecipesParseIngredientsNutritionWeightPerServing = RecipesParseIngredientsNutritionWeightPerServing
  { recipesParseIngredientsNutritionWeightPerServingAmount :: !(Double) -- ^ /Required/ "amount"
  , recipesParseIngredientsNutritionWeightPerServingUnit :: !(Text) -- ^ /Required/ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecipesParseIngredientsNutritionWeightPerServing
instance A.FromJSON RecipesParseIngredientsNutritionWeightPerServing where
  parseJSON = A.withObject "RecipesParseIngredientsNutritionWeightPerServing" $ \o ->
    RecipesParseIngredientsNutritionWeightPerServing
      <$> (o .:  "amount")
      <*> (o .:  "unit")

-- | ToJSON RecipesParseIngredientsNutritionWeightPerServing
instance A.ToJSON RecipesParseIngredientsNutritionWeightPerServing where
  toJSON RecipesParseIngredientsNutritionWeightPerServing {..} =
   _omitNulls
      [ "amount" .= recipesParseIngredientsNutritionWeightPerServingAmount
      , "unit" .= recipesParseIngredientsNutritionWeightPerServingUnit
      ]


-- | Construct a value of type 'RecipesParseIngredientsNutritionWeightPerServing' (by applying it's required fields, if any)
mkRecipesParseIngredientsNutritionWeightPerServing
  :: Double -- ^ 'recipesParseIngredientsNutritionWeightPerServingAmount' 
  -> Text -- ^ 'recipesParseIngredientsNutritionWeightPerServingUnit' 
  -> RecipesParseIngredientsNutritionWeightPerServing
mkRecipesParseIngredientsNutritionWeightPerServing recipesParseIngredientsNutritionWeightPerServingAmount recipesParseIngredientsNutritionWeightPerServingUnit =
  RecipesParseIngredientsNutritionWeightPerServing
  { recipesParseIngredientsNutritionWeightPerServingAmount
  , recipesParseIngredientsNutritionWeightPerServingUnit
  }


-- * Enums


-- ** E'Accept

-- | Enum of 'Text'
data E'Accept
  = E'Accept'Application_json -- ^ @"application/json"@
  | E'Accept'Text_html -- ^ @"text/html"@
  | E'Accept'Media_ -- ^ @"media/*"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Accept where toJSON = A.toJSON . fromE'Accept
instance A.FromJSON E'Accept where parseJSON o = P.either P.fail (pure . P.id) . toE'Accept =<< A.parseJSON o
instance WH.ToHttpApiData E'Accept where toQueryParam = WH.toQueryParam . fromE'Accept
instance WH.FromHttpApiData E'Accept where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Accept
instance MimeRender MimeMultipartFormData E'Accept where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Accept' enum
fromE'Accept :: E'Accept -> Text
fromE'Accept = \case
  E'Accept'Application_json -> "application/json"
  E'Accept'Text_html -> "text/html"
  E'Accept'Media_ -> "media/*"

-- | parse 'E'Accept' enum
toE'Accept :: Text -> P.Either String E'Accept
toE'Accept = \case
  "application/json" -> P.Right E'Accept'Application_json
  "text/html" -> P.Right E'Accept'Text_html
  "media/*" -> P.Right E'Accept'Media_
  s -> P.Left $ "toE'Accept: enum parse failure: " P.++ P.show s


-- ** E'ContentType

-- | Enum of 'Text'
data E'ContentType
  = E'ContentType'Application_x_www_form_urlencoded -- ^ @"application/x-www-form-urlencoded"@
  | E'ContentType'Application_json -- ^ @"application/json"@
  | E'ContentType'Multipart_form_data -- ^ @"multipart/form-data"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ContentType where toJSON = A.toJSON . fromE'ContentType
instance A.FromJSON E'ContentType where parseJSON o = P.either P.fail (pure . P.id) . toE'ContentType =<< A.parseJSON o
instance WH.ToHttpApiData E'ContentType where toQueryParam = WH.toQueryParam . fromE'ContentType
instance WH.FromHttpApiData E'ContentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ContentType
instance MimeRender MimeMultipartFormData E'ContentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ContentType' enum
fromE'ContentType :: E'ContentType -> Text
fromE'ContentType = \case
  E'ContentType'Application_x_www_form_urlencoded -> "application/x-www-form-urlencoded"
  E'ContentType'Application_json -> "application/json"
  E'ContentType'Multipart_form_data -> "multipart/form-data"

-- | parse 'E'ContentType' enum
toE'ContentType :: Text -> P.Either String E'ContentType
toE'ContentType = \case
  "application/x-www-form-urlencoded" -> P.Right E'ContentType'Application_x_www_form_urlencoded
  "application/json" -> P.Right E'ContentType'Application_json
  "multipart/form-data" -> P.Right E'ContentType'Multipart_form_data
  s -> P.Left $ "toE'ContentType: enum parse failure: " P.++ P.show s


-- ** E'Language

-- | Enum of 'Text'
data E'Language
  = E'Language'En -- ^ @"en"@
  | E'Language'De -- ^ @"de"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Language where toJSON = A.toJSON . fromE'Language
instance A.FromJSON E'Language where parseJSON o = P.either P.fail (pure . P.id) . toE'Language =<< A.parseJSON o
instance WH.ToHttpApiData E'Language where toQueryParam = WH.toQueryParam . fromE'Language
instance WH.FromHttpApiData E'Language where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Language
instance MimeRender MimeMultipartFormData E'Language where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Language' enum
fromE'Language :: E'Language -> Text
fromE'Language = \case
  E'Language'En -> "en"
  E'Language'De -> "de"

-- | parse 'E'Language' enum
toE'Language :: Text -> P.Either String E'Language
toE'Language = \case
  "en" -> P.Right E'Language'En
  "de" -> P.Right E'Language'De
  s -> P.Left $ "toE'Language: enum parse failure: " P.++ P.show s


-- ** E'Locale

-- | Enum of 'Text'
data E'Locale
  = E'Locale'US -- ^ @"en_US"@
  | E'Locale'GB -- ^ @"en_GB"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Locale where toJSON = A.toJSON . fromE'Locale
instance A.FromJSON E'Locale where parseJSON o = P.either P.fail (pure . P.id) . toE'Locale =<< A.parseJSON o
instance WH.ToHttpApiData E'Locale where toQueryParam = WH.toQueryParam . fromE'Locale
instance WH.FromHttpApiData E'Locale where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Locale
instance MimeRender MimeMultipartFormData E'Locale where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Locale' enum
fromE'Locale :: E'Locale -> Text
fromE'Locale = \case
  E'Locale'US -> "en_US"
  E'Locale'GB -> "en_GB"

-- | parse 'E'Locale' enum
toE'Locale :: Text -> P.Either String E'Locale
toE'Locale = \case
  "en_US" -> P.Right E'Locale'US
  "en_GB" -> P.Right E'Locale'GB
  s -> P.Left $ "toE'Locale: enum parse failure: " P.++ P.show s


-- ** E'Measure

-- | Enum of 'Text'
data E'Measure
  = E'Measure'Us -- ^ @"us"@
  | E'Measure'Metric -- ^ @"metric"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Measure where toJSON = A.toJSON . fromE'Measure
instance A.FromJSON E'Measure where parseJSON o = P.either P.fail (pure . P.id) . toE'Measure =<< A.parseJSON o
instance WH.ToHttpApiData E'Measure where toQueryParam = WH.toQueryParam . fromE'Measure
instance WH.FromHttpApiData E'Measure where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Measure
instance MimeRender MimeMultipartFormData E'Measure where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Measure' enum
fromE'Measure :: E'Measure -> Text
fromE'Measure = \case
  E'Measure'Us -> "us"
  E'Measure'Metric -> "metric"

-- | parse 'E'Measure' enum
toE'Measure :: Text -> P.Either String E'Measure
toE'Measure = \case
  "us" -> P.Right E'Measure'Us
  "metric" -> P.Right E'Measure'Metric
  s -> P.Left $ "toE'Measure: enum parse failure: " P.++ P.show s


-- ** E'Normalize

-- | Enum of 'Bool'
data E'Normalize
  = E'Normalize'False -- ^ @"false"@
  | E'Normalize'True -- ^ @"true"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Normalize where toJSON = A.toJSON . fromE'Normalize
instance A.FromJSON E'Normalize where parseJSON o = P.either P.fail (pure . P.id) . toE'Normalize =<< A.parseJSON o
instance WH.ToHttpApiData E'Normalize where toQueryParam = WH.toQueryParam . fromE'Normalize
instance WH.FromHttpApiData E'Normalize where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Normalize
instance MimeRender MimeMultipartFormData E'Normalize where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Normalize' enum
fromE'Normalize :: E'Normalize -> Bool
fromE'Normalize = \case
  E'Normalize'False -> "false"
  E'Normalize'True -> "true"

-- | parse 'E'Normalize' enum
toE'Normalize :: Bool -> P.Either String E'Normalize
toE'Normalize = \case
  "false" -> P.Right E'Normalize'False
  "true" -> P.Right E'Normalize'True
  s -> P.Left $ "toE'Normalize: enum parse failure: " P.++ P.show s


-- ** E'Normalize2

-- | Enum of 'Bool'
data E'Normalize2
  = E'Normalize2'True -- ^ @"true"@
  | E'Normalize2'False -- ^ @"false"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Normalize2 where toJSON = A.toJSON . fromE'Normalize2
instance A.FromJSON E'Normalize2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Normalize2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Normalize2 where toQueryParam = WH.toQueryParam . fromE'Normalize2
instance WH.FromHttpApiData E'Normalize2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Normalize2
instance MimeRender MimeMultipartFormData E'Normalize2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Normalize2' enum
fromE'Normalize2 :: E'Normalize2 -> Bool
fromE'Normalize2 = \case
  E'Normalize2'True -> "true"
  E'Normalize2'False -> "false"

-- | parse 'E'Normalize2' enum
toE'Normalize2 :: Bool -> P.Either String E'Normalize2
toE'Normalize2 = \case
  "true" -> P.Right E'Normalize2'True
  "false" -> P.Right E'Normalize2'False
  s -> P.Left $ "toE'Normalize2: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKeyScheme
data AuthApiKeyApiKeyScheme =
  AuthApiKeyApiKeyScheme Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKeyScheme where
  applyAuthMethod _ a@(AuthApiKeyApiKeyScheme secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("apiKey", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


